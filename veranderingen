Syntax
    Lijst-datastructuur
        Lijst waarden [v_1,...,v_n]
        Lijst computaties [c_1,...,c_n]
    let rec (computatie)
        -- https://www.cs.cornell.edu/courses/cs6110/2018sp/lectures/lec11.pdf
        letrec f1 = λx1. v1 and ... and fn = λxn. vn in c 
        http://pages.di.unipi.it/corradini/Didattica/PR2-B-14/OpSem.pdf
        https://www.cs.swarthmore.edu/~zpalmer/cs73/s18/book.pdf
        Mike Grant Zachary Palmer Scott Smith, Principles of Programming Languages, Chapter 2
        letrec f x = c1 in c2
    reduce clausule
    for clausule
    head v 
    head c
    tail v
    tail c 
    empty v 
    empty c 
    fst v 
    snd v 
    map f v 

Semantiek

    E-Letrec 
    --------------------------------------------------------------------------------
        let rec f = c1 In c2 -> c2[c1[(let rec f = c1 in f)/f]/f]

    E-FwdFor
        (for _ _ _) not element of h    (reduce lstv k -> c) element of h
    -----------------------------------------------------------------------------------
        h # for lstv1 (y. c1) (lstv2. c2) -> for lstv1 (y. h # c1) (lstv3. c[lstv3/lstv, (lstv2. h # c2)/k])

    E-HandFor
            (for lstv1 p k)  element of h
    -----------------------------------------------------------------------
        h # map lstv2 (y. c1) (lstv3. c2) -> c[lstv1/x, (y. h # c1)/p, (lstv3. h # c2)/k]

    E-DoFor
    ------------------------------------------------------------------------------------------------------------
        do x <- for (v1:v2:...:vn:[]) (y. c1) (l. c2); c3 -> for (v1:v2:...:vn:[]) (y. c1) (l. do x <- c2; c3)

    E-Map             
    ------------------------------------------------------------------------------------------------------------
        map f (v1:v2:...:vn:[]) -> (f c1):(f c2):...:((f cn):[])

    -- TODO
    E-ParList     
        Exist j : !normal cj, ForAll i: ci->ci' <- !normal ci         
    ------------------------------------------------------------------
        (c1:...:ci:...:cn:[]) -> (c1:...:ci':...:cn:[]) 

    E-ListRet
    -------------------------------------------------------------------------------------------------
            ((return v1):(return v2):...:(return vn):[]) -> return (v1:v2:...:vn:[])

    E-Head
    -----------------------------
        head (c1:c) -> return c1

    E-First
    ----------------------------
        fst (x, y) -> return x

    E-Second
    ----------------------------
        snd (x, y) -> return y

    E-Tail
    ----------------------------
        tail (c1:c) -> c

    E-NullTrue
    ---------------------------
        null [] -> return True 

    E-NullFalse
    ---------------------------
        null (c1:c) -> return False

    E-IfTrue
    --------------------------------------
        if True then c1 else c2 -> c1

    E-IfFalse
    --------------------------------------
        if False then c1 else c2 -> c2

    E-If
                        c1->c1'
    -----------------------------------------------------
        if c1 then c2 else c3 -> if c1' then c2 else c3

Calculus
    ParList
    RetList
    Lijst values
    Lijst computations
    Lijst
    Head
    Tail
    Null
    let rec
    map