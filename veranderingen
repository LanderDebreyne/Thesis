Syntax
    Lijst-datastructuur [c_1,...,c_n,v_1,...,v_m] (is value v)
    letrec (is computation c)
        -- https://www.cs.cornell.edu/courses/cs6110/2018sp/lectures/lec11.pdf
        letrec f1 = λx1. v1 and ... and fn = λxn. vn in c 
        http://pages.di.unipi.it/corradini/Didattica/PR2-B-14/OpSem.pdf
        https://www.cs.swarthmore.edu/~zpalmer/cs73/s18/book.pdf
        Mike Grant Zachary Palmer Scott Smith, Principles of Programming Languages, Chapter 2
        letrec f x = c1 in c2
    (pc: parallel computation)

Semantiek

    E-Letrec 
    --------------------------------------------------------------------------------
        let rec f = c1 In c2 -> c2[c1[(let rec f = c1 in f)/f]/f]

    E-HandMap
                        (red l1 k -> c) element of h
    -----------------------------------------------------------------------------------
        h # map l2 (y. c1) (l3. c2) -> map l (y. h # c1) (l4. c[l3/l1, (l3. h # c2)/k])

    E-EffMap             
    ------------------------------------------------------------------------------------------------------------
        map (v1:v2:...:vn:[]) (y. c1) (l. c2) -> par (((y. c1) v1):((y. c1) v2):....:((y. c1) vn):[]) (l. c2)

    E-Map             
    ------------------------------------------------------------------------------------------------------------
        map (v. c) (v1:v2:...:vn:[]) -> (((v. c) c1):((v. c) c2):...:((v. c) cn):[])

    E-ParList     
            Exist j : !normal cj, ForAll i: ci->ci' <- !normal ci         
    ------------------------------------------------------------------------------------------------------------
        (c1:...:ci:...:cn:[]) -> (c1:...:ci':...:cn:[]) 

    E-ListRet
    -------------------------------------------------------------------------------------------------
            ((return v1):(return v2):...:(return vn):[]) -> return (v1:v2:...:vn:[])

    E-Par
        1. Exist i: ci->ci', !Exists k<i: ck->ck', ForAll j>i: cj->cj'  
        2. Exist j : !normal cj, ForAll i: ci->ci' <- !normal ci             
    ------------------------------------------------------------------
            par (c1:...:ci:...:cn:[]) (l. cn+1) -> (c1:...:ci':...:c:[]) (l. cn+1)


    E-ParNorRet
            ForAll i : ci = return vi 
    --------------------------------------------------------------------------
        par ((return v1):...:(return vn):[]) (l. c) -> (l. c) (v1:...:vn:[])

--    E-ParNor
--            ForAll i : return vi -> vi | op l v k -> op l v k | sc l v p k -> sc l v p k      
--    ------------------------------------------------------------------
--        par (c1:c2:...:cn:[]) (l. cn+1) -> (l. cn+1) (n1:n2:...:nn:[]) 

    E-Head
    -----------------------------
        head (c1:c) -> return c1

    E-First
    ----------------------------
        fst (x, y) -> return x

    E-Second
    ----------------------------
        snd (x, y) -> return y

    E-Tail
    ----------------------------
        tail (c1:c) -> c

    E-NullTrue
    ---------------------------
        null [] -> return True 

    E-NullFalse
    ---------------------------
        null (c1:c) -> return False

    E-IfTrue
    --------------------------------------
        if True then c1 else c2 -> c1

    E-IfFalse
    --------------------------------------
        if False then c1 else c2 -> c2

    E-If
                        c1->c1'
    -----------------------------------------------------
        if c1 then c2 else c3 -> if c1' then c2 else c3

    -- E-ParDo
    --                          c1->c1', ..., cn->cn', n != 0
    -- ---------------------------------------------------------------------------------
    --     do x <- [c1,...,cn,cn+1,...,cm]; cm+1 -> do x <- [c1',...,cn',cn+1,...,cm]; cm+1

    -- c1->c1', ..., cn->cn', n != 0
    --        [c1,...,cn,cn+1,...,cm]; cm+1 -> [c1',...,cn',cn+1,...,cm]; cm+1

    -- E-RetList
    -- --------------------------------------------------------
    --     [return v1,...,return vn] -> return [v1,...,vn]

Calculus
    ParList
    RetList
    -- Lijst values
    -- Lijst computations
    Lijst
    Head
    Tail
    Null
    let rec
    map
    -- map :: (ParallellisableFunction (v->c)) => [v] -> (v->c) -> [c] -- parallel
    reduce :: (ReducingFunction (v->v->v)) => [v] -> (v->v->v) -> v -- parallel
