#######

Updated: 02/01/2023

#######



do _ <- op accum "start " (x. return x);
do _ <- for 1:2:3:4:5:[] (x. if x == 2
    then
    do _ <- op accum "!" (x.return x);
    do _ <- op throw "error" (x. return x);
    op accum "unreachable" (x. return x)
    else op accum x (x. return x)) ;
do _ <- op accum " end" (x. return x);
return "success"

hAccum = handler 
    {
        return x -> return ("", x)
        op accum m k -> do (m', v) <- k (); return (m ++ m', v)  
        reduce l k ->  do first <- map fst l;
                    do second <- map snd l;
                    do (m', b) <- k second;
                    let rec reduce = l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in 
                                    do m <- reduce first;
                                    return (m ++ m', b)
        fwd f p k -> f (p, k) -- TODO
    }


hWeak = handler 
    {
        return x -> return (Right x)
        op throw m _ -> return (Left m)
        reduce l k ->  do res <- return l;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> k t
        fwd f p k -> f (p, k) -- TODO
    }

firstFailure lst = case map firstError lst of
    Just e  -> Left e
    Nothing -> Right $ fmap (\(Right x) -> x) lst 
  where firstError x = case x of Left e  -> Just e
                                 Right _ -> Nothing

hFor = handler 
{
    return x -> return x
    for l p k -> do res <- map p l;
                 k res
    reduce _ _ -> ()
    fwd f p k -> -- TODO 
}

hFor # hAccum # hWeak # (do _ <- op accum "start " (x. return x);
                        do _ <- for 1:2:3:4:5:[] (x. if x == 2
                            then
                            do _ <- op accum "!" (x.return x);
                            do _ <- op throw "error" (x. return x);
                            op accum "unreachable" (x. return x)
                            else op accum x (x. return x)) (x. return x);
                        do _ <- op accum " end" (x. return x) (x. return x);
                        return "success")

{- E-Hand and E-hand and E-Hand and E-DoOp -}
hFor # hAccum # hWeak # op accum "start " (x. 
                                    do _ <- return x;
                                    do _ <- for 1:2:3:4:5:[] (x. if x == 2
                                        then
                                        do _ <- op accum "!" (x.return x);
                                        do _ <- op throw "error" (x. return x);
                                        op accum "unreachable" (x. return x)
                                        else op accum x (x. return x)) (x. return x);
                                    do _ <- op accum " end" (x. return x) (x. return x);
                                    return "success")

{- E-Hand and E-Hand and E-FwdOp -}
hFor # hAccum # op accum "start " (x. hWeak # 
                            do _ <- return x;
                            do _ <- for 1:2:3:4:5:[] (x. if x == 2
                                then
                                do _ <- op accum "!" (x.return x);
                                do _ <- op throw "error" (x. return x);
                                op accum "unreachable" (x. return x)
                                else op accum x (x. return x)) (x. return x);
                            do _ <- op accum " end" (x. return x) (x. return x);
                            return "success")

{- E-Hand and E-HandOp -}
hFor # do (m', v) <- (x. hAccum # hWeak # 
                do _ <- return x;
                do _ <- for 1:2:3:4:5:[] (x. if x == 2
                    then
                    do _ <- op accum "!" (x.return x);
                    do _ <- op throw "error" (x. return x);
                    op accum "unreachable" (x. return x)
                    else op accum x (x. return x)) (x. return x);
                do _ <- op accum " end" (x. return x) (x. return x);
                return "success") (); 
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-AppAbs -}
hFor # do (m', v) <- hAccum # hWeak # 
                do _ <- return ();
                do _ <- for 1:2:3:4:5:[] (x. if x == 2
                    then
                    do _ <- op accum "!" (x.return x);
                    do _ <- op throw "error" (x. return x);
                    op accum "unreachable" (x. return x)
                    else op accum x (x. return x)) (x. return x);
                do _ <- op accum " end" (x. return x) (x. return x);
                return "success"; 
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Hand and E-Hand and E-DoRet -}
hFor # do (m', v) <- hAccum # hWeak # 
                do _ <- for 1:2:3:4:5:[] (x. if x == 2
                    then
                    do _ <- op accum "!" (x.return x);
                    do _ <- op throw "error" (x. return x);
                    op accum "unreachable" (x. return x)
                    else op accum x (x. return x)) (x. return x);
                do _ <- op accum " end" (x. return x) (x. return x);
                return "success"; 
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Hand and E-Hand and E-DoFor -}
hFor # do (m', v) <- hAccum # hWeak # 
            for 1:2:3:4:5:[] (x. if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) (x. 
                                                do _ <- return x;
                                                do _ <- op accum " end" (x. return x) (x. return x);
                                                return "success"; 
                );
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Hand and E-FwdFor -}
hFor # do (m', v) <- hAccum #
            for 1:2:3:4:5:[] (x. hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x))
                (x. do res <- return x;
                case firstFailure res of
                    Left err -> return (Left err)
                    Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t);
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-FwdFor -}
hFor # do (m', v) <- for 1:2:3:4:5:[] (x. hAccum # hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x))
                (do first <- map fst l;
                    do second <- map snd l;
                    do (m', b) <- (x. hAccum # do res <- return x;
                                    case firstFailure res of
                                        Left err -> return (Left err)
                                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
                    let rec reduce = l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in 
                                    do m <- reduce first;
                                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-DoFor -}
hFor # for 1:2:3:4:5:[] (x. hAccum # hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x))
                (x. do (m', v) <- (do first <- map fst x;
                    do second <- map snd x;
                    do (m', b) <- (x. hAccum #  do res <- return x;
                                    case firstFailure res of
                                        Left err -> return (Left err)
                                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
                    let rec reduce = l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in 
                                    do m <- reduce first;
                                    return (m ++ m', b));
                return ("start " ++ m', v))

{- E-HandFor -}
do res <- for (x. hFor # hAccum # hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) (1:2:3:4:5:[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res
 
{- E-Do and E-Map -}
do res <- (((x. hFor # hAccum # hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) 1):
                ((x. hFor # hAccum # hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) 2):
                ((x. hFor # hAccum # hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) 3):
                ((x. hFor # hAccum # hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) 4):
                ((x. hFor # hAccum # hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) 5):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-AppAbs*5] -}
do res <- ((hFor # hAccum # hWeak #  if 1 == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum 1 (x. return x)):
            (hFor # hAccum # hWeak #  if 2 == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum 2 (x. return x)):
            (hFor # hAccum # hWeak #  if 3 == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum 3 (x. return x)):
            (hFor # hAccum # hWeak #  if 4 == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum 4 (x. return x)):
            (hFor # hAccum # hWeak #  if 5 == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum 5 (x. return x)):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-Hand and E-IfTrue, E-Hand and E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-Hand and E-IfFalse] -}
do res <- ((hFor # hAccum # hWeak # op accum 1 (x. return x)):
            (hFor # hAccum # hWeak #  do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x)):
            (hFor # hAccum # hWeak # op accum 3 (x. return x)):
            (hFor # hAccum # hWeak # op accum 4 (x. return x)):
            (hFor # hAccum # hWeak # op accum 5 (x. return x)):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Hand and E-FwdOp, E-Hand and E-Hand and E-Hand and E-DoOp, E-Hand and E-Hand and E-FwdOp, E-Hand and E-Hand and E-FwdOp, E-Hand and E-Hand and E-FwdOp] -}
do res <- ((hFor # hAccum # op accum 1 (x. hWeak # return x)):
            (hFor # hAccum # hWeak # op accum "!" (x. do _ <- return x; do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x))):
            (hFor # hAccum # op accum 3 (x. hWeak # return x)):
            (hFor # hAccum # op accum 4 (x. hWeak # return x)):
            (hFor # hAccum # op accum 5 (x. hWeak # return x)):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-HandOp, E-Hand and E-Hand and E-FwdOp, E-Hand and E-HandOp, E-Hand and E-HandOp, E-Hand and E-HandOp] -}
do res <- ((hFor # do (m', v) <- (x. hAccum # hWeak # return x) (); return (1 ++ m', v)):
            (hFor # hAccum # op accum "!" (x. hWeak # do _ <- return x; do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x))):
            (hFor # do (m', v) <- (x. hAccum # hWeak # return x) (); return (3 ++ m', v)):
            (hFor # do (m', v) <- (x. hAccum # hWeak # return x) (); return (4 ++ m', v)):
            (hFor # do (m', v) <- (x. hAccum # hWeak # return x) (); return (5 ++ m', v)):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Do and E-AppAbs, E-Hand and E-HandOp, E-Hand and E-Do and E-AppAbs, E-Hand and E-Do and E-AppAbs,E-Hand and E-Do and E-AppAbs] -}
do res <- ((hFor # do (m', v) <- hAccum # hWeak # return (); return (1 ++ m', v)):
            (hFor # do (m', v) <- (x. hAccum # hWeak # do _ <- return x; do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x)) (); return ("!" ++ m', v)):
            (hFor # do (m', v) <- hAccum # hWeak # return (); return (3 ++ m', v)):
            (hFor # do (m', v) <- hAccum # hWeak # return (); return (4 ++ m', v)):
            (hFor # do (m', v) <- hAccum # hWeak # return (); return (5 ++ m', v)):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Do and E-Hand and E-HandRet, E-Hand and E-Do And E-AppAbs, E-Hand and E-Do and E-Hand and E-HandRet, E-Hand and E-Do and E-Hand and E-HandRet, E-Hand and E-Do and E-Hand and E-HandRet] -}
do res <- ((hFor # do (m', v) <- hAccum # return (Right ()); return (1 ++ m', v)):
            (hFor # do (m', v) <- hAccum # hWeak # do _ <- return (); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x); return ("!" ++ m', v)):
            (hFor # do (m', v) <- hAccum # return (Right ()); return (3 ++ m', v)):
            (hFor # do (m', v) <- hAccum # return (Right ()); return (4 ++ m', v)):
            (hFor # do (m', v) <- hAccum # return (Right ()); return (5 ++ m', v)):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Do and E-HandRet, E-Hand and E-Do And E-Hand and E-Hand and E-DoRet, E-Hand and E-Do and E-HandRet, E-Hand and E-Do and E-HandRet, E-Hand and E-Do and E-HandRet] -}
do res <- ((hFor # do (m', v) <- return ("", Right ()); return (1 ++ m', v)):
            (hFor # do (m', v) <- hAccum # hWeak # do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x); return ("!" ++ m', v)):
            (hFor # do (m', v) <- return ("", Right ()); return (3 ++ m', v)):
            (hFor # do (m', v) <- return ("", Right ()); return (4 ++ m', v)):
            (hFor # do (m', v) <- return ("", Right ()); return (5 ++ m', v)):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-DoRet, E-Hand and E-Do And E-Hand and E-Hand and E-DoOp, E-Hand and E-DoRet, E-Hand and E-DoRet, E-Hand and E-DoRet] -}
do res <- ((hFor # return ("1", Right ())):
            (hFor # do (m', v) <- hAccum # hWeak # op throw "error" (x. do _ <-  return x; op accum "unreachable" (x. return x)); return ("!" ++ m', v)):
            (hFor # return ("3", Right ())):
            (hFor # return ("4", Right ())):
            (hFor # return ("5", Right ())):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-HandRet, E-Hand and E-Do And E-Hand and E-HandOp, E-HandRet, E-HandRet, E-HandRet] -}
do res <- ((return ("1", Right ())):
            (hFor # do (m', v) <- hAccum # return (Left "error"); return ("!" ++ m', v)):
            (return ("3", Right ())):
            (return ("4", Right ())):
            (return ("5", Right ())):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Do And E-HandRet] -}
do res <- ((return ("1", Right ())):
            (hFor # do (m', v) <- return ("", Left "error"); return ("!" ++ m', v)):
            (return ("3", Right ())):
            (return ("4", Right ())):
            (return ("5", Right ())):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-DoRet] -}
do res <- ((return ("1", Right ())):
            (hFor # return ("!", Left "Error")):
            (return ("3", Right ())):
            (return ("4", Right ())):
            (return ("5", Right ())):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-HandRet] -}
do res <- ((return ("1", Right ())):
            (return ("!", Left "Error")):
            (return ("3", Right ())):
            (return ("4", Right ())):
            (return ("5", Right ())):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ListRet -}
do res <- return (("1", Right ()):("!", Left "Error"):("3", Right ()):("4", Right ()):("5", Right ()):[]); 
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-DoRet -}
(x. hFor # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) (("1", Right ()):("!", Left "Error"):("3", Right ()):("4", Right ()):("5", Right ()):[])

{- E-AppAbs -}
hFor # do (m', v) <- (do first <- map fst (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-Map -}
hFor # do (m', v) <- (do first <- ((fst ("1", Right ())):(fst ("!", Left "error")):(fst ("3", Right ())):(fst ("4", Right ())):(fst ("5", Right ())):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-Map -}
hFor # do (m', v) <- (do first <- ((fst ("1", Right ())):(fst ("!", Left "error")):(fst ("3", Right ())):(fst ("4", Right ())):(fst ("5", Right ())):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-ParList and [E-First*5] -}
hFor # do (m', v) <- (do first <- ((return "1"):(return "!"):(return "3"):(return "4"):(return "5"):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-ListRet -}
hFor # do (m', v) <- (do first <- return ("1":"!":"3":"4":"5":[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-DoRet -}
hFor # do (m', v) <- (do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-Map -}
hFor # do (m', v) <- (do second <- ((snd ("1", Right ())):(snd ("!", Left "error")):(snd ("3", Right ())):(snd ("4", Right ())):(snd ("5", Right ())):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-ParList and [E-Second*5] -}
hFor # do (m', v) <- (do second <- ((return (Right ())):(return (Left "error")):(return (Right ())):(return (Right ())):(return (Right ())):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-ListRet -}
hFor # do (m', v) <- (do second <- return ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-DoRet -}
hFor # do (m', v) <- (do (m', b) <- (x. hAccum # do res <- return x;
                                case firstFailure res of
                                    Left err -> return (Left err)
                                    Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]);
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 


{- E-Hand and E-Do and E-Do and E-AppAbs -}
hFor # do (m', v) <- (do (m', b) <- hAccum # do res <- return ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]);
                            case firstFailure res of
                                Left err -> return (Left err)
                                Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t);
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-Hand and E-DoRet -}
hFor # do (m', v) <- (do (m', b) <- hAccum # case firstFailure ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]) of
                                Left err -> return (Left err)
                                Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t);
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b);
return ("start " ++ m', v)

--TODO 
{- E-Hand and E-Do and E-Do E-Hand and E-FirstFailLeft -}
hFor # do (m', v) <- (do (m', b) <- hAccum #  return (Left "error");
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-HandRet -}
hFor # do (m', v) <- (do (m', b) <- return ("", Left "error");
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-DoRet -}
hFor # do (m', v) <- (let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ "", Left "error"));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-LetRec -}
hFor # do (m', v) <- (do m <- (let rec reduce = l. 
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in l. 
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) ("1":"!":"3":"4":"5":[]);
                return (m ++ "", Left "error"));
return ("start " ++ m', v) 

...
{- analogous to let rec reduction in "reductionMap" -}

{- E-Hand and E-Do and E-DoRet -}
hFor # do (m', v) <- return ("1:345", Left "error");
return ("start " ++ m', v) 

{- E-Hand and E-DoRet -}
hFor # return ("start 1:345", Left "error") 

{- E-HandRet -}
return ("start 1:345", Left "error") 
