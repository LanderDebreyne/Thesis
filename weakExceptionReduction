do _ <- op accum "start " (x. return x);
do _ <- map 1:2:3:4:5:[] (x. if x == 2
    then
    do _ <- op accum "!" (x.return x);
    do _ <- op throw "error" (x. return x);
    op accum "unreachable" (x. return x)
    else op accum x (x. return x)) ;
do _ <- op accum " end" (x. return x);
return "success"

hAccum = handler 
    {
        return x -> return ("", x)
        op accum m k -> do (m', v) <- k (); return (m ++ m', v)  
        red l k ->  do first <- map fst l;
                    do second <- map snd l;
                    do (m', b) <- k second;
                    let rec reduce = l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in 
                                    do m <- reduce first;
                                    return (m ++ m', b)
        fwd f p k -> f (p, k) -- TODO
    }


hWeak = handler 
    {
        return x -> return (Right x)
        op throw m _ -> return (Left m)
        red l k ->  do res <- return l;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> k t
        fwd f p k -> f (p, k) -- TODO
    }

firstFailure lst = case map firstError lst of
    Just e  -> Left e
    Nothing -> Right $ fmap (\(Right x) -> x) lst 
  where firstError x = case x of Left e  -> Just e
                                 Right _ -> Nothing

hPure = handler 
{
    return x -> x
    red l k -> hPure # (k (map (hPure #) l))
}


hPure # hAccum # hWeak # (do _ <- op accum "start " (x. return x);
                        do _ <- map 1:2:3:4:5:[] (x. if x == 2
                            then
                            do _ <- op accum "!" (x.return x);
                            do _ <- op throw "error" (x. return x);
                            op accum "unreachable" (x. return x)
                            else op accum x (x. return x)) (x. return x);
                        do _ <- op accum " end" (x. return x) (x. return x);
                        return "success")

hAccum # hWeak # (do _ <- op accum "start " (x. return x);
                do _ <- map 1:2:3:4:5:[] (x. if x == 2
                    then
                    do _ <- op accum "!" (x.return x);
                    do _ <- op throw "error" (x. return x);
                    op accum "unreachable" (x. return x)
                    else op accum x (x. return x)) (x. return x);
                do _ <- op accum " end" (x. return x) (x. return x);
                return "success")

{- E-Hand and E-Hand and E-DoOp -}
hAccum # hWeak # op accum "start " (x. 
                                    do _ <- return x;
                                    do _ <- map 1:2:3:4:5:[] (x. if x == 2
                                        then
                                        do _ <- op accum "!" (x.return x);
                                        do _ <- op throw "error" (x. return x);
                                        op accum "unreachable" (x. return x)
                                        else op accum x (x. return x)) (x. return x);
                                    do _ <- op accum " end" (x. return x) (x. return x);
                                    return "success")

{- E-Hand and E-FwdOp -}
hAccum # op accum "start " (x. hWeak # 
                            do _ <- return x;
                            do _ <- map 1:2:3:4:5:[] (x. if x == 2
                                then
                                do _ <- op accum "!" (x.return x);
                                do _ <- op throw "error" (x. return x);
                                op accum "unreachable" (x. return x)
                                else op accum x (x. return x)) (x. return x);
                            do _ <- op accum " end" (x. return x) (x. return x);
                            return "success")

{- E-HandOp -}
do (m', v) <- (x. hAccum # hWeak # 
            do _ <- return x;
            do _ <- map 1:2:3:4:5:[] (x. if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) (x. return x);
            do _ <- op accum " end" (x. return x) (x. return x);
            return "success") (); 
return ("start " ++ m', v) 

{- E-Do and E-AppAbs -}
do (m', v) <- hAccum # hWeak # 
            do _ <- return ();
            do _ <- map 1:2:3:4:5:[] (x. if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) (x. return x);
            do _ <- op accum " end" (x. return x) (x. return x);
            return "success"; 
return ("start " ++ m', v) 

{- E-Do and E-Hand and E-Hand and E-DoRet -}
do (m', v) <- hAccum # hWeak # 
            do _ <- map 1:2:3:4:5:[] (x. if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) (x. return x);
            do _ <- op accum " end" (x. return x) (x. return x);
            return "success"; 
return ("start " ++ m', v) 

{- E-Do and E-Hand and E-Hand and E-DoMap -}
do (m', v) <- hAccum # hWeak # 
            map 1:2:3:4:5:[] (x. if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) (x. 
                                                do _ <- return x;
                                                do _ <- op accum " end" (x. return x) (x. return x);
                                                return "success"; 
                );
return ("start " ++ m', v) 

{- E-Do and E-Hand and E-HandMap -}
do (m', v) <- hAccum #
            map 1:2:3:4:5:[] (x. hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x))
                (x. do res <- return x;
                case firstFailure res of
                    Left err -> return (Left err)
                    Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t);
return ("start " ++ m', v) 

{- E-Do and E-HandMap -}
do (m', v) <- map 1:2:3:4:5:[] (x. hAccum # hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x))
                (do first <- map fst l;
                    do second <- map snd l;
                    do (m', b) <- (x. hAccum # do res <- return x;
                                    case firstFailure res of
                                        Left err -> return (Left err)
                                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
                    let rec reduce = l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in 
                                    do m <- reduce first;
                                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-DoMap -}
map 1:2:3:4:5:[] (x. hAccum # hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x))
                (x. do (m', v) <- (do first <- map fst x;
                    do second <- map snd x;
                    do (m', b) <- (x. hAccum #  do res <- return x;
                                    case firstFailure res of
                                        Left err -> return (Left err)
                                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
                    let rec reduce = l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in 
                                    do m <- reduce first;
                                    return (m ++ m', b));
                return ("start " ++ m', v))

{- E-EffMap -}
par (((x. hAccum # hWeak #  if x == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum x (x. return x)) 1):
((x. hAccum # hWeak #  if x == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum x (x. return x)) 2):
((x. hAccum # hWeak #  if x == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum x (x. return x)) 3):
((x. hAccum # hWeak #  if x == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum x (x. return x)) 4):
((x. hAccum # hWeak #  if x == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum x (x. return x)) 5):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-Par and [E-AppAbs, E-AppAbs, E-AppAbs, E-AppAbs, E-AppAbs] -}
par ((hAccum # hWeak #  if 1 == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum 1 (x. return x)):
(hAccum # hWeak #  if 2 == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum 2 (x. return x)):
(hAccum # hWeak #  if 3 == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum 3 (x. return x)):
(hAccum # hWeak #  if 4 == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum 4 (x. return x)):
(hAccum # hWeak #  if 5 == 2 then do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x) else op accum 5 (x. return x)):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-Par and [E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-IfTrue, E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-IfFalse] -}
par ((hAccum # hWeak # op accum 1 (x. return x)):
(hAccum # hWeak #  do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x)):
(hAccum # hWeak # op accum 3 (x. return x)):
(hAccum # hWeak # op accum 4 (x. return x)):
(hAccum # hWeak # op accum 5 (x. return x)):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))
 
{- E-Par and [E-Hand and E-FwdOp, E-Hand and E-Hand and E-DoOp, E-Hand and E-FwdOp, E-Hand and E-FwdOp, E-Hand and E-FwdOp] -}
par ((hAccum # op accum 1 (x. hWeak # return x)):
(hAccum # hWeak #  op accum "!" (x. do _ <-  return x; do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x));):
(hAccum # op accum 3 (x. hWeak # return x)):
(hAccum # op accum 4 (x. hWeak # return x)):
(hAccum # op accum 5 (x. hWeak # return x)):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-Par and [E-HandOp, E-Hand and E-FwdOp, E-HandOp, E-HandOp, E-HandOp] -}
par ((do (m', v) <- (x. hAccum # hWeak # return x) (); return (1 ++ m', v)):
(hAccum # hWeak #  op accum "!" (x. do _ <-  return x; do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x));):
(do (m', v) <- (x. hAccum # hWeak # return x) (); return (3 ++ m', v)):
(do (m', v) <- (x. hAccum # hWeak # return x) (); return (4 ++ m', v)):
(do (m', v) <- (x. hAccum # hWeak # return x) (); return (5 ++ m', v)):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-Par and [E-Do and E-AppAbs, E-Hand and E-HandOp, E-Do and E-AppAbs, E-Do and E-AppAbs, E-Do and E-AppAbs] -}
par ((do (m', v) <- hAccum # hWeak # return (); return (1 ++ m', v)):
(hAccum # op accum "!" (x. hWeak # do _ <-  return x; do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x));):
(do (m', v) <- hAccum # hWeak # return (); return (3 ++ m', v)):
(do (m', v) <- hAccum # hWeak # return (); return (4 ++ m', v)):
(do (m', v) <- hAccum # hWeak # return (); return (5 ++ m', v)):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-Par and [E-Do and E-Hand and E-HandRet, E-HandOp, E-Do and E-Hand and E-HandRet, E-Do and E-Hand and E-HandRet, E-Do and E-Hand and E-HandRet] -}
par ((do (m', v) <- hAccum # return (Right ()); return (1 ++ m', v)):
(do (m', v) <- (x. hAccum # hWeak # do _ <-  return x; do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x)) (); return ("!" ++ m', v)):
(do (m', v) <- hAccum # return (Right ()); return (3 ++ m', v)):
(do (m', v) <- hAccum # return (Right ()); return (4 ++ m', v)):
(do (m', v) <- hAccum # return (Right ()); return (5 ++ m', v)):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-Par and [E-Do and E-HandRet, E-Do and E-AppAbs, E-Do and E-HandRet, E-Do and E-HandRet, E-Do and E-HandRet] -}
par ((do (m', v) <- return ("", Right ()); return (1 ++ m', v)):
(do (m', v) <- hAccum # hWeak # do _ <-  return (); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x); return ("!" ++ m', v)):
(do (m', v) <- return ("", Right ()); return (3 ++ m', v)):
(do (m', v) <- return ("", Right ()); return (4 ++ m', v)):
(do (m', v) <- return ("", Right ()); return (5 ++ m', v)):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))


{- E-Par and [E-DoRet, E-Do and E-Hand and E-Hand and E-DoRet, E-DoRet, E-DoRet, E-DoRet] -}
par ((return ("1", Right ())):
(do (m', v) <- hAccum # hWeak # do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x); return ("!" ++ m', v)):
(return ("3", Right ())):
(return ("4", Right ())):
(return ("5", Right ())):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-Par and [E-Do and E-Hand and E-Hand and E-DoOp] -}
par ((return ("1", Right ())):
(do (m', v) <- hAccum # hWeak # op throw "error" (x. do _ <-  return x; op accum "unreachable" (x. return x)); return ("!" ++ m', v)):
(return ("3", Right ())):
(return ("4", Right ())):
(return ("5", Right ())):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-Par and [E-Do and E-Hand and E-HandOp] -}
par ((return ("1", Right ())):
(do (m', v) <- hAccum # return (Left "error"); return ("!" ++ m', v)):
(return ("3", Right ())):
(return ("4", Right ())):
(return ("5", Right ())):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-Par and [E-Do and E-HandRet] -}
par ((return ("1", Right ())):
(do (m', v) <- return ("", Left "error"); return ("!" ++ m', v)):
(return ("3", Right ())):
(return ("4", Right ())):
(return ("5", Right ())):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-Par and [E-DoRet] -}
par ((return ("1", Right ())):
(return ("!", Left "error")):
(return ("3", Right ())):
(return ("4", Right ())):
(return ("5", Right ())):[])
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v))

{- E-ParNorRet -}
(x. do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[])

{- E-AppAbs -}
do (m', v) <- (do first <- map fst (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-Do and E-Map -}
do (m', v) <- (do first <- ((fst ("1", Right ())):(fst ("!", Left "error")):(fst ("3", Right ())):(fst ("4", Right ())):(fst ("5", Right ())):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-Do and E-Map -}
do (m', v) <- (do first <- ((fst ("1", Right ())):(fst ("!", Left "error")):(fst ("3", Right ())):(fst ("4", Right ())):(fst ("5", Right ())):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-Do and E-ParList and [E-First*5] -}
do (m', v) <- (do first <- ((return "1"):(return "!"):(return "3"):(return "4"):(return "5"):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-Do and E-ListRet -}
do (m', v) <- (do first <- return ("1":"!":"3":"4":"5":[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-DoRet -}
do (m', v) <- (do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-Do and E-Map -}
do (m', v) <- (do second <- ((snd ("1", Right ())):(snd ("!", Left "error")):(snd ("3", Right ())):(snd ("4", Right ())):(snd ("5", Right ())):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-Do and E-ParList and [E-Second*5] -}
do (m', v) <- (do second <- ((return (Right ())):(return (Left "error")):(return (Right ())):(return (Right ())):(return (Right ())):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-Do and E-ListRet -}
do (m', v) <- (do second <- return ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-DoRet -}
do (m', v) <- (do (m', b) <- (x. hAccum # do res <- return x;
                                case firstFailure res of
                                    Left err -> return (Left err)
                                    Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]);
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 


{- E-Do and E-Do and E-AppAbs -}
do (m', v) <- (do (m', b) <- hAccum # do res <- return ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]);
                            case firstFailure res of
                                Left err -> return (Left err)
                                Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t);
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-Do and E-Hand and E-DoRet -}
do (m', v) <- (do (m', b) <- hAccum # case firstFailure ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]) of
                                Left err -> return (Left err)
                                Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t);
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v)

--TODO 
{- E-Do and E-Do E-Hand and E-FirstFailLeft -}
do (m', v) <- (do (m', b) <- hAccum #  return (Left "error");
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-Do and E-HandRet -}
do (m', v) <- (do (m', b) <- return ("", Left "error");
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Do and E-DoRet -}
do (m', v) <- (let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ "", Left "error"));
return ("start " ++ m', v) 

{- E-Do and E-LetRec -}
do (m', v) <- (do m <- (let rec reduce = l. 
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in l. 
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) ("1":"!":"3":"4":"5":[]);
                return (m ++ "", Left "error"));
return ("start " ++ m', v) 

...

{- E-Do and E-DoRet -}
do (m', v) <- return ("1:345", Left "error");
return ("start " ++ m', v) 

{- E-DoRet -}
do (m', v) <- return ("1:345", Left "error");
return ("start 1:345", Left "error") 


