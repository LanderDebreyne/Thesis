@article{Moggi1991,
   abstract = {The λ-calculus is considered a useful mathematical tool in the study of programming languages, since programs can be identified with λ-terms. However, if one goes further and uses βη-conversion to prove equivalence of programs, then a gross simplification is introduced (programs are identified with total functions from values to values) that may jeopardise the applicability of theoretical results. In this paper we introduce calculi, based on a categorical semantics for computations, that provide a correct basis for proving equivalence of programs for a wide range of notions of computation.},
   author = {Eugenio Moggi},
   doi = {https://doi.org/10.1016/0890-5401(91)90052-4},
   issn = {0890-5401},
   issue = {1},
   journal = {Information and Computation},
   note = {Selections from 1989 IEEE Symposium on Logic in Computer Science},
   pages = {55-92},
   title = {Notions of computation and monads},
   volume = {93},
   url = {https://www.sciencedirect.com/science/article/pii/0890540191900524},
   year = {1991},
}

@article{Liang1995,
   abstract = {We show how a set of building blocks can be used to construct programming language interpreters, and present implementations of such building blocks capable of supporting many commonly known features, including simple expressions, three different function call mechanisms (call-by-name, call-by-value and lazy evaluation), references and assignment, nondeterminism, first-class continuations, and program tracing.The underlying mechanism of our system is monad transformers, a simple form of abstraction for introducing a wide range of computational behaviors, such as state, I/O, continuations, and exceptions.Our work is significant in the following respects. First, we have succeeded in designing a fully modular interpreter based on monad transformers that incudes features missing from Steele's, Espinosa's, and Wadler's earlier efforts. Second, we have found new ways to lift monad operations through monad transformers, in particular difficult cases not achieved in Moggi's original work. Third, we have demonstrated that interactions between features are reflected in liftings and that semantics can be changed by reordering monad transformers. Finally, we have implemented our interpreter in Gofer, whose constructor classes provide just the added power over Haskell's type classes to allow precise and convenient expression of our ideas. This implementation includes a method for constructing extensible unions and a form of subtyping that is interesting in its own right.},
   author = {Sheng Liang and Paul Hudak and Mark Jones},
   city = {New York, NY, USA},
   doi = {10.1145/199448.199528},
   isbn = {0897916921},
   journal = {Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
   pages = {333-343},
   publisher = {Association for Computing Machinery},
   title = {Monad Transformers and Modular Interpreters},
   url = {https://doi.org/10.1145/199448.199528},
   year = {1995},
}

@article{Haas2017,
   author = {Andreas Haas and Andreas Rossberg and Derek Schuff and Ben Titzer and Michael Holman and Dan Gohman and Luke Wagner and Alon Zakai and Jf Bastien},
   doi = {10.1145/3062341.3062363},
   journal = {PLDI 2017: Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
   month = {12},
   pages = {185-200},
   title = {Bringing the web up to speed with WebAssembly},
   year = {2017},
}

@article{Levy2003,
   abstract = {In categorical semantics, there have traditionally been two approaches to modelling environments, one by use of finite products in cartesian closed categories, the other by use of the base categories of indexed categories with structure. Each requires modifications in order to account for environments in call-by-value programming languages. There have been two more general definitions along both of these lines: the first generalising from cartesian to symmetric premonoidal categories, the second generalising from indexed categories with specified structure to κ-categories. In this paper, we investigate environments in call-by-value languages by analysing a fine-grain variant of Moggi’s computational λ-calculus, giving two equivalent sound and complete classes of models: one given by closed Freyd categories, which are based on symmetric premonoidal categories, the other given by closed κ-categories.},
   author = {PaulBlain Levy and John Power and Hayo Thielecke},
   doi = {https://doi.org/10.1016/S0890-5401(03)00088-9},
   issn = {0890-5401},
   issue = {2},
   journal = {Information and Computation},
   pages = {182-210},
   title = {Modelling environments in call-by-value programming languages},
   volume = {185},
   url = {https://www.sciencedirect.com/science/article/pii/S0890540103000889},
   year = {2003},
}


@article{Pretnar2015,
   abstract = {This paper is a tutorial on algebraic effects and handlers. In it, we explain what algebraic effects are, give ample examples to explain how handlers work, define an operational semantics and a type & effect system, show how one can reason about effects, and give pointers for further reading.},
   author = {Matija Pretnar},
   doi = {10.1016/J.ENTCS.2015.12.003},
   issn = {1571-0661},
   journal = {Electronic Notes in Theoretical Computer Science},
   keywords = {algebraic effects,effect system,handlers,logic,semantics,tutorial},
   month = {12},
   pages = {19-35},
   publisher = {Elsevier},
   title = {An Introduction to Algebraic Effects and Handlers. Invited tutorial paper},
   volume = {319},
   year = {2015},
}

@article{Bauer2015,
   author = {Andrej Bauer and Matija Pretnar},
   doi = {10.1016/j.jlamp.2014.02.001},
   issue = {1},
   journal = {Journal of Logical and Algebraic Methods in Programming},
   month = {1},
   pages = {108-123},
   publisher = {Elsevier BV
},
   title = {Programming with algebraic effects and handlers},
   volume = {84},
   url = {https://doi.org/10.1016%2Fj.jlamp.2014.02.001},
   year = {2015},
}

@article{Bosman2022,
   author = {Roger Bosman and Birthe van den Berg and W Tang and Tom Schrijvers},
   title = {A Calculus for Scoped Effects\& Handlers},
   journal = {under review},
   year = 2022
}

@article{Wu2014,
   abstract = {Algebraic effect handlers are a powerful means for describing effectful computations. They provide a lightweight and orthogonal technique to define and compose the syntax and semantics of different effects. The semantics is captured by handlers, which are functions that transform syntax trees.Unfortunately, the approach does not support syntax for scoping constructs, which arise in a number of scenarios. While handlers can be used to provide a limited form of scope, we demonstrate that this approach constrains the possible interactions of effects and rules out some desired semantics.This paper presents two different ways to capture scoped constructs in syntax, and shows how to achieve different semantics by reordering handlers. The first approach expresses scopes using the existing algebraic handlers framework, but has some limitations. The problem is fully solved in the second approach where we introduce higher-order syntax.},
   author = {Nicolas Wu and Tom Schrijvers and Ralf Hinze},
   city = {New York, NY, USA},
   doi = {10.1145/2775050.2633358},
   issn = {0362-1340},
   issue = {12},
   journal = {SIGPLAN Not.},
   keywords = {Haskell,effect handlers,modularity,monads,semantics,syntax},
   month = {9},
   pages = {1-12},
   publisher = {Association for Computing Machinery},
   title = {Effect Handlers in Scope},
   volume = {49},
   url = {https://doi.org/10.1145/2775050.2633358},
   year = {2014},
}

@article{Pirog2018,
   abstract = {Motivated by the problem of separating syntax from semantics in programming with algebraic effects and handlers, we propose a categorical model of abstract syntax with so-called scoped operations. As a building block of a term, a scoped operation is not merely a node in a tree, as it can also encompass a whole part of the term (a scope). Some examples from the area of programming are given by the operation catch for handling exceptions, in which the part in the scope is the code that may raise an exception, or the operation once, which selects a single solution from a nondeterministic computation. A distinctive feature of such operations is their behaviour under program composition, that is, syntactic substitution.Our model is based on what Ghani et al. call the monad of explicit substitutions, defined using the initial-algebra semantics in the category of endofunctors. We also introduce a new kind of multi-sorted algebras, called scoped algebras, which serve as interpretations of syntax with scopes. In generality, scoped algebras are given in the style of the presheaf formalisation of syntax with binders of Fiore et al. As the main technical result, we show that our monad indeed arises from free objects in the category of scoped algebras.Importantly, we show that our results are immediately applicable. In particular, we show a Haskell implementation together with practical, real-life examples.},
   author = {Maciej Piróg and Tom Schrijvers and Nicolas Wu and Mauro Jaskelioff},
   city = {New York, NY, USA},
   doi = {10.1145/3209108.3209166},
   isbn = {9781450355834},
   journal = {Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science},
   pages = {809-818},
   publisher = {Association for Computing Machinery},
   title = {Syntax and Semantics for Operations with Scopes},
   url = {https://doi.org/10.1145/3209108.3209166},
   year = {2018},
}

@article{Yang2022,
  author    = {Zhixuan Yang and
               Marco Paviotti and
               Nicolas Wu and
               Birthe van den Berg and
               Tom Schrijvers},
  title     = {Structured Handling of Scoped Effects: Extended Version},
  journal   = {CoRR},
  volume    = {abs/2201.10287},
  year      = {2022},
  url       = {https://arxiv.org/abs/2201.10287},
  eprinttype = {arXiv},
  eprint    = {2201.10287},
  timestamp = {Tue, 01 Feb 2022 14:59:01 +0100},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2201-10287.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@report{Xie2021-2,
   abstract = {See the HOPE'21 presentation.

Algebraic effect handlers are a novel technique for adding composable computational effects to functional languages. While programming with distinct effects is concise, using multiple instances of the same effect is difficult to express. This work studies _named effect handlers_, such that an operation can explicitly yield to a specific handler by name. We propose a novel design of named handlers, where names are first-class values bound by regular lambdas, and are guaranteed not to escape through the standard rank-2 polymorphism. We also formalize dynamically instantiated named handlers, which can express first-class isolated heaps with dynamic mutable references. Finally, we provide an implementation of named handlers in the Koka programming language, showing that the proposed ideas enable supporting named handlers with moderate effort.},
   author = {Ningning Xie and Youyou Cong and Daan Leijen},
   issue = {MSR-TR-2021-10},
   institution = {Microsoft},
   month = {5},
   note = {Presented at the 8th ACM SIGPLAN Workshop on Higher-Order Programming with Effects (HOPE'21).},
   title = {First-class Named Effect Handlers},
   url = {https://www.microsoft.com/en-us/research/publication/first-class-named-effect-handlers/},
   year = {2021},
}

@article{Xie2021,
  author    = {Ningning Xie and
               Daniel D. Johnson and
               Dougal Maclaurin and
               Adam Paszke},
  title     = {Parallel Algebraic Effect Handlers},
  journal   = {CoRR},
  volume    = {abs/2110.07493},
  year      = {2021},
  url       = {https://arxiv.org/abs/2110.07493},
  eprinttype = {arXiv},
  eprint    = {2110.07493},
  timestamp = {Mon, 25 Oct 2021 07:55:55 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2110-07493.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@book{Palmer2009,
   author = {Zachary Palmer and Mike Grant and Scott Smith},
   pages = {4-49},
   publisher = {John Hopkins University},
   title = {Principles of Programming Languages},
   url = {https://www.cs.swarthmore.edu/~zpalmer/cs73/s18/book.pdf},
   year = {2009},
}

@book{Pierce2002,
   abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems – and of programming languages from a type-theoretic perspective – has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.},
   author = {Benjamin C Pierce},
   edition = {1st},
   isbn = {0262162091},
   publisher = {The MIT Press},
   title = {Types and Programming Languages},
   year = {2002},
}

@misc{Sampson2018,
   author = {Adrian Sampson},
   title = {CS 6110: Advanced Programming Languages Spring 2018 Lecture 11},
   year = {2018},
   howpublished = {\url{https://www.cs.cornell.edu/courses/cs6110/2018sp/lectures/lec11.pdf}},
   note= {Accessed on: 03/01/2023}, 
}

@article{Leijen2017,
   abstract = {Algebraic effect handlers, introduced by Plotkin and Power in 2002, are recently gaining in popularity as a purely functional approach to modeling effects. In this article, we give a full overview of practical algebraic effects in the context of a compiled implementation in the Koka language. In particular, we show how algebraic effects generalize over common constructs like exception handling, state, iterators and async-await. We give an effective type inference algorithm based on extensible effect rows using scoped labels, and a direct operational semantics. Finally, we show an efficient compilation scheme to common runtime platforms (like JavaScript) using a type directed selective CPS translation.},
   author = {Daan Leijen},
   city = {New York, NY, USA},
   doi = {10.1145/3093333.3009872},
   issn = {0362-1340},
   issue = {1},
   journal = {SIGPLAN Not.},
   keywords = {Algebraic Effect Handlers,CPS transformation,Type Inference},
   month = {1},
   pages = {486-499},
   publisher = {Association for Computing Machinery},
   title = {Type Directed Compilation of Row-Typed Algebraic Effects},
   volume = {52},
   url = {https://doi.org/10.1145/3093333.3009872},
   year = {2017},
}

@misc{Brachthauser2020,
   author = {Jonathan Immanuel Brachthäuser and Philipp Schuster and Klaus Ostermann},
   institution = {University of Tübingen, Germany},
   title = {Effekt: Lightweight Effect Polymorphism for Handlers (Technical Report)},
   year = {2020},
}

@article{bingham2019pyro,
  author    = {Eli Bingham and
               Jonathan P. Chen and
               Martin Jankowiak and
               Fritz Obermeyer and
               Neeraj Pradhan and
               Theofanis Karaletsos and
               Rohit Singh and
               Paul A. Szerlip and
               Paul Horsfall and
               Noah D. Goodman},
  title     = {Pyro: Deep Universal Probabilistic Programming},
  journal   = {J. Mach. Learn. Res.},
  volume    = {20},
  pages     = {28:1--28:6},
  year      = {2019},
  url       = {http://jmlr.org/papers/v20/18-403.html}
}

@article{vandenBerg2021,
  author    = {Birthe van den Berg and
               Tom Schrijvers and
               Casper Bach Poulsen and
               Nicolas Wu},
  title     = {Latent Effects for Reusable Language Components: Extended Version},
  journal   = {CoRR},
  volume    = {abs/2108.11155},
  year      = {2021},
  url       = {https://arxiv.org/abs/2108.11155},
  eprinttype = {arXiv},
  eprint    = {2108.11155},
  timestamp = {Thu, 23 Dec 2021 10:30:13 +0100},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2108-11155.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{Ahman2020,
  author    = {Danel Ahman and
               Matija Pretnar},
  title     = {Asynchronous effects},
  journal   = {CoRR},
  volume    = {abs/2003.02110},
  year      = {2020},
  url       = {https://arxiv.org/abs/2003.02110},
  eprinttype = {arXiv},
  eprint    = {2003.02110},
  timestamp = {Tue, 10 Mar 2020 13:33:48 +0100},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2003-02110.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inbook{Backus2003,
author = {McCracken, Daniel D. and Reilly, Edwin D.},
title = {Backus-Naur Form (BNF)},
year = {2003},
isbn = {0470864125},
publisher = {John Wiley and Sons Ltd.},
address = {GBR},
abstract = {Backus-Naur Form, named after John W. Backus of the US and Peter Naur of Denmark, and usually written BNF, is the best-known example of a meta-language (q.v.), i.e. one that syntactically describes a programming language. Using BNF it is possible to specify which sequences of symbols constitute a syntactically valid program in a given language. (The question of semantics--i.e, what such valid strings of symbols mean--must be specified separately.) A discussion of the basic concepts of BNF follows.},
booktitle = {Encyclopedia of Computer Science},
pages = {129–131},
numpages = {3}
}


@book{Church1941,
   author = {Alonzo Church},
   publisher = {Princeton University Press},
   title = {The Calculi of Lambda Conversion. (AM-6)},
   year = {1941},
}

@article{Landin1965,
   author = {P J Landin},
   city = {New York, NY, USA},
   doi = {10.1145/363744.363749},
   issn = {0001-0782},
   issue = {2},
   journal = {Commun. ACM},
   month = {2},
   pages = {89-101},
   publisher = {Association for Computing Machinery},
   title = {Correspondence between ALGOL 60 and Church's Lambda-Notation: Part I},
   volume = {8},
   url = {https://doi.org/10.1145/363744.363749},
   year = {1965},
}
