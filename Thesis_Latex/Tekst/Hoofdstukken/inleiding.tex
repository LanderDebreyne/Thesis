\chapter{Inleiding} \label{inleiding}
Programmeren omvat het schrijven van instructies die een computer uitvoert om een specifieke taak te volbrengen. Programmeurs schrijven programma's in een programmeertaal, een taal die bestaat uit een set woorden, symbolen en regels. Formele systemen zijn nuttig om de eigenschappen en het gedrag van een programmeertaal te bestuderen. Programmeertaal-calculi bieden een wiskundig kader dat analyse mogelijk maakt om de fundamentele eigenschappen van de taal te begrijpen. Met behulp van abstracte algebra en logische notatie worden de syntaxis, de operationele semantiek en het type-en-effectsysteem van een vereenvoudigde versie van de programmeertaal voorgesteld. De syntaxis beschrijft hoe de woorden en symbolen uit de programmeertaal correct geschreven programma's vormen. De operationele semantiek beschrijft hoe programma's uitgevoerd worden. Het type-en effect-systeem beschrijft hoe de termen in de syntaxis een type krijgen.  

\section{Effecten}
Effecten in programma's zijn interacties met een omgeving buiten de lokale omgeving waarin het programma wordt uitgevoerd. Mogelijke effecten zijn het weergeven van informatie op het scherm, het opslaan van gegevens in een database. In programma's zijn effecten noodzakelijk om het gewenste gedrag te bereiken. Anderzijds kunnen effecten onbedoelde en ongewenste gevolgen hebben. In pure functionele programmeertalen kunnen in principe geen effecten plaatsvinden buiten het uitvoeren van een berekening. Omdat de programmeur geen rekening moet houden met andere effecten kan code geschreven in pure functionele programmeertalen makkelijker te begrijpen en over te redeneren zijn. Deze code verhoogt de productiviteit en verlaagt de kans op fouten. Het puur of vrij van neveneffecten zijn van deze programma's kan limiterend zijn voor de expressiviteit en  het bereiken van het gewenste gedrag. Daarom is het elegant introduceren en correct afhandelen van effecten een belangrijke open vraag in het programmeertaal-onderzoek, in het bijzonder voor functionele programmeertalen. Een goede functionele programmeertaal isoleert, controleert en beheert effecten op een voorspelbare manier. Voor de programmeur maakt een goede functionele programmeertaal het redeneren, uitbreiden, testen en onderhouden van programma's met effecten duidelijk en efficiënt. \emph{Expliciete constructies} voor het redeneren over effecten zijn essentieel om dit doel te bereiken. \newline

\section{Monads en effect handlers}
De meest industrie-relevante aanpak om effecten te modelleren in pure, functionele programmeertalen is de \emph{monad} \cite{Moggi1991}. De bekendste voorbeelden zijn Optional in Java, Result in Rust, en de IO monad en de Maybe monad in Haskell. In Haskell zijn \emph{monad transformers}\cite{Liang1995} populair om modulaire compositie van monads, en bijgevolg effecten, te realiseren. Dit gebeurt door verschillende types monads te combineren tot een enkele, gecombineerde monad. \newline 
Een tweede constructie om effecten te modelleren is het gebruik van \emph{algebraïsche effecten \cite{Pretnar2015} en effect handlers}. Het concept is om de aanroep van het effect, of de syntaxis, te scheiden van de afhandeling van het effect, of de semantiek. Een effect handler kan worden beschouwd als een functie die verantwoordelijk is voor de afhandeling van een effect in een andere functie zodat dit op een voorspelbare en modulaire manier kan gebeuren. 

\section{Programmeertaal-onderzoek en industrie}
WebAssembly \cite{Haas2017} is een goed voorbeeld van hoe principes en vooruitgang uit programmeertaal-onderzoek vertaald kunnen worden naar een industrie-relevante programmeertaal. WebAssembly is van het begin af aan ontworpen met een formele semantiek hetgeen bewijst dat dit een waardevolle aanpak kan zijn. De doelen die de auteurs vooropstellen voor een veilige, snelle, draagbare en compacte taal zijn toepasbaar op het ontwerp van bijna alle talen. Met deze principes in gedachte kan toegewerkt worden naar een calculus voor effect handlers die, mits verder ontwikkeling, kan evolueren naar een industrie-relevante aanpak om in een pure functionele taal met effecten om te gaan. Dit met als doel de programmeur een volwaardig alternatief te bieden voor monads in pure, functionele talen. \newline

Een online bibliografie\footnote{\url{https://github.com/yallop/effects-bibliography}} verzamelt toepassingen en applicaties die gerelateerd zijn aan onderzoek rond  op deze manier programmeren met computationele effecten. Koka \cite{Leijen2017}, Eff \cite{Bauer2015} en Effekt \cite{Brachthauser2020} zijn onderzoeks-programmeertalen ontwikkeld met als doel programmeren met effect handlers. De Haskell-library \emph{fused-effects} \footnote{\url{https://github.com/fused-effects/fused-effects}} biedt functionaliteit om in haskell programma's te maken met effect handlers. Deze library wordt gebruikt door Github in de semantic\footnote{\url{https://github.com/github/semantic}} library. Verder is er de Pyro \cite{bingham2019pyro} library voor flexibel en schaalbaar diep probabilistisch programmeren die volgens de auteurs gebouwd is op Poutine, een library om te programmeren met effect handlers, voor de flexibiliteit en separation of concerns die de aanpak met zich meebrengt.

\section{Gecombineerde calculus}
De meest bestudeerde vorm van effect handlers zijn de handlers die algebraïsche effecten behandelen\cite{Bauer2015}. Algebraïsche effecten zijn effecten die geschreven kunnen worden in de vorm $\textbf{op}\ v\ (y.\ c)$ met $v$ een parameter voor het effect en $(y. \  c)$ voor de continuatie of de rest van het programma na het effect. Een reden waarom deze vorm het meest bestudeerd is, is omdat deze effecten generisch kunnen sequencen en forwarden. \newline
Generische sequencing: 
\begin{equation}
    \inference{}{\textbf{do} \  x \leftarrow \textbf{op} \  l \  v \  (y. \  c_1); \   c_2 \leadsto \textbf{op} \  l \  v \  (y. \   \textbf{do} \  x \leftarrow \  c_1 ; \  c_2)}[E-DoOp]
\end{equation} 
Generische forwarding met h een handler die de operatie met label l niet behandelt:
\begin{equation}
    \inference{(\textbf{op}\:l\:\_\:\_) \notin h}{h \star \textbf{op}\:l\:v\:(y.\:c_{1}) \leadsto \textbf{op}\:l\:v\:(y.\: h \star c_{1})}[E-FwdOp]
\end{equation} 
Calculi van effect handlers zouden ideaal gezien drie eigenschappen moeten bezitten.
\begin{itemize}
    \item Overloading van de effecten: De effecten krijgen een verschillende semantiek door het schrijven en gebruiken van verschillende handlers voor hetzelfde programma.
    \item  Functie compositie: Het modulair combineren van verschillende effecten en effect handlers is mogelijk zonder strikte beperkingen.
    \item Effectinteracties: Effecten interageren met elkaar, waarbij de volgorde van de verschillende handlers een rol speelt en nieuwe semantische mogelijkheden biedt.
\end{itemize}

Het scheiden van operaties en hun behandeling, respectievelijk in de effecten en de handlers, zorgt voor overloading en modulaire compositie. Effectinteracties resulteren uit de compositie van niet-orthogonale effecten. \newline

Algebraïsche effect handlers zijn expressief beperkt in de zin dat ze geen model zijn voor alle computationele effecten. Dit vloeit rechtstreeks voort uit de syntaxis van algebraïsche effecten die als input enkel een parameter en de continuatie van het programma hebben waardoor het semantische domein beperkt is. De expressiviteit van programmeren met algebraïsche effect handlers is beperkt als gevolg hiervan. \newline

Het toevoegen van scoped effecten verhoogt de expressiviteit van een effect handler-gebaseerde programmeertaal. Scoped effecten splitsen het programma in een computatie in scope en een deel dat buiten de scope valt. Het resultaat is dat de handler deze continuatie in scope anders kan behandelen dan de computatie out of scope. Deze syntaxis laat complexere semantiek toe door het mogelijk te maken de computatie in scope een andere betekenis te geven dan de  continuatie. Generisch is de syntaxis te schrijven als $\textbf{sc}\:v\:(y.\:c_1)\:(z.\:c_2)$ met $v$ de parameter, $(y.\:c_1)$ de berekening in scope en $(z.\:c_2)$ de continuatie. De $\lambda_{sc}$ calculus \cite{Bosman2022} beschrijft een calculus voor algebraïsche en scoped effecten. Deze is expressiever dan een calculus voor enkel algebraïsche effecten. De $\lambda_{sc}$ calculus behandelt effecten echter strikt sequentieel en laat daardoor mogelijke performantieverbeteringen naast zich liggen. \newline

Methodiek toevoegen om effecten in parallel te behandelen kan de efficiëntie verbeteren. Parallelle algebraïsche effecten\cite{Xie2021} bieden deze mogelijkheid. De $\lambda^{p}$ calculus maakt parallelle afhandeling van effecten mogelijk door gebruik te maken van een parallelle \emph{for each constructie die effecten parallel behandelt} en levert zo mogelijk performantieverbeteringen voor parallelliseerbare algebraïsche effecten. \newline

\section{Doel}
Het doel van deze masterproef is het afleveren van een calculus met effect handlers die een formeel systeem modelleert met ondersteuning voor algebraïsche en scoped effecten en parallelle afhandeling van effecten. In de literatuur bestaat een leemte voor systemen die deze combinatie expliciet ondersteunen. Deze masterproef wil een ontwerp aanreiken voor een dergelijke calculus. Het resulterende ontwerp steunt op een sterke theoretische basis door een formele syntax, semantiek en type-en effectsysteem af te leveren maar kent ook praktische bruikbaarheid door de implementatie van een functionele interpreter. \newline

De beoogde calculus heeft minimaal volgende meta-eigenschappen: 
\begin{itemize}
    \item \emph{Veilig} voor het programmeren met effecten door het schrijven van overzichtelijke en duidelijke programma's mogelijk te maken door scheiding van syntax en semantiek van effecten door gebruik van de effect handler aanpak.
    \item \emph{Snel} door parallelle afhandeling van effecten mogelijk te maken.
    \item \emph{Compact} door een minimale calculus voor te stellen die aan deze eigenschappen voldoet.
    \item \emph{Draagbaar} door een calculus voor te stellen die wijd implementeerbaar is.
\end{itemize}

 De onderzoeksvraag voor deze masterproef luidt: \newline

\emph{Hoe kan een compacte calculus worden gedefinieerd die sequentiële en parallelle afhandeling van algebraïsche en scoped effecten modelleert met behoud van handler overloading, modulaire compositie en effect interacties?}

\section{Overzicht}
Hoofdstuk \ref{hoofdstuk:achtergrond} geeft meer achtergrondinformatie over de onderwerpen die deze masterproef behandelt. Vervolgens overloopt \Cref{hoofdstuk:startpunt} de literatuur waarop deze thesis voortbouwt. De motivatie voor dit onderwerp en de uitdagingen zijn het onderwerp van \Cref{hoofdstuk:motivatie}. De hoofdstukken die daarop volgen vormen de bijdrage van deze masterproef en stellen de $\lambda_{sc}^{p}$-calculus voor met de syntaxis in \Cref{hoofdstuk:syntaxis}, de operationele semantiek in \Cref{hoofdstuk:semantiek}, het type-en effect-systeem in \Cref{hoofdstuk:typesysteem}, voorbeelden in \Cref{hoofdstuk:voorbeelden} en de metatheorie in \Cref{hoofdstuk:metatheorie}. Vervolgens geeft hoofdstuk \Cref{hoofdstuk:evaluatie} een evaluatie van de masterproef, \Cref{hoofdstuk:gerelateerd} geeft een overzicht van gerelateerd werk. Tot slot bevat \Cref{besluit} de conclusie.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "masterproef"
%%% End: 