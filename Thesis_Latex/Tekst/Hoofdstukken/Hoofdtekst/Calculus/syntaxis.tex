\chapter{Syntaxis}
\label{hoofdstuk:syntaxis}


Dit hoofdstuk bespreekt de syntaxis voor de gecombineerde $\lambda_{sc}^p$-calculus. Tabel \ref{fig:syntaxisNodig} stelt de syntaxis voor met de \emph{nodige uitbreidingen} op de $\lambda_{sc}$-calculus gemarkeerd. 
% De belangrijkste toevoeging is de \textbf{for} clausule in de handler. Bijhorend is een lijst-structuur voor waarden en een lijst-structuur voor computaties. 
Merk op dat de calculus \emph{geen nieuwe effect operatie} introduceert. Sectie \ref{sec:SyntaxFor} bespreekt de reden hiervoor. \newline
Tabel \ref{fig:syntaxisHandig} toont \emph{handige uitbreidingen} om de evaluatie van meer programma's mogelijk te maken. Deze tabel beschrijft een \textbf{let rec} constructie om \emph{recursieve functie evaluatie} mogelijk te maken, een \textbf{if} \emph{conditionele constructie} en enkele hulp-functies om \emph{paar- en lijst-manipulatie} toe te laten. Deze toevoegingen zijn niet essentieel om een minimaal werkende calculus te bekomen maar wel nodig om de voorbeelden te kunnen evalueren. De volgende secties bespreken de verschillende toegevoegde syntactische elementen.

\section{For clausule}
\label{sec:SyntaxFor}
%De \textbf{for} clausule modelleert parallelle behandeling in de calculus. 
Het doel van deze calculus is om zoals in de $\lambda^p$-calculus uitgaande van een parallelle pure \emph{for each} functie parallelle, gebruiker-gedefinieerde parallelle effecten te modelleren\cite{Xie2021}. De $\lambda^p$-calculus gebruikt hiervoor een \textbf{for} clausule in de vorm ''$\textbf{for} \ x : n. \ e$'' om zowel de pure \emph{for each} te presenteren als de \textbf{for} clausule als effect operatie.
\begin{table}[h]
    \centering
    \begin{tabular}{c c c c c c}
        $\lambda^p$-calculus: & \textbf{for} &  & x : n. & e &  (impliciete k) \\
        $\lambda_{sc}$-calculus: & \textbf{sc} & $l^{sc}$ & x & p & k \\  
        & sleutelwoord & label & argument & computatie in scope & continuatie \\
    \end{tabular}
    \caption{Syntaxis vergelijking tussen \textbf{for} in $\lambda^p$ en \textbf{sc} in $\lambda_{sc}$}
    \label{tab:synForSc}
\end{table}
%De \textbf{for} clausule die deze syntaxis aanlevert, bestaat uit het sleutelwoord \textbf{for}, gevolgd door een for-label,  een lijst van waarden, gevolgd door een functie $(y. \ c_{1})$, gevolgd door de resumptie $(z. \  c_{2})$ die de continuatie van het programma bevat. 
Merk op dat de syntaxis van de \textbf{for} clausule sterk gelijkt op die van de \textbf{sc} clausule, met uitzondering van het missen van een label omdat in de $\lambda^p$-calculus slechts \'e\'en parallel effect per programma kan gedefinieerd worden en dat de continuatie niet expliciet is voor het \textbf{for}-statement.
%deze niet als \'e\'en clausule kan beschouwd worden omdat de semantiek zal verschillen. 
%De syntaxis lijkt sterk op de syntaxis uit de $\lambda^p$-calculus met de uitzondering van het toegevoegde label. 
Het label laat toe om meerdere verschillende parallelle/scoped effecten binnen hetzelfde programma te evalueren. \newline 
Deze thesis argumenteert dat de parallel niet stopt bij de syntaxis maar \emph{volledig door te trekken is}.
 %De standaard \textbf{for} behandeling (om een parallelle \emph{for each} constructie te benaderen) zou zijn om de functie, in parallel, op elke waarde in de lijst toe te passen en het resultaat als input van de continuatie te gebruiken. Aangezien de calculus een effect handler aanpak voorstelt, is dat slechts een mogelijke implementatie van de handler. De handler bepaalt hoe de \textbf{for} constructie te behandelen. Aangezien deze computatie nieuwe \textbf{for} constructies kan introduceren, is het raadzaam om elk programma met \textbf{for} constructies als buitenste handler te behandelen door een pure handler om eventuele overgebleven \textbf{for} constructies puur af te handelen.
 %De \textbf{for} clausule heeft in tegenstelling tot de \textbf{op} of \textbf{sc} clausule geen label omdat deze clausule geen specifiek effect voorsteld maar een generieke \textbf{for-each} constructie over een lijst. 

%\begin{equation}
%    \textbf{for}\quad (input_1:input_2:input_3:[\:\:]) \quad (input.\:\textbf{effect}\:input) \quad(result.\:\textbf{rest})
%\end{equation}


%\begin{equation}
%    \begin{split}
%    & \textbf{hPure} = \textbf{handler} \\
%    & \{ \\
%    & \qquad ... \\
%    & \qquad    \textbf{for}\:lst\:p\:k \rightarrow \textbf{do}\:res \leftarrow map\:p\:lst \\
%    &  \qquad \qquad \qquad \qquad k\:res \\
%    & \} 
%\end{split}  
%\end{equation}

\begin{table}
    \centering
    \begin{tabular}{|r c l r|}
    \hline 
         waarden $v$ & $::=$ & $() \ \ | \ \ (v_{1}, \ v_{2} ) \ \ | \ \ x \ \ | \ \ \lambda x . \ c \ \ | \ \ h$ & \\
         & $|$ & \hl{lstV[A]} & \\
         handlers $h$ & $::=$ & $\textbf{handler} \ \{ \ \ \textbf{return} \ x \mapsto c_{r}$ & return clausule\\
         & & $\qquad \qquad \quad , \ oprs$ & effect  clausules \\
         & & $\qquad \qquad \quad , \ \textbf{fwd} \ f \ p \ k \mapsto c_{f} \}$ & forwarding clausule \\
         \hl{lijst waarden $lstV[A]$} & $::=$ & \hl{$nilV[A]\  \  | \  \  consV[A] \ 
 v_1 \  v_2$} & \hl{lijst van waarden}\\
          effect clausules $oprs$ & $::=$ & . & \\ 
          & $|$ & $\textbf{op} \ l^{op} \ x \ k \mapsto c, \ oprs$ & algebraïsch effect clausule\\
           & $|$ & $\textbf{sc} \ l^{sc} \ x \ p \ k \mapsto c, \ oprs$ & scoped effect clausule\\
        % & $|$ & \hl{$\textbf{for}\  l^{for} \  x \  p \  k \mapsto c, \  oprs$} & \hl{for effect clausule} \\
         computaties $c$ & $::=$ & $\textbf{return} \ v$ & return waarde \\
          & $|$ & $\textbf{op} \ l^{op} \ v \ (y. \ c)$ & algebraïsch effect \\
          & $|$ & $\textbf{sc} \ l^{sc} \ v \ (y. \ c_{1}) \ (z. \ c_{2})$ & scoped effect \\
          % & $|$ & \hl{$\textbf{for} \ l^{for} \ v \ (y. \ c_{1}) \ (z. \ c_{2})$} & \hl{for effect} \\
          & $|$ & $v \star c$ & behandeling \\
          & $|$ & $\textbf{do} \ x \leftarrow c_{1}; \ c_{2}$ & do clausule \\
          & $|$ & $v_{1} \ v_{2}$ & applicatie \\
          & $|$ & $\textbf{let} \ x = v \ \textbf{in} \ c$ & let \\
          & $|$ & \hl{\textbf{map} \ $v_1$ \ $v_2$} & \hl{map over lstv} \\
          & $|$ & \hl{$lstC[A]$} & \hl{lijst computaties} \\
          \hl{lijst computaties $lstC[A]$} & $::=$ & \hl{$nilC[A] \ 
 \  | \  \  consC[A] \  c_1 \  c_2$} & \hl{lijst computaties}\\
         waarde types $A, \ B, \ M$ & $::=$ & $() \ \ | \ \ (A, \ B) \ \ | \ \ A \rightarrow \underline{C} \ \ | \ \ \underline{C} \Rightarrow \underline{D}$ & \\
         & $|$ & $\alpha$ & type variabele \\
         & $|$ & $\lambda \ \alpha . \ A$ & type operator abstractie \\
         & $|$ & $M \ A$ & type applicatie \\
         & $|$ & \hl{ListV A} & \hl{lijst waarden}\\
         type schemas $\sigma$ & $::=$ & $A \ \ | \ \ \forall \ \mu . \ \sigma \ \ | \ \ \forall \ \alpha . \ \sigma $ & \\
         computatie types $\underline{C}, \ \underline{D}$ & $::=$ & $A ! \langle E \rangle $ & \\
         & $|$ & \hl{ListC $\underline{C}$} & \hl{lijst computaties}\\
         effect type rows $E, \: F$ & $::=$ & $ . \ \ | \ \ \mu \ \ | \ \ l ; \ E$ & \\
         %kinds $K$ & $::=$ & $* \: \: | \: \: K \rightarrow K$ & \\
         signatuur contexten $\Sigma$ & $::=$ & $ . $ & \\
         & $|$ & $\Sigma , \ l^{op} : A_{op} \rightarrowtriangle B_{op}$ & \\
         & $|$ & $\Sigma , \ l^{sc} : A_{sc} \rightarrowtriangle B_{sc}$ & \\
         % & $|$ & \hl{$\Sigma , \ l^{for} : A_{for} \rightarrowtriangle B_{for}$} & \\
         type contexten $\Gamma$ & $::=$ & $. \: \: | \:\: \Gamma, \: x \: : \: A \: \: | \: \: \Gamma , \: \mu \: \: | \: \: \Gamma, \: \alpha $ & \\
    \hline
    \end{tabular}
    \caption{$\lambda_{sc}^{p}$ Syntaxis met uitbreidingen gemarkeerd}
    \label{fig:syntaxisNodig}
\end{table}


\begin{table}
    \centering
    \begin{tabular}{|r c l r|}
    \hline 
        & & & \\
        waarden $v$ & $::=$ & \hl{true | false} & \hl{booleans} \\
        & & & \\
         computaties $c$ & $::=$ & \hl{$\textbf{let rec} \: f \: = \: c_{1} \: \textbf{in} \: c_{2}$} & \hl{let rec} \\
         & $|$ & \hl{\textbf{if} v \textbf{then} $c_1$ \textbf{else} $c_2$} & \hl {conditie} \\
          & $|$ & \hl{\textbf{headV[A]} \ v} & \hl{head lstv} \\
          & $|$ & \hl{\textbf{tailV[A]} \ v} & \hl{tail lstv} \\
          & $|$ & \hl{\textbf{emptyV[A]} \ v} & \hl{test lege lstv} \\
          & $|$ & \hl{\textbf{headC[A]} \ c} & \hl{head lstc} \\
          & $|$ & \hl{\textbf{tailC[A]} \ c} & \hl{tail lstc} \\
          & $|$ & \hl{\textbf{emptyC[A]} \ c} & \hl{test lege lstc} \\
          & $|$ & \hl{\textbf{fst}\:v} & \hl{first paar} \\
          & $|$ & \hl{\textbf{snd}\:v} & \hl{second paar} \\
          & & & \\
          waarde types $A, \: B, \: M$ & $::=$ & \hl{Bool} & \hl{boolean} \\ 
         & & & \\
    \hline
    \end{tabular}
    \caption{Uitbreidingen op de $\lambda_{sc}^{p}$ Syntaxis om de calculus meer bruikbaar te maken}
    \label{fig:syntaxisHandig}
\end{table}

\section{Lijst-structuur}
De calculus heeft nood aan een manier om een pure parallelle for each functie te definiëren. De minimale vereiste om computaties in parallel uit te voeren is een samengestelde datastructuur waarop een parallelle iterator kan gedefinieerd worden om een functie toe te passen op de verschillende inputwaarden.
%samengestelde data-structuur in de calculus die de verschillende computaties die de machine parallel uitvoert bijhoudt. 
Deze calculus gebruikt een lijst-structuur maar in principe is elke lineaire datastructuur mogelijk. \newline
%op elke lineaire datastructuur. \newline
%aangezien op elk van deze het mogelijk is (maar niet noodzakelijk efficiënt) een head, tail en empty functie te implementeren. 
%Een voorbeeld van een lijst van computaties is: 
%\begin{equation} \label{eq:listEx}
%    \begin{split}
%    (39 + 49):(29 + 74):(100 + 61):(41 + 56):(97 + 67):[\:\:] \\
%    \leadsto 88:103:161:97:164:[\:\:]
%    \end{split}
%\end{equation} 
%De reductie in dit voorbeeld kan parallel gebeuren voor elk element in de lijst. \newline
Aangezien de $\lambda_{sc}$-calculus syntaxis een strikte scheiding hanteert tussen waarden en termen ligt het voor de hand dat de $\lambda_{sc}^{p}$-calculus eveneens strikt onderscheid maakt tussen \emph{lijsten van waarden} en \emph{lijsten van computaties}. \newline
De syntaxis neemt inspiratie van de syntaxis voor lijsten beschreven in Hoofdstuk 11.12 in TAPL\cite{Pierce2002}.

\subsection{Lijst van waarden}
Een lijst van waarden is zelf een waarde. De syntaxis is intuïtief, de lijst is een lege lijst ($nilV[A]$) van een bepaald type A of een compositie van een waarde en een lijst ($consV[A] \  v_1 \ 
 v_2$), de waarde met type A en de lijst met type ListV van A. Het type-systeem in \Cref{hoofdstuk:typesysteem} controleert de vereiste dat de waarden het juiste type bezitten. De lijst van waarden voegt het waarde type $ListV \ A$ toe.

\subsection{Lijst van computaties}
%Een lijst van compuaties is een computatie, dit omdat de elementen in de lijst kunnen reduceren en semantische regels geïntroduceerd worden in Sectie \ref{hoofdstuk:semantiek} om een lijst te reduceren naar een lijst van normaalwaarden. Hiervoor moet de lijst zelf een computatie zijn omdat een reductie in de $\lambda_{sc}^{p}$-calculus een computatie naar een andere computatie mapt. 
De syntaxis voor een lijst van computaties is intuïtief en analoog aan de lijst van waarden. De lijst is een lege lijst ($nilC[A]$) van een bepaald type A of een compositie van een computatie en een lijst ($consC[A] \  c_1 \ 
 c_2$), de computatie met type A en de lijst met type ListC van $\underline{C}$. Het type-systeem in \Cref{hoofdstuk:typesysteem} controleert de vereiste dat de computaties het juiste type bezitten. De lijst van computaties voegt het computatie type $ListC \ \underline{C}$ toe.

\subsection{Lijst-manipulatie functies}
Om voorbeelden uit te werken heeft de lijst-structuur een \textbf{head}, \textbf{tail} en \textbf{empty} functie nodig om elementen uit de lijst te halen en na te kijken of de lijst leeg is. Deze minimale implementatie is aanwezig in de syntaxis door de \emph{\textbf{headV[A]} v, \textbf{tailV[A]} v, \textbf{emptyV[A]} v, \textbf{headC[A]} c, \textbf{tailC[A]} c en \textbf{emptyC[A]} c} computaties. De volgende voorbeelden illustereren kort de syntaxis en semantiek van deze functies. De calculus is in de voorbeelden impliciet uitgebreid met een $Int$ basis-type.

\begin{equation}
    \begin{split}
        & \textbf{headV[Int]}\:(consV[Int] \  5 \  consV[Int] \  3 \  consV[Int] \  8 \  nilV[Int]) \\
        & \leadsto \textbf{return}\:5
    \end{split}
\end{equation}
Veronderstel in de volgende voorbeelden dat de calculus is uitgebreid met een \textbf{double} computatie die een $Int$ verdubbelt.

\begin{equation}
    \begin{split}
        & \textbf{headC[Int]}\:(consC[Int] \  (\textbf{double} \ 5) \   consC[Int] \ 
 (\textbf{double} \ 3) \  nilC[Int]) \\
        & \leadsto \textbf{return}\:(\textbf{double}\:5)
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{tailV[Int]} \ (consV[Int] \ 5 \ consV[Int] \  3 \  consV[Int] \  8 \  nilV[Int]) \\
        & \leadsto \textbf{return} \  (consV[Int] \  3 \  consV[Int] \  8 \  nilV[Int])
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{tailC[Int]} \ (consC[Int] \  (\textbf{double}\:5) \ 
 consC[Int] \  (\textbf{double}\:3) \ nilC[Int]) \\
        & \leadsto \textbf{return}\:(consC[Int] \  (\textbf{double}\:3) \ nilC[Int) 
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{emptyV[Int]}\:(consV[Int] \ 5 \  nilV[Int]) \\
        & \leadsto \textbf{return}\:false
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{emptyC[Int]} \ (consC[Int] \ (\textbf{double}\:5) \ nilC[Int]) \\
        & \leadsto \textbf{return}\:false
    \end{split}
\end{equation}


\begin{equation}
    \begin{split}
        & \textbf{emptyV[Int]} \ nilV[Int] \\
        & \leadsto \textbf{return} \ true
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{emptyC[Int]} \ nilC[Int] \\
        & \leadsto \textbf{return} \ strue
    \end{split}
\end{equation}

\subsection{Map functie}
De \textbf{map} constructie modelleert een functie die een lijst van waarden omvormt naar een lijst van computaties met als argument een lambda-functie om toe te passen op de lijst van waarden. Hieronder een demonstratie doormiddel van een simpel voorbeeld en het uiteindelijke resultaat na evaluatie.

\begin{equation}
    \begin{split}
        & \textbf{map}\:(\lambda x . \ x+1)\:(consV[Int] \ 5 \ consV[Int] \  3 \  consV[Int] \ 8 \  nilV[Int]) \\
        & \leadsto * \quad \textbf{return} \  (consV[Int] \ 6 \ consV[Int] \  4 \  consV[Int] \ 9 \  nilV[Int])
    \end{split}
\end{equation}
Het doel van deze constructie is om de \emph{parallelle constructie} te vormen die een lijst van computaties vormt die allen in parallel geëvalueerd worden. De calculus wijkt hier af van de $\lambda^p$-calculus aangezien door de scheiding te maken waar in $\lambda^{p}$ de \textbf{for} clausule beide rollen opneemt. Enerzijds de effect operatie zoals in de \textbf{E-Traverse} regel en anderzijds de pure, parallelle for each als in de \textbf{E-Parallel} regel. \newline 
Een voordeel van de expliciete scheiding is dat deze calculus ook eenvoudig gebruik kan maken van pure parallelle for each door de \textbf{map} constructie.

\section{Recursieve let}
De \textbf{let rec} constrcutie laat toe om recursieve functies te implementeren in de calculus. De syntaxis is voornamelijk gebaseerd op de syntaxis voor \textbf{let rec} beschreven in hoofdstuk twee van het boek "Principles of Programming Languages" \cite{Palmer2009} en les 11 van CS6110 aan de Cornell-universiteit \cite{Sampson2018} maar wordt op soortgelijke manier voorgesteld in TAPL \cite{Pierce2002} in Sectie 11.11. \newline 
%Voor simpliciteit is gekozen om slechts 1 recursieve functie toe te laten in tegenstelling tot implementaties die een lijst van recursieve functies toelaten. Dit in referentie naar de syntaxis van \textbf{letrec}, $\textbf{letrec} \ f = c_1 \ in \ c_2$ waarbij de $c_1$ ook een lijst. omdat deze implementatie de semantische regels vereenvoudigt en voldoende expressief is om de gewenste voorbeelden uit te werken. \newline 
Recursieve functies zijn nodig om enkele functies te definiëren die handig zijn om interessante voorbeelden uit te worken zoals bijvoorbeeld een implementatie van foldr:

\begin{equation} \label{eq: sumEx}
    \begin{split}
        \textbf{let\:rec}\:foldr\:= &\:l\:op\:mempty.\: \\
        & \textbf{do}\:n\leftarrow \textbf{empty}\:l; \\
        & \textbf{if}\:n\:\textbf{then}\:\textbf{return}\:mempty \\
        & \textbf{else} \\
        & \qquad \textbf{do}\:h \leftarrow \textbf{head}\:l;\\
        & \qquad \textbf{do}\:t \leftarrow \textbf{tail}\:l; \\
        & \qquad \textbf{do}\:y \leftarrow \textbf{foldr}\:t\:op\:mempty    ; \\
        & \qquad \textbf{return}\:(op\:h\:y)\:\textbf{in} \\
        & \qquad \qquad \textbf{foldr}\:(consV[Int] \  1 \  consV[Int] \ 2 \ nilV[Int])\:(+)\:0;\\
    \end{split}
\end{equation}

Dit voorbeeld programma telt de waarden in de lijst [1,2] op tot 3.

\section{Booleans}
Een handige praktische toevoeging aan de calculus is om booleans toe te voegen als basis type. Deze uitbreiding laat vervolgens een extensie met condities die meer expressieve voorbeelden toelaten.

\begin{equation}
    true
\end{equation}

\begin{equation}
    false
\end{equation}

\section{Conditie}
Een simpele conditie om de controlestroom van programma's te bepalen op basis van een test.

\begin{equation}
    \begin{split}
        & \textbf{if}\  true \  \textbf{then} \  \textbf{return} \  0 \  \textbf{else} \  \textbf{return} \  1 \\
        & \leadsto \textbf{return}\  0
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{if}\  false \  \textbf{then} \  \textbf{return} \  0 \  \textbf{else} \  \textbf{return} \  1 \\
        & \leadsto \textbf{return}\  1
    \end{split}
\end{equation}





%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "masterproef"
%%% End: 
