\chapter{Syntaxis}
\label{hoofdstuk:syntaxis}
% TODO: scheiding van NODIGE uitbreidingen en HANDIGE uitbreidingen

Tabel \ref{fig:syntaxis} toont de syntaxis voor de termen en types in de $\lambda_{sc}^{p}$ calculus. De uitbreidingen op de $\lambda_{sc}$ calculus zijn gemarkeerd. De syntaxis is uitgebreid met een lijst-structuur voor waarden, een lijst-structuur voor computaties en handler clausules om de parallelle afhandeling van effecten mogelijk te maken. Verder is ook een \textbf{let rec} constructie toegevoegd om recursieve functies mogelijk te maken, een \textbf{if} constructie en enkele hulp-functies voor paar- en lijst-manipulatie.

\begin{table}
    \centering
    \begin{tabular}{|r c l r|}
    \hline 
         waarden $v$ & $::=$ & $() \: \: | \: \: (v_{1}, \: v_{2} ) \: \: | \: \: x \: \: | \: \: \lambda x . \: c \: \: | \: \: h \:\: | lstv$ & \\
         handlers $h$ & $::=$ & $\textbf{handler} \: \{ \: \: \textbf{return} \: x \mapsto c_{r}$ & return clausule\\
         & & $\qquad \qquad \quad , \: oprs$ & effect  clausules \\
         & & $\qquad \qquad \quad , \: \textbf{fwd} \: f \: p \: k \mapsto c_{f} \: $ & forwarding clausule \\
        & & \qquad \qquad \quad \hl{$, \:\textbf{for}\:lstv\:p\:k \mapsto c\}$} & \hl{for clausule} \\
         \hl{lijst waarden $lstv$} & $::=$ & \hl{$[\:\:]\:\:|\:\:v:lstv$} & \hl{lijst van waarden}\\
          effect clausules $oprs$ & $::=$ & . & \\ 
          & $|$ & $\textbf{op} \: l \: x \: k \mapsto c, \: oprs$ & algebraïsch effect \\
           & $|$ & $\textbf{sc} \: l \: x \: p \: k \mapsto c, \: oprs$ & scoped effect\\
        & & & \\
         computaties $c$ & $::=$ & $\textbf{return} \: v$ & return waarde \\
          & $|$ & $\textbf{op} \: l \: v \: (y. \: c)$ & algebraïsch effect \\
          & $|$ & $\textbf{sc} \: l \: v \: (y. \: c_{1}) \: (z. \: c_{2})$ & scoped effect \\
          & $|$ & \hl{$\textbf{for} \: v \: (y. \: c_{1}) \: (z. \: c_{2})$} & \hl{for effect} \\
          & $|$ & $v \star c$ & behandeling \\
          & $|$ & $\textbf{do} \: x \leftarrow c_{1}\:; \: c_{2}$ & do clausule \\
          & $|$ & $v_{1} \: v_{2}$ & applicatie \\
          & $|$ & $\textbf{let} \: x = v \: \textbf{in} \: c$ & let \\
          & $|$ & \hl{$\textbf{let rec} \: f \: = \: c_{1} \: \textbf{in} \: c_{2}$} & \hl{let rec} \\
          & $|$ & \hl{\textbf{head}\:v} & \hl{head lstv} \\
          & $|$ & \hl{\textbf{tail}\:v} & \hl{tail lstv} \\
          & $|$ & \hl{\textbf{empty}\:v} & \hl{test lege lstv} \\
          & $|$ & \hl{\textbf{head}\:c} & \hl{head lstc} \\
          & $|$ & \hl{\textbf{tail}\:c} & \hl{tail lstc} \\
          & $|$ & \hl{\textbf{empty}\:c} & \hl{test lege lstc} \\
          & $|$ & \hl{\textbf{fst}\:v} & \hl{first paar} \\
          & $|$ & \hl{\textbf{snd}\:v} & \hl{second paar} \\
          & $|$ & \hl{\textbf{map}\:f\:v} & \hl{map over lstv} \\
          & $|$ & \hl{$lstc$} & \hl{lijst computaties} \\
          \hl{lijst computaties $lstc$} & $::=$ & \hl{$[\:\:]\:\:|\:\:c\::\:lstc$} & \hl{lijst computaties}\\
         & & & \\
         waarde types $A, \: B, \: M$ & $::=$ & $() \: \: | \: \: (A, \:B) \: \: | \: \: A \rightarrow \underline{C} \: \: | \: \: \underline{C} \Rightarrow \underline{D}$ & \\
         & $|$ & $\alpha$ & type variabele \\
         & $|$ & $\lambda \: \alpha . \: A$ & type operator abstractie \\
         & $|$ & $M \: A$ & type applicatie \\
         type schemas $\sigma$ & $::=$ & $A \: \: | \: \: \forall \: \mu . \: \sigma \: \: | \: \: \forall \: \alpha. \: \sigma $ & \\
         computatie types $\underline{C}, \: \underline{D}$ & $::=$ & $A ! \langle E \rangle $ & \\
         effect type rows $E, \: F$ & $::=$ & $. \: \: | \: \: \mu \: \: | \: \: l; \: E $ & \\
         kinds $K$ & $::=$ & $* \: \: | \: \: K \rightarrow K$ & \\
         signatuur contexten $\Sigma$ & $::=$ & $. \: \: | \: \: \Sigma , \: l \: : \: A \rightarrowtriangle B$ & \\
         type contexten $\Gamma$ & $::=$ & $. \: \: | \:\: \Gamma, \: x \: : \: A \: \: | \: \: \Gamma , \: \mu \: \: | \: \: \Gamma, \: \alpha $ & \\
    \hline
    \end{tabular}
    \caption{$\lambda_{sc}^{p}$ Syntaxis}
    \label{fig:syntaxis}
\end{table}

\section{Lijst-structuur}
Een mogelijke manier om parallelle afhandeling van effecten mogelijk te maken is functionaliteit toe te voegen waardoor een lijst van computaties die mogelijk effecten bevatten parallel behandeld kunnen worden. Daarvoor is het essentieel om datastructuren te hebben die meerdere computaties kunnen opslaan om zo de verschillende computaties die parallel moeten reduceren te groeperen. Een lijst-structuur is een datastructuur die relatief eenvoudig te implementeren is, weinig eigen complexe functies met zich meebrengt en bijgevolg relatief eenvoudig te vervangen door een andere datastructuur indien nodig. Een voorbeeld van een lijst van computaties is: 

\begin{equation} \label{eq:listEx}
    \begin{split}
    (39 + 49):(29 + 74):(100 + 61):(41 + 56):(97 + 67):[\:\:] \\
    \leadsto 88:103:161:97:164:[\:\:]
    \end{split}
\end{equation} 

De reductie in dit voorbeeld kan parallel gebeuren voor elk element in de lijst. \newline

Aangezien de $\lambda_{sc}$-calculus syntaxis een strikte scheiding heeft tussen waarden en termen ligt het voor de hand dat dit onderscheid er ook zou zijn voor lijsten in de $\lambda_{sc}^{p}$-calculus.

\subsection{Lijst van waarden}
Een lijst van waarden is zelf een waarde. De syntaxis is intuïtief, de lijst eindigt op een lege lijst $[\:\:]$ en wordt voorgegaan door één of meerdere waarden.

\subsection{Lijst van computaties}
Een lijst van compuaties is een computatie, dit omdat de elementen in de lijst kunnen reduceren en semantische regels geïntroduceerd worden in Sectie \ref{hoofdstuk:semantiek} om een lijst te reduceren naar een lijst van normaalwaarden. Hiervoor moet de lijst zelf een computatie zijn omdat een reductie in de $\lambda_{sc}^{p}$-calculus een computatie naar een andere computatie mapt. De syntaxis voor de lijst is intuïtief en analoog aan de lijst van waarden, de lijst eindigt op een lege lijst $[\:\:]$ en wordt voorgegaan door één of meerdere computaties.

\subsection{Lijst-manipulatie functies}
De lijst heeft minimaal een \textbf{head}, \textbf{tail} en \textbf{empty} functie nodig om elementen uit de lijst te halen en na te kijken of de lijst leeg is. Deze minimale implementatie is aanwezig in de syntaxis.

\begin{equation}
    \begin{split}
        & \textbf{head}\:(5:3:8:4:[\:\:]) \\
        & \leadsto \textbf{return}\:5
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{head}\:((\textbf{double}\:5):(\textbf{double}\:3):(\textbf{double}\:8):(\textbf{double}\:4):[\:\:]) \\
        & \leadsto \textbf{return}\:(\textbf{double}\:5)
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{tail}\:(5:3:8:4:[\:\:]) \\
        & \leadsto \textbf{return}\:(3:8:4:[\:\:])
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{tail}\:((\textbf{double}\:5):(\textbf{double}\:3):(\textbf{double}\:8):(\textbf{double}\:4):[\:\:]) \\
        & \leadsto \textbf{return}\:((\textbf{double}\:3):(\textbf{double}\:8):(\textbf{double}\:4):[\:\:]) 
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{empty}\:(5:3:8:4:[\:\:]) \\
        & \leadsto \textbf{return}\:false
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        & \textbf{emmpty}\:((\textbf{double}\:5):(\textbf{double}\:3):(\textbf{double}\:8):(\textbf{double}\:4):[\:\:]) \\
        & \leadsto \textbf{return}\:false
    \end{split}
\end{equation}


\begin{equation}
    \begin{split}
        & \textbf{empty}\:[\:\:] \\
        & \leadsto \textbf{return}\:true
    \end{split}
\end{equation}

\subsection{Map functie}
Een map functie die een lijst van waarden omvormt naar een lijst van computaties met als argument een functie om toe te passen op de lijst van waarden.

\begin{equation}
    \begin{split}
        & \textbf{map}\:(+1)\:(5:3:8:4:[\:\:]) \\
        & \leadsto \textbf{return}\:(6:4:9:5:[\:\:])
    \end{split}
\end{equation}

\section{Recursieve let}
\textbf{let rec} helpt om recursieve functies te implementeren in de calculus. De syntaxis is gebaseerd op de syntaxis voor \textbf{let rec} beschreven in hoofdstuk twee van het boek "Principles of Programming Languages" \cite{Palmer2009} en les 11 van CS6110 aan de Cornell-universiteit \cite{Sampson2018}. Voor simpliciteit is gekozen om slechts 1 recursieve functie toe te laten omdat die semantische regels vereenvoudigt en voldoende expressief is om de gewenste voorbeelden uit te werken.  Recursieve functies zijn nodig om complexere functies te definiëren zoals bijvoorbeeld een implementatie van foldr:

\begin{equation} \label{eq: sumEx}
    \begin{split}
        \textbf{let\:rec}\:foldr\:= &\:l\:op\:mempty.\: \\
        & \textbf{do}\:n\leftarrow \textbf{empty}\:l; \\
        & \textbf{if}\:n\:\textbf{then}\:\textbf{return}\:mempty \\
        & \textbf{else} \\
        & \qquad \textbf{do}\:h \leftarrow \textbf{head}\:l;\\
        & \qquad \textbf{do}\:t \leftarrow \textbf{tail}\:l; \\
        & \qquad \textbf{do}\:y \leftarrow \textbf{foldr}\:t\:op\:mempty    ; \\
        & \qquad \textbf{return}\:(op\:h\:y)\:\textbf{in} \\
        & \qquad \qquad \textbf{foldr}\:(1:2:5:6:[\:\:])\:(+)\:[\:\:];\\
    \end{split}
\end{equation}

Dit voorbeeld programma telt de waarden in de lijst (1:2:5:6:[ ]) op tot 14.

\section{Handler clausules}
Deze sectie behandelt de clausules die moeten toegevoegd worden aan de handlers om parallelle behandeling van effecten mogelijk te maken. Het doel is om effecten parallel te behandelen in een lijst, maar enkel dit doen is niet voldoende.

\begin{equation}
    \begin{split}
    & ((\textbf{effect}\:input_1):(\textbf{effect}\:input_2):(\textbf{effect}\:input_3):[\:\:]); \\
    & \textbf{rest van het programma} \\
    &\leadsto ((output_1):(output_2):(output_3):[\:\:]); \\
    & \textbf{rest van het programma} \\
    &\leadsto ?
    \end{split}
\end{equation}

De lijst van effecten moet linken aan de rest van het programma. Hiervoor is een nieuwe clausule nodig. De \textbf{for} clausule bestaat uit het sleutelwoord \textbf{for}, gevolgd door een lijst van waarden, gevolgd door een mapping-functie $(y.\:c_{1})$ die op alle waarden in de gegeven lijst wordt uitgevoerd, gevolgd door de resumptie $(z.\:c_{2})$ die de continuatie van het programma bevat gegeven de resulterende lijst van waarden na toepassing van de mapping-functie. De \textbf{for} clausule heeft in tegenstelling tot de \textbf{op} of \textbf{sc} clausule geen label omdat deze clausule geen specifiek effect voorsteld maar een generieke \textbf{for-each} constructie over een lijst. 

\begin{equation}
    \textbf{for}\quad (input_1:input_2:input_3:[\:\:]) \quad (input.\:\textbf{effect}\:input) \quad(result.\:\textbf{rest})
\end{equation}

Een handler heeft de vrije keuze over hoe een \textbf{for} constructie te behandelen. De standaard benadering voor handlers die geen specifieke \textbf{for} clausule implementeren is om de \textbf{for} clausule terug te geven, waarbij de handler binnen de mapping-functie en de resumptie geschoven worden, zie \textbf{E-FwdFor} in Tabel \ref{fig:semantiek}. Het is raadzaam dat elk programma met \textbf{for} constructies ls buitenste handler een \textbf{hPure} handler heeft om eventuele overgebleven pure \textbf{for} constructies af te handelen.

\begin{equation}
    \begin{split}
    & \textbf{hPure} = \textbf{handler} \\
    & \{ \\
    & \qquad ... \\
    & \qquad    \textbf{for}\:lst\:p\:k \rightarrow \textbf{do}\:res \leftarrow map\:p\:lst \\
    &  \qquad \qquad \qquad \qquad k\:res \\
    & \} 
\end{split}  
\end{equation}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "masterproef"
%%% End: 
