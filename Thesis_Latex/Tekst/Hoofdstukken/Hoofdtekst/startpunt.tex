\chapter{Startpunt}\label{hoofdstuk:startpunt}
Deze masterproef heeft als doel een calculus voor te stellen die algebraïsche en scoped effecten en effect handlers als \texttt{first-class citizens} beschouwt met sequentiële en parallelle behandeling voor deze effecten. Het startpunt voor deze calculus is $\lambda_{sc}$\cite{Bosman2022}, een calculus die sequentiële behandeling van scoped en algebraïsche effecten ondersteunt. Voor parallelle behandeling van effecten bestaat de $\lambda^{p}$-calculus\cite{Xie2021}, een calculus die parallelle algebraïsche effecten ondersteunt. Het doel van de thesis is de concepten uit deze laatste calculus te vertalen naar een vorm gelijkaardig aan de eerste calculus en aan deze toe te voegen. Dit hoofdstuk bespreekt beide calculi om de lezer een idee te geven van de bestaande lectuur en wat als eigen contributie nodig is om het doel te bereiken.

\section{\texorpdfstring{$\lambda_{sc}$ :}{} Scoped Effecten} \label{hoofdstuk:startpuntScoped}
Deze sectie stelt de calculus voor algebraïsche en scoped effecten \cite{Bosman2022} die als startpunt dient voor deze masterproef. Deze calculus is gebaseerd op Eff \cite{Bauer2015}. De calculus gebruikt een effect systeem zoals Koka \cite{Leijen2017} om effecten te typeren. De hoofdcontributie van de calculus over Eff is de capaciteit om scoped effecten te modelleren.
\begin{table}
    \centering
    \begin{tabular}{|r c l r|}
    \hline
         & & & \\ 
         waarden $v$ & $::=$ & $() \: \: | \: \: (v_{1}, \: v_{2} ) \: \: | \: \: x \: \: | \: \: \lambda x . \: c \: \: | \: \: h$ & \\
         handlers $h$ & $::=$ & $\textbf{handler} \: \{ \: \: \textbf{return} \: x \mapsto c_{r}$ & return clausule\\
         & & $\qquad \qquad \quad , \: oprs$ & effect  clausules \\
         & & $\qquad \qquad \quad , \: \textbf{fwd} \: f \: p \: k \mapsto c_{f} \: \} $ & forwarding clausule \\
         & & & \\
          effect clausules $oprs$ & $::=$ & . & \\ 
          & $|$ & $\textbf{op} \: l \: x \: k \mapsto c, \: oprs$ & algebraïsche effect clausules \\
           & $|$ & $\textbf{sc} \: l \: x \: p \: k \mapsto c, \: oprs$ & scoped effect clausules \\
        & & & \\
         computaties $c$ & $::=$ & $\textbf{return} \: v$ & return waarde \\
          & $|$ & $\textbf{op} \: l \: v \: (y. \: c)$ & algebraïsch effect \\
          & $|$ & $\textbf{sc} \: l \: v \: (y. \: c_{1}) \: (z. \: c_{2})$ & scoped effect \\
          & $|$ & $v \star c$ & behandeling \\
          & $|$ & $\textbf{do} \: x \leftarrow c_{1}\:; \: c_{2}$ & do clausule \\
          & $|$ & $v_{1} \: v_{2}$ & applicatie \\
          & $|$ & $\textbf{let} \: x = v \: \textbf{in} \: c$ & let \\
         & & & \\
         waarde types $A, \: B, \: M$ & $::=$ & $() \: \: | \: \: (A, \:B) \: \: | \: \: A \rightarrow \underline{C} \: \: | \: \: \underline{C} \Rightarrow \underline{D}$ & \\
         & $|$ & $\alpha$ & type variabele \\
         & $|$ & $\lambda \: \alpha . \: A$ & type operator abstractie \\
         & $|$ & $M \: A$ & type applicatie \\
         type schemas $\sigma$ & $::=$ & $A \: \: | \: \: \forall \: \mu . \: \sigma \: \: | \: \: \forall \: \alpha. \: \sigma $ & \\
         computatie types $\underline{C}, \: \underline{D}$ & $::=$ & $A ! \langle E \rangle $ & \\
         effect type rows $E, \: F$ & $::=$ & $. \: \: | \: \: \mu \: \: | \: \: l; \: E $ & \\
         & & & \\
         kinds $K$ & $::=$ & $* \: \: | \: \: K \rightarrow K$ & \\
         & & & \\
         signatuur contexten $\Sigma$ & $::=$ & $. \: \: | \: \: \Sigma , \: l \: : \: A \rightarrowtriangle B$ & \\
         type contexten $\Gamma$ & $::=$ & $. \: \: | \:\: \Gamma, \: x \: : \: A \: \: | \: \: \Gamma , \: \mu \: \: | \: \: \Gamma, \: \alpha $ & \\
         & & & \\
    \hline
    \end{tabular}
    \caption{Syntaxis voor $\lambda_{sc}$}
    \label{fig:syntaxisScoped}
\end{table}

\subsection{Lopend voorbeeld}
Om de syntaxis en de operationele semantiek van deze calculus te illustreren gebruikt deze sectie een lopend voorbeeld. 
Het lopend voorbeeld, voorgesteld in Eq. \ref{eq:runEx}, is gebaseerd op het \emph{Forwarding} voorbeeld uit \cite{Bosman2022}. In dit voorbeeld komen alle relevante reductieregels aan bod. Het voorbeeld is een programma dat het \textbf{once} effect, dat van een computatie met het \textbf{choose} (non-determinisme) effect enkel het eerste resultaat teruggeeft, combineert met het \textbf{inc} effect, dat een teller bijhoudt. Het \textbf{inc} effect transformeert een computatie in een functie die een staat doorgeeft. Dit voorbeeld is gelijkaardig aan het voorbeeld beschreven in Sectie \ref{subsec:effInter}. Om dit voorbeeld te bespreken is het nodig eerst de syntaxis van de calculus te introduceren.

\begin{equation} \label{eq:runEx}
    h_{once} \star (run_{inc} \: 0 \star c_{fwd})
\end{equation}



\subsection{Syntaxis}
Tabel \ref{fig:syntaxisScoped} beeldt de syntaxis voor de $\lambda_{sc}$-calculus af. De syntaxis onderscheidt visueel de termen in de bovenste helft en de types in de onderste helft van de tabel. De termen zijn gesplitst in waarden $v$ en computaties $c$ waarbij waarden verschillen van computaties in dat de semantiek in Sectie \ref{sec:OpSemScop} enkel reducties op computaties definieert. De volgende paragrafen bespreken de termen in de syntaxis die tot de waarden, de computaties en de types behoren.

\subsubsection{Waarden}
We zien dat de syntaxis vijf soorten waarden heeft. Deze overlopen we kort.
Een waarde is ofwel de \emph{eenheids-waarde} $()$ (unit-waarde), een \emph{paar} van twee waarden $(v_{1}, v_{2})$, een \emph{variabele} $x$, een \emph{lambda functie} $\lambda x.\:c$ of een \emph{handler} $h$. De eerste vier soorten waarden zijn weinig interessant. \newline
De belangrijkste soort waarden in een calculus voor effect handlers zijn de \emph{handlers}. Een handler bestaat uit een \emph{return} clausule, geen tot meerdere \emph{effect} clausules en een \emph{forwarding} clausule. In vergelijking met Eff merken we de toevoeging van de forwarding clausule op die specifiek is voor de scoped effecten. \newline 
De forwarding clausule $\textbf{fwd}\:f\:p\:k \mapsto c_{f}$, die elke handler moet implementeren, zorgt voor expliciete forwarding wanneer de te behandelen scoped effect clausule niet geïmplementeerd wordt door de handler. De computatie $c_{f}$ specifieert hoe de onbekende scoped effect clausule moet aangepast worden en kan hiervoor gebruik maken van $f$, dat het onbekende scoped effect bevat, de computatie in scope $p$ en de resumptie $k$. \newline
De return clausule $\textbf{return}\:x \mapsto c_{r}$ duidt aan dat de behandeling van een \textbf{return} computatie met resultaat x door de handler deze computatie vervangt door de handler-bepaalde computatie $c_{r}$. \newline
Zoals aangehaald bestaat een handler uit geen tot meerdere effect clausules. In het geval van deze kunnen deze effect clausule algebraïsche operaties of scoped operaties zijn, waarbij de scoped operaties aan uitbreiding vormen aan de Eff calculus. Een \emph{algebraïsche} effect clausule ($\textbf{op}\:l\:x\:k \mapsto c$) wordt gekenmerkt door het sleutelwoord \textbf{op} gevolgd door een label $l$, een input parameter $x$ en een resumptie k. $\mapsto c$ duidt aan dat een handler deze clausule verwerkt door de computatie $c$ toe te passen. Een \emph{scoped} effect clausule ($\textbf{sc}\:l\:x\:p\:k \mapsto c$) is gelijkaardig aan een algebraïsche effect clausule met een verschillend sleutelwoord \textbf{sc} en bijkomende een bewerking in scope $p$.

\subsubsection{Computaties}
Deze paragraaf bespreekt de zeven computaties die syntactisch mogelijk zijn in de calculus. De effect operaties en behandeling van computaties zijn hierbij het interessantst voor de effect handler aanpak. \newline
De twee operaties die in de calculus gedefinieerd zijn, zijn de operatie voor het algebraïsch effect en die voor het scoped effect. Een \emph{algebraïsche effect operatie} ($\textbf{op}\:l\:v\:(y.\:c)$) bestaat uit het sleutelwoord \textbf{op}, een label $l$, een input parameter waarde $v$ en een resumptie in de vorm $(y.\:c)$. Een \emph{scoped effect operatie} ($\textbf{sc}\:l\:v\:(y.\:c_{1})\:(z.\:c_{2})$) bestaat uit het sleutelwoord \textbf{sc}, een label $l$, een input parameter waarde $v$, een scoped berekening $(y.\:c_{1})$ en een resumptie $(z.\:c_{2})$. In beide soorten effecten is de resumptie de computatie die gegeven de resulterende waarde van het effect, de rest van het programma bevat. \newline  
De behandeling ($v \star c$) drukt de behandeling van een computatie $c$ door een waarde $v$ door middel van de $\star$-operator. Deze waarde is in de praktijk altijd een handler, anders is het programma niet goed getypeerd. \newline 
Computaties kunnen een waarde teruggeven en in normaalvorm belanden door middel van de \emph{return clausule} ($\textbf{return}\:v$). \newline  
Computaties worden aan elkaar gerijgd doormiddel van do clausules in de vorm $\textbf{do}\:x \leftarrow c_{1};\:c_{2}$ waarbij het resultaat van $c_{1}$ in $c_{2}$ beschikbaar is als $x$. \newline 
De syntax van applicatie in de calculus is door $v_{1}\:v_{2}$. \newline
Let-polymorfisme is beschikbaar in de calculus als $\textbf{let}\ 
 x \  = \  v \  \textbf{in} \  c$. Dit is een uitbreiding op Eff.

\subsubsection{Lopend voorbeeld}
Het lopend voorbeeld (Eq. \ref{eq:runEx}) introduceert de handlers $h_{once}$ en $h_{inc}$. $c_{fwd}$ is de te behandelen computatie en bestaat uit een scoped effect operatie met in de continuatie een algebraïsch effect operatie. De volgende vergelijkingen stellen deze computaties, handlers en operaties voor in de syntaxis van de calculus.

\begin{equation}
    c_{fwd} \: = \: \textbf{sc}\:once\:()\:(\_.\:c_{inc})\:(x.\:\textbf{op}\:inc\:()\:(y.\:\textbf{return}\:(x+y)))
\end{equation}

\begin{equation}
    run_{inc} \:s\:c \equiv \textbf{do}\:c' \leftarrow h_{inc} \star c;\:c'\:s
\end{equation}

\begin{equation}
    \begin{split}
        h_{inc} = \textbf{handler}\: & \{\:\textbf{return}\:x \mapsto \textbf{return}\:(\lambda s.\: \textbf{return}\:(x,\:s)) \\
        & ,\:\textbf{op}\:inc\:\_\:k \mapsto \textbf{return}\:(\lambda s. \: k\:s(s+1)) \\
        & ,\: \textbf{fwd}\:f\:p\:k \mapsto \textbf{return}\:(\lambda s.\:f(\lambda y.\:p\:y\:s,\:\lambda (z,\:s').\: k\:z\:s'))\}
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        h_{once} = \textbf{handler}\: & \{\:\textbf{return}\:x \mapsto \textbf{return}\:[x] \\
        & ,\:\textbf{op}\:choose\:\_\:k \mapsto \textbf{do}\:xs \leftarrow k\:true;\:\textbf{do}\:ys \leftarrow k\:false;\:xs \concat ys \\
        & ,\:\textbf{sc}\:once\:\_\:p\:k \mapsto \textbf{do}\:ts \leftarrow p\:();\:\textbf{do}\:t \leftarrow head \:ts;\:k\:t \\
        & ,\:\textbf{fwd}\:f\:p\:k \mapsto f\:(p,\:(\lambda z.\: concatMap \:z\:k))\}
    \end{split}
\end{equation}
De concatMap functie wordt in dit voorbeeld niet besproken maar wel in de paper over de $\lambda_{sc}$-calculus\cite{Bosman2022}.

\subsubsection{Types}
%TODO: uitbreidingen tov Eff
Analoog aan de termen zijn ook de types opgesplitst in waarde types $A,\:B,\:M$ en computatie types $\underline{C},\:\underline{D}$. \newline
De calculus bevat enkele waarde types die ook terug te vinden zijn in Eff, namelijk een \emph{eenheids-type} $()$, een \emph{paar-type} $(A,\:B)$, een \emph{functie type} $A \rightarrow \underline{C}$ en een \emph{handler type} $\underline{C} \Rightarrow \underline{D}$. Verder is de syntaxis uitgebreid tegenover Eff door toevoeging van een \emph{type variabele} $\alpha$, een \emph{type operator abstractie} $\lambda \: \alpha. \: A$ een een \emph{type applicatie} $M\:A$. \newline 
Een computatie type heeft een enkele vorm ($A!\langle E \rangle$) en bestaat uit een \emph{waarde type} $A$, het \emph{type van de resulterende waarde} van de computatie, en een \emph{effect type} $E$. Het effect type is het type van de effecten die tijdens de computatie kunnen opgeroepen worden. \newline 
Een effect type of \emph{effect row} bestaat uit een mogelijke lege collectie atomische labels $l$, mogelijk met een row-variabele $\mu$ als laatste element. \newline
Deze calculus ondersteunt verder \emph{type schemas} $\sigma$, waarbij applicatie van type variabelen op type schemas een uitbreiding vormt en \emph{kinds} $K$ die ook niet beschikbaar zijn in Eff. De calculus houdt een gespecialiseerde \emph{signatuur context} $\Sigma$ bij om via hun labels de signatuur van gebruikte effecten te typeren. De calculus heeft ook een \emph{type context} die de types van variabelen bijhoudt.

\subsection{Operationele semantiek}
\label{sec:OpSemScop}

\begin{table}
    \centering
    \begin{tabular}{|l|}
        \hline
        % top
        \\
        % header
         \begin{tabular} {l r}
              \begin{tabular}{|l|}
              \hline
                     $c \leadsto c'$ \\
                \hline
              \end{tabular} & Reductie van computaties \\
         \end{tabular} \\
         % rules
          \begin{tabular}{c}
            $\inference{}{(\lambda x.\:c)\:v \leadsto c\:[\:v\:/\:x\:]}[E-AppAbs] \qquad \inference{}{\textbf{let}\:x\: = \: v \: \textbf{in} \:c \leadsto c\:[\:v\:/\:x\:]}[E-Let]$ \\ 
            \\
            $\inference{c_{1} \leadsto c_{1}'}{\textbf{do}\:x \leftarrow c_{1}\:;\:c_{2} \leadsto \textbf{do}\:x \leadsto c_{1}'\:;\:c_{2}}[E-Do] \qquad \inference{}{\textbf{do}\:x \leftarrow \textbf{return}\:v\:;\:c_{2} \leadsto c_{2}\:[\:v\:/\:x\:]}[E-DoRet]$ \\
            \\
            $\inference{}{\textbf{do}\:x \leftarrow \textbf{op}\:l\:v\:(y.\:c_{1})\:;\:c_{2} \leadsto \textbf{op}\:l\:v\:(y.\: \textbf{do} \: x \leftarrow c_{1}\:;\:c_{2})}[E-DoOp]$ \\
            \\
            $\inference{}{\textbf{do}\:x \leftarrow \textbf{sc} \:l\:v\:(y.\:c_{1})\:(z.\:c_{2}) \: ;\: c_{3} \leadsto \textbf{sc} \:l\:v\:(y.\:c_{1})\:(z.\: \textbf{do} \: x \leftarrow c_{2} \: ;\: c_{3})}[E-DoSc]$ \\
            \\
            $\inference{c \leadsto c'}{h \star c \leadsto h \star c'}[E-Hand] \qquad \inference{(\textbf{return}\:x \mapsto c_{r}) \in h}{h \star \textbf{return} \: v \leadsto c_{r} \:[\:v\:/\:x\:]}[E-HandRet]$ \\
            \\
            $\inference{(\textbf{op}\:l\:x\:k \mapsto c) \in h}{h \star \textbf{op}\:l\:v\:(y.\:c_{1}) \leadsto c\:[\:v\:/\:x,\:(\lambda y.\:h \star c_{1}) \: / \: k]}[E-HandOp]$ \\
            \\
            $\inference{(\textbf{op}\:l\:\_\:\_) \notin h}{h \star \textbf{op}\:l\:v\:(y.\:c_{1}) \leadsto \textbf{op}\:l\:v\:(y.\: h \star c_{1})}[E-FwdOp]$ \\
            \\
            $\inference{(\textbf{sc}\:l\:x\:p\:k \mapsto c) \in h}{h \star \textbf{sc}\:l\:v\:(y.\:c_{1})\:(z.\:c_{2}) \leadsto c\:[\:v\:/\:x,\:(\lambda \: y. \: h \star\:c_{1}) \: / \: p, (\lambda z. \: h \star c_{2}) \:/\:k\:]}[E-HandSc]$ \\
            \\
            $\inference{(\textbf{sc}\:l\:\_\:\_\:\_) \notin h \\ (\textbf{fwd}\:f\:p\:k \mapsto c_{f}) \in h \qquad g\:=\:\lambda(p',\:k')\:.\:\textbf{sc}\:l\:v\:(y.\:p'\:y)\:(z.\:k'\:z)}{h \star \textbf{sc}\:l\:v\:(y.\:c_{1})\:(z.\:c_{2}) \leadsto c_{f}\:[\:(\lambda\:y.\:h \star c_{1})\:/\:p,\:(\lambda z.\: h \star c_{2})\:/\:k,\:g\:/\:f]}[E-FwdSc]$\\
          \end{tabular} \\
          % bottom
          \\
        \hline
    \end{tabular}
    \caption{Operationele semantiek van $\lambda_{sc}$}
    \label{fig:semantiekScoped}
\end{table}
Tabel \ref{fig:semantiekScoped} toont de kleine-staps operationele semantiek van de $\lambda_{sc}$-calculus. De relatie $c \leadsto c'$ duidt aan dat $c$ naar $c'$ stapt of reduceert. Dat dit een computatie reductie relatie is, betekent dat de calculus enkel termen die computaties zijn, kan reduceren. \newline
De regels \textbf{E-AppAbs} en \textbf{E-Let} behandelen functie applicatie en let-binding. De andere regels zijn op te delen in twee domeinen: computaties aan elkaar rijgen en computaties behandelen met handlers.
\subsubsection{Computaties aan elkaar rijgen}
Om computaties aan elkaar te rijgen van de vorm $\textbf{do}\:x \leftarrow c_{1}\:;\:c_{2}$ is een onderscheid te maken tussen het geval waarbij \emph{$c_{1}$ een stap kan zetten} naar $c_{1}'$ (\textbf{E-Do}) of waarbij \emph{$c_{1}$ in normale vorm is} (\textbf{return}, \textbf{op \textellipsis}, of \textbf{sc \textellipsis}). \newline 
In het laatste geval, hangt de regel af van de normale vorm die zich presenteert in $c_{1}$. \newline 
In het geval dat de computatie \emph{een resultaat is} met een waarde, $\textbf{do}\:x \leftarrow \textbf{return}\:v\:;\:c_{2}$, wordt $x$ vervangen door $v$ in $c_{2}$ of $\leadsto c_{2}\:[\:v\:/\:x\:]$ (\textbf{E-DoRet}). \newline
Is de computatie \emph{een algebraïsche effect} ($\textbf{do} \  x \leftarrow \textbf{op} \  l \  v \  (y. \  c_{1}) \  ; \  c_{2}$) dan kan de computatie herschreven worden met behulp van de algebraïciteits-eigenschap $\leadsto \textbf{op} \  l \  v \  (y. \   \textbf{do} \   x \leftarrow c_{1} \  ; \  c_{2})$ (\textbf{E-DoOp}). \newline
Bij \emph{een scoped effect} ($\textbf{do}\:x \leftarrow \textbf{sc} \:l\:v\:(y.\:c_{1})\:(z.\:c_{2}) \: ;\: c_{3}$) wordt een generalisatie van de algebraïciteits-eigenschap gebruikt $\leadsto \textbf{sc} \:l\:v\:(y.\:c_{1})\:(z.\: \textbf{do} \: x \leftarrow c_{2} \: ;\: c_{3})$ (\textbf{E-DoSc}).

\subsubsection{Computaties behandelen met handlers}
Om computaties te behandelen met handlers, $h \star c$, is er opnieuw onderscheid te maken tussen het geval waar \emph{$c$ kan reduceren} ($c \leadsto c'$) en waar \emph{$c$ in normale vorm is} (\textbf{return} v, \textbf{op \textellipsis}, \textbf{sc \textellipsis}). \newline 
In het eerste geval wordt de mogelijke stap genomen ($h \star c \leadsto h \star c'$) (\textbf{E-Hand}). In het andere geval wordt de clausule die geldt uit de handler toegepast (\textbf{E-HandRet}, \textbf{E-HandOp}, \textbf{E-FwdOp}, \textbf{E-HandSc}, \textbf{E-FwdSc}).

\subsubsection{Lopend voorbeeld}
% TODO: beter?
Dit deel van het lopend voorbeeld illustreert de toepassing van de inferentie regels uit de operationele semantiek om de reductie van het voorbeeld tot de uiteindelijk resulterende waarde te doen. De uitgelichte stappen gebruiken enkele van de regels die uniek zijn aan deze calculi of meer algemeen calculi van effect handlers. De hele reductie is hier niet gegeven.\newline
Door $run_{inc}$ te substitueren door de definitie herschrijft het voorbeeld zich als:
\begin{equation} 
    h_{once} \star (run_{inc}\:0 \star c_{fwd}) \equiv h_{once} \star (\textbf{do}\:p' \leftarrow h_{inc} \star c_{fwd};\: p'\:0)
\end{equation}
Door vervolgens \textbf{E-FwdSc} te gebruiken, in combinatie met \textbf{E-Hand} en \textbf{E-Do}, reduceert het voorbeeld met de \textbf{fwd} clausule in de \emph{$h_{once}$} handler.
\begin{equation}
    \begin{split}
        \leadsto & \{-\text{E-Hand and E-Do and E-FwdSc}-\} \\
        & h_{once} \star (\textbf{do}\:p' \leftarrow \textbf{return}\:(\lambda c.\:(\lambda (p,\:k).\: \textbf{sc}\:once\:()\:(y.\:p\:y)\:(z.\:k\:z)) \\
        &  \qquad \qquad \qquad \qquad \qquad \qquad (\lambda y. \: (\lambda \_ .\: h_{inc} \star c_{inc})\:y\:c, \\
        & \qquad \qquad \qquad \qquad \qquad \qquad \lambda (z,\:c').\:(\lambda x.\: h_{inc} \star \textbf{op}\:inc\:()\:(y.\:\textbf{return}\:(x+y)))\:z\:c')); \\
        & \qquad \qquad \qquad \qquad \qquad \qquad p'\:0)
    \end{split}
\end{equation}
Verder in de reductie behandelt de $h_{once}$ handler scoped operatie
\begin{equation}
    \begin{split}
        \leadsto* \: h_{once} \star (\textbf{sc}\:once\:()\: & (y.\:(\lambda y.\:(\lambda \_.\:h_{inc} \star c_{inc})\:y\:0)\:y) \\
        & (z.\:(\lambda (z,\:c').\:(\lambda x.\:h_{inc} \star \textbf{op}\:inc\:()\:(y.\:\textbf{return}\:(x+y)))\:z\:c')\:z)) \\
        \leadsto \{- \text{E-HandSc} -\} & \\
        \quad \textbf{do}\:ts \leftarrow (\lambda y.\: h_{once} & \star (\lambda y.\: (\lambda \_.\:h_{inc} \star c_{inc})\:y\:0)\:y)\:(); \\
        \quad \textbf{do}\:t \leftarrow head\:ts; & \\
        \quad (\lambda z.\:h_{once} \star ( \lambda (z, & \:c'). \:(\lambda x.\:h_{inc} \star \textbf{op}\:inc\:()\:(y.\:\textbf{return}\:(x+y)))\:z\:c')\:z)\:t \\
        \leadsto* \: \textbf{return}\:[(1,\:2)]
    \end{split}
\end{equation}

\subsection{Type- en effect-systeem}
De $\lambda_{sc}$-calculus heeft een apart type-systeem voor de termen en de effecten. Het effect-systeem maakt gebruikt van \emph{effect rows} volgens de stijl van Koka\cite{Leijen2017}. De volgende paragrafen behandelen het type-systeem, met in Tabel \ref{fig:typeWaarde} de waarde typering, in Tabel \ref{fig:typeComp} de computatie typering en in Tabel \ref{fig:typeHand} de handler typering.
\subsubsection{Waarde typering}
\begin{table}
    \centering
    \begin{tabular}{|l|}
        \hline
        % top
        \\
        % header
         \begin{tabular} {l r}
              \begin{tabular}{|l|}
              \hline
                     $\Gamma \vdash v\::\:\sigma$ \\
                \hline
              \end{tabular} & Waarde typering \\
         \end{tabular} \\
         % rules
          \begin{tabular}{c}
          \\
            $\inference{(x\::\:\sigma) \in \Gamma}{\Gamma \vdash x\::\:\sigma}[T-Var] \qquad \inference{}{\Gamma \vdash (\:) \::\:(\:)}[T-Unit]$ \\ 
            \\
            $\inference{\Gamma \vdash v_1\::\:A \qquad \Gamma \vdash v_2 \::\:B}{\Gamma \vdash (v_1,\:v_2)\::\:(A,\:B)}[T-Pair]$\\
            \\
            $\inference{\Gamma,\:x\::\:A \vdash c\::\:\underline{C}}{\Gamma \vdash \lambda \: x.\:c\::\:A \rightarrow \underline{C}}[T-Abs] \qquad \inference{\Gamma \vdash v\::\:A \qquad A \equiv B}{\Gamma \vdash v\::\:B}[T-EqV]$\\
            \\
            $\inference{\Gamma \vdash A \::\: * \qquad \Gamma \vdash v\::\: \forall \: \alpha.\:\sigma}{\Gamma \vdash v\::\:\sigma\:[\:A\:/\:\alpha\:]}[T-Inst] \qquad \inference{\Gamma,\:\alpha \vdash v\::\:\sigma \qquad \alpha \notin \Gamma}{\Gamma \vdash v\::\:\forall\:\mu.\:\sigma}[T-Gen]$\\
            \\
            $\inference{\Gamma \vdash v\::\:\forall\:\mu.\:\sigma}{\Gamma \vdash b \::\:\sigma\:[\:E\:/\:\mu\:]}[T-InstEff] \qquad \inference{\Gamma,\:\mu \vdash v\::\:\sigma \qquad \mu \notin \Gamma}{\Gamma \vdash v\::\:\forall \mu.\:\sigma}[T-GenEff]$\\
            \\
          \end{tabular} \\
          % bottom
          \\
        \hline
    \end{tabular}
    \caption{Waarde typering van $\lambda_{sc}$}
    \label{fig:typeWaarde}
\end{table}

Tabel \ref{fig:typeWaarde} toont de waarde typeringsregels voor $\lambda_{sc}$. \newline 
\textbf{T-Var}, \textbf{T-Unit} en \textbf{T-Pair} behandelen de standaard \emph{typering van respectievelijk variabelen, de eenheidswaarde en paren}. \newline
\textbf{T-Abs} is ook relatief standaard en bespreekt de \emph{typering van een abstractie}. \newline
\textbf{T-EqV} beschrijft een \emph{equivalentie-relatie voor waarden}. De volledige type equivalentie is hier achterwege gelaten maar te vinden in de appendix van de originele paper \cite{Bosman2022}. \newline 
De resterende vier type-regels zijn minder standaard en nieuw voor de calculus tegenover Eff. Deze regels bespreken de \emph{instantie en abstractie over respectievelijk type variabelen en row variabelen} (voor effecten).
\textbf{T-Inst} en \textbf{T-InstEff} behandelen daarbij de instantie van respectievelijk type- en row-variabelen. \textbf{T-Gen} en \textbf{T-GenEff} behandelen dan abstractie over respectievelijk type- en row-variabelen.

\subsubsection{Computatie typering}
\begin{table}
    \centering
    \begin{tabular}{|l|}
        \hline
        % top
        \\
        % header
         \begin{tabular} {l r}
              \begin{tabular}{|l|}
              \hline
                     $\Gamma \vdash c\::\:\underline{C}$ \\
                \hline
              \end{tabular} & Computatie typering \\
         \end{tabular} \\
         % rules
          \begin{tabular}{c}
          \\
            $\inference{\Gamma \vdash v_1 \::\:A \rightarrow \underline{C} \qquad \Gamma \vdash v_2 \::\:A}{\Gamma \vdash v_1\:v_2\::\:\underline{C}}[T-App]$ \\
            \\
            $\inference{\Gamma \vdash c_1\::\:A!\langle E \rangle \qquad \Gamma,\:x\::\:A \vdash c_2 \::\:B! \langle E \rangle}{\Gamma \vdash \textbf{do}\:x \leftarrow c_1;c_2\::\:B!\langle E \rangle}[T-Do]$\\
            \\
            $\inference{\Gamma \vdash c\::\:\underline{C} \qquad \underline{C} \equiv \underline{D}}{\Gamma \vdash c\::\:\underline{D}}[T-EqC]$ \\
            \\
            $\inference{\Gamma \vdash v\::\:\sigma \qquad \Gamma,\:x\::\:\sigma \vdash c\::\:\underline{C}}{\Gamma \vdash \textbf{let}\:x = v\:\textbf{in}\:c\::\:\underline{C}}[T-Let]$\\
            \\
            $\inference{\Gamma \vdash v\::\:A}{\Gamma \vdash \textbf{return}\:v\::\:A!\langle E \rangle}[T-Ret]$\\
            \\
            $\inference{\Gamma \vdash v\::\:\forall \:\alpha.\:\alpha!\langle E \rangle \Rightarrow M\:\alpha!\langle F \rangle \qquad \Gamma \vdash c\::\:A!\langle E \rangle}{\Gamma \vdash v \star c\::\:M\:A!\langle F \rangle}[T-Hand]$\\
            \\
            $\inference{(l\::\:A_l \rightarrowtriangle B_l) \in \Sigma \qquad \Gamma \vdash v\::\:A_l \qquad \Gamma,\:y\::\:B_l \vdash c\::\:A!\langle l;E \rangle}{\Gamma \vdash \textbf{op}\:l\:v\:(y.\:c)\::\:A!\langle l;E \rangle}[T-Op]$\\
            \\
            $\inference{(l\::\:A_l \rightarrowtriangle B_l) \in \Sigma \qquad \Gamma \vdash v\::\:A_l \\ \Gamma,\:y\::\:B_l\vdash c_1 \::\: B!\langle l;E \rangle \qquad \Gamma,\:z\::\:B \vdash c_2 \::\:A!\langle l;E \rangle}{\Gamma \vdash \textbf{sc}\:l\:v\:(y.\:c_1)\:(z.\:c_2)\::\:A!\langle l;E \rangle}[T-Sc]$\\
            \\
          \end{tabular} \\
          % bottom
          \\
        \hline
    \end{tabular}
    \caption{Computatie typering van $\lambda_{sc}$}
    \label{fig:typeComp}
\end{table}
Tabel \ref{fig:typeComp} toont de computatie typeringsregels voor $\lambda_{sc}$. \newline
\textbf{T-App, T-Do, T-Ret, T-Let} zijn relatief standaard regels voor respectievelijk \emph{applicatie}, een \emph{\textbf{do} statement}, een \emph{\textbf{return} statement} en \emph{\textbf{let} polymorfisme}. \newline 
Voor de \textbf{T-EqC} regel die \emph{type-equivalentie voor computaties} behandelt geldt dezelfde opmerking als gemaakt voor typering van waarden. \newline
\textbf{T-Hand} typeert de \emph{applicatie van een handler}. De resterende typering voor handlers en bijhorende clausules is gegeven in Tabel \ref{fig:typeHand}. Verschillend aan Eff, typeert $\lambda_{sc}$ hier een polymorfe handler. \newline
\textbf{T-Op} typeert een \emph{algebraïsch effect}. Merk op dat het subscript $l$ hier staat voor de signatuur bekomen door het zoeken naar het label $l$ in de context. \newline
\textbf{T-Sc} typeert een \emph{scoped effect}. Een soortgelijke opmerking als voor algebraïsche effecten geldt hier met het verschil dat de opgevraagde signatuur de signatuur voor de \emph{scoped computatie} is, waardoor het type van de resulterende continuatie door de signatuur onbeschreven is maar de effect rows moeten wel overeenkomen. 

\subsubsection{Handler typering}
\begin{table}
    \centering
    \begin{tabular}{|l|}
        \hline
        % top
        \\
        % header
         \begin{tabular} {l l l r}
              \begin{tabular}{|l|}
              \hline
                     $\Gamma \vdash oprs\::\:\underline{C}$ \\
                \hline
              \end{tabular} & \begin{tabular}{|l|}
              \hline
                     $\Gamma \vdash \textbf{fwd}\:f\:p\:k \mapsto c\::\:\underline{C}$ \\
                \hline
              \end{tabular} & \begin{tabular}{|l|}
              \hline
                     $\Gamma \vdash h\::\:\underline{C} \Rightarrow \underline{D}$ \\
                \hline
              \end{tabular} & Handler typering \\
         \end{tabular} \\
         % rules
          \begin{tabular}{c}
          \\
            $\inference{}{\Gamma \vdash .\::\:\underline{C}}[T-Empty]$ \\ 
            \\
            $\inference{\Gamma \vdash oprs \::\: \underline{C} \qquad (l\::\: A_l \rightarrowtriangle B_l) \in \Sigma \qquad \Gamma,\:x\::\:A_l,\:k\::\:B_l \rightarrow \underline{C} \vdash c \::\: \underline{C}}{\Gamma \vdash \textbf{op}\:l\:x\:k \mapsto c,\:oprs\::\: \underline{C}}[T-OprOp]$\\
            \\
            $\inference{\Gamma \vdash oprs\::\:M\:A!\langle E \rangle \qquad (l\::\:A_l \rightarrowtriangle b_l) \in  \Sigma) \\
            \Gamma, \: \beta ,\:x\::\:A_l , \:p\::\:B_l \rightarrow M\: \beta ! \langle E \rangle ,\:k\::\: \beta \rightarrow M\:A! \langle E \rangle \vdash c \::\: M\:A! \langle E \rangle}{\Gamma \vdash \textbf{sc}\:l\:v\:p\:k \mapsto c,\:oprs\::\:M\:A! \langle E \rangle}[T-OprSc]$\\
            \\
            $\inference{A_p = \alpha \rightarrow M\: \beta ! \langle E \rangle \qquad A_k = \beta \rightarrow M \: A!\langle E \rangle \qquad A_k' = M\: \beta \rightarrow M\:A!\langle E \rangle \\
            \Gamma,\: \alpha,\:\beta,\:p\::\:A_p,\:k\::\:A_k,\:f\::\:(A_p,\:A_k') \rightarrow M\:A!\langle E \rangle \vdash c_f \::\: M\:A!\langle E \rangle}{\Gamma \vdash \textbf{fwd}\:f\:p\:k \mapsto c_f \::\: M\:A!\langle E \rangle}[T-Fwd]$\\
            \\
            $\inference{\langle E \rangle = \langle labels \: (oprs);\:F \rangle \qquad \Gamma, \: \alpha \vdash \textbf{return} \   x \mapsto c_r \::\: M\:\alpha ! \langle F \rangle \\ \Gamma,\:\alpha \vdash oprs\::\: M \: \alpha !\langle F \rangle \qquad \Gamma,\: \alpha \vdash \textbf{fwd}\:f\:p\:k \mapsto c_f\::\:M\:\alpha ! \langle F \rangle}{\Gamma \vdash \textbf{handler}\:\{\:\textbf{return},\:oprs,\:\textbf{fwd}\:\}\::\:\forall\:\alpha.\:\alpha!\langle E \rangle \Rightarrow M\:\alpha ! \langle F \rangle}[T-Handler]$\\
            \\
          \end{tabular} \\
          % bottom
          \\
        \hline
    \end{tabular}
    \caption{Handler typering van $\lambda_{sc}$}
    \label{fig:typeHand}
\end{table}

Tabel \ref{fig:typeHand} toont de typeringsregels voor handlers in $\lambda_{sc}$. In deze typering is onderscheid te maken tussen \emph{operatie clausules}, \emph{forwarding clausules} en \emph{handler} typering. \newline 
De operatie clausules worden geven door \textbf{T-Empty} voor de \emph{lege operatie sequence}, \textbf{T-OprOp} voor een \emph{algebraïsche operatie} en \textbf{T-OprSc} voor een \emph{scoped operatie}. Merk op dat de operaties allemaal in type $\underline{C}$ moeten overeenkomen. \newline
De \emph{forwarding clausule} wordt getypeerd door \textbf{T-Fwd}. \newline
De \emph{handler typering} door \textbf{T-Hand} specifieert dat de handler bestaat uit een \emph{\textbf{return} clausule, geen of meerdere operaties clausules en een forwarding clausule}. 

\subsection{Metatheorie}
De belangrijkste metatheoretische eigenschap van $\lambda_{sc}$-calculus is dat deze \emph{typeveilig} is. Dit wordt aangetoond door een bewijs van \emph{progress} en van \emph{subject reduction of preservation}. Deze bewijzen zijn uitgeschreven in de paper ''A Calculus for Scoped Effects \& Handlers'' \cite{Bosman2022} maar worden hier niet verder besproken maar het is belangrijk in te zien dat de toevoegingen de typeveiligheid niet in gevaar brengen.

\subsection{Observaties over de calculus}
Een typerend kenmerk van de calculus is dat de calculus een \emph{fine-grained call-by-value} evaluatie modelleert. \emph{De strikte scheiding van waarden en computaties en reductie op de computaties} vormt eveneens een significant verschil tegenover formele systemen in andere bronnen zoals Types and Programming Languages\cite{Pierce2002}. \newline
Binnen het effect handler paradigma zijn de grootste veranderingen van de $\lambda_{sc}$-calculus tegenover een calculus voor algebraïsche effecten zoals Eff \cite{Bauer2015} enerzijds de introductie van de \textbf{sc} operatie voor scoped effecten en de syntaxis en semantiek hierrond, inclusief de nood voor niet-generieke forwarding doormiddel van de \textbf{fwd} clausule. Om dit te bereiken is de introductie van let-polymorfisme nodig die de syntactische toevoeging van het \textbf{let} sleutelwoord noodzaakt. Het \textbf{let} sleutelwoord laat toe om polymorfe handlers te introduceren, welke nodig zijn om scoped operaties te typeren, specifiek de scoped computatie binnen de scoped effect clausule.

\section{\texorpdfstring{$\lambda^{p}:$}{} Parallelle algebraïsche effect handlers} \label{hoofdstuk:startpuntParallel}
% TODO: grote en kleine stappen op juiste manier presenteren
Deze sectie presenteert een calculus voor de \emph{parallelle behandeling van algebraïsche effecten}. De calculus hieronder gepresenteerd is een lichte aangepaste versie van de calculus beschreven in "Parallel Algebraic Effect Handlers" \cite{Xie2021}. De aanpassingen aan de calculus zijn bedoeld als \emph{refactoring} zodat de vorm dichter aanleunt bij de vorm van de andere calculi gepresenteerd in deze thesis maar de \emph{functie bewaard blijft} zoals in de paper. Merk op dat de calculus een grote-staps operationele semantiek modelleert in tegenstelling tot de andere calculi in deze thesis en dat de calculus ongetypeerd is.

\subsection{Syntaxis}
\begin{table}
    \centering
    \begin{tabular}{|r c l r|}
    \hline
         & & & \\ 
         waarden $v,\:f,\:n$ & $::=$ & $i \: \: | \: \: x \: \: | \: \: \lambda \:x.\:e \: \:$ & \\
         & $|$ & $\langle v_{0},\: ... , \: v_{n} \rangle \: \: | \: \: \textbf{perform}\:op$ & \\
         & & & \\
         handlers $h$ & $::=$ & $\{ \: \: \textbf{return} \mapsto f_{r}$ & return clausule\\
         & & $, \: \textbf{op} \mapsto f_{p}$ & algebraïsche effect  clausule \\
         & & $, \: \textbf{traverse} \mapsto f_{t} \: \} $ & traverse clausule \\
         & & & \\
         expressies $e$ & $::=$ & $v$ & waarde \\
          & $|$ & $e\:e$ & applicatie \\
          & $|$ & $\textbf{for}\:x\::\:n.\:e$ & for constructie \\
          & $|$ & $\textbf{handle}\:h\:e$ & behandel frame \\
         & & & \\
         evaluatie context $F$ & $::=$ & $. \: \: | \: \: F \: e \: \: | \: \: v\:F$ & parallelle context \\
         $E$ & $::=$ & $. \: \: | \:\: E\:e \: \: | \: \: v\:E \:\: | \:\: \textbf{handle}\:h\:e$ & sequentiële context\\
         & & & \\
    \hline
    \end{tabular}
    \caption{Syntaxis voor $\lambda^{p}$}
    \label{fig:syntaxisPar}
\end{table}

Tabel \ref{fig:syntaxisPar} geeft de syntaxis voor de $\lambda^{p}$-calculus weer. \newline
Waar de $\lambda_{sc}$-calculus de termen verdeelt in waarden en computaties, verdeelt deze calculus de \emph{termen in expressies en handlers}. De verschillen tegenover de eerder besproken calculus zijn dat \emph{waarden expressies zijn} en \emph{handlers niet langer waarden zijn} maar een andere categorie die zich buiten de expressies bevindt. \newline
De \textbf{waarden} zijn ofwel een \emph{literal} ($i$), een \emph{variabele} ($x$), een \emph{lambda functie} ($\lambda\:x.\:e$), een \emph{lijst van waarden} ($\langle v_{0},\: ...,\: v_{n} \rangle$) of een \emph{oproep voor een algebraïsch effect} ($\textbf{perform}\:op$). Voor waarden wordt $v$ gebruikt voor \emph{algemene waarden}, $f$ voor \emph{lambda-functies} en $n$ voor \emph{literals}. \newline 
\textbf{Handlers} hebben steeds 3 clausules, namelijk een \emph{return clausule} ($\textbf{return} \mapsto f_{r}$), een \emph{algebraïsche effect clausule} ($\textbf{op} \mapsto f_{p}$) en een \emph{traverse clausule} ($\textbf{traverse} \mapsto f_{t}$). De \textbf{traverse} clausule is essentieel in de parallelle behandeling. \newline 
\textbf{Computaties} zijn ofwel een \emph{waarde} ($v$), een \emph{applicatie} ($e \  e$), een \emph{for constructie} ($\textbf{for} \  x \ \  n.\  e$) voor parallelle behandeling of een \emph{handle constructie} ($\textbf{handle} \  h  \  e$) voor behandeling van een expressies door een handler. \newline
Opvallend aan de syntaxis van handlers is dat elke handler precies \'{e}\'{e}n clausule heeft van elk type en de clausule hebben geen label.

\subsection{Operationele semantiek}

\begin{table}
    \centering
    \begin{tabular}{|l|}
        \hline
        % top
        \\
        % header
         \begin{tabular} {l r}
              \begin{tabular}{|l|}
              \hline
                     $e \leadsto e'$ \\
                \hline
              \end{tabular} & Reductie van expressies \\
         \end{tabular} \\
         % rules
          \begin{tabular}{c}
            $\inference{}{(\lambda\:x.\:e)\:v \leadsto e\:[\:v\:/\:x\:]}[E-App]$ \\ 
            \\
            $\inference{}{\langle v_{0},\: ... ,\: v_{n} \rangle \: i \leadsto v_{i}}[E-Index]$ \\
            \\
            $\inference{(\textbf{return} \mapsto f_{r}) \in h}{\textbf{handle}\:h\:v \leadsto f_{r}\:v}[E-Return]$ \\
            \\
            $\inference{\textbf{op} \notin bop(E) \wedge (\textbf{op} \mapsto f_{p}) \in h \\ where\:k=\:\lambda\:x.\:\textbf{handle}\:h\:E[x]}{\textbf{handle}\:h\:E[\textbf{perform}\:op\:v] \leadsto f_{p}\:v\:k}[E-Perform]$ \\
            \\
            $\inference{(\textbf{traverse} \mapsto f_{t}) \in h \\
            where\:l\:=\:\textbf{for}\:x\::\:n.\:\textbf{handle}\:h\:e \\
            k\:=\:\lambda\:xs.\:\textbf{handle}\:h\:F[xs]}{\textbf{handle}\:h\:F[\textbf{for}\:x\::\:n.\:e] \leadsto f_{t}\:n\:l\:k}[E-Traverse]$ \\
            \\
            $\inference{e \leadsto e'}{E[e] \mapsto E[e']}[E-Step]$ \\
            \\
            $\inference{\forall \: 0 \: \leq \: i < n. \  e[x\:::=\:i] \mapsto v_{i}}{F[\textbf{for}\:x\::\:n. \  e] \mapsto F[\langle v_{0},\:...,\:v_{n-1}\rangle]}[E-Parallel]$ \\
          \end{tabular} \\
          % bottom
          \\
        \hline
    \end{tabular}
    \caption{Operationele semantiek van $\lambda^{p}$}
    \label{fig:semantiekPar}
\end{table}

De operationele semantiek in deze calculus is afgebeeld in Tabel \ref{fig:semantiekPar}. Merk op dat deze operationele semantiek niet volledig is. Het is \emph{niet mogelijk} om puur op basis van de reductie-regels een expressie te reduceren tot een waarde omdat de calculus geen reducties definieert voor pure expressies. De calculus modelleert een combinatie van fijne stappen met de $\leadsto$ relatie en grote stappen met de $\mapsto$ relatie. \newline 
De regels \textbf{E-App}, \textbf{E-Index} zijn standaard regels voor \emph{applicatie} en \emph{lijst-extractie}. \newline
De \textbf{E-Step} is een \emph{congruentie regel voor evaluatie binnen de sequentiële evaluatie context} ($E$). De evaluatie stap is hier een individuele stap. \newline 
\textbf{E-Return} past de \emph{return clausule} ($(\textbf{return} \mapsto f_{r}) \in h$) in de handler toe wanneer de handler een waarde tegenkomt. \newline
\textbf{E-Perform} past een \emph{algebraïsche operatie clausule} toe wanneer een handler een effect tegenkomt dat in de handler zit ($(\textbf{op} \mapsto f_{p}) \in h$).\newline %TODO: E-Traverse en E-Parallel uitleg 
De meest \emph{essentiële regel voor de werking} van de $\lambda^{p}$-calculus is \textbf{E-Traverse}. Deze regel modelleert het effectvol behandelen door de handler van de \textbf{for}-constructie die geïntroduceerd wordt door de paper. In essentie vervangt deze regel een \textbf{for}-constructie in het programma door een handler-specifieke computatie $f_t$. Deze computatie kan vervolgens geen tot meerdere nieuwe \textbf{for}-constructies introduceren. Bij deze behandeling schuift de handler door in de continuatie en de computatie $f_t$ wat \emph{diepe behandeling} toelaat. \newline
\textbf{E-Parallel} is de regel waarin het parallellisme in de calculus plaatsvindt. De regel evalueert een pure \emph{\textbf{for}-constructie in parallel naar een lijst van waarden.} De computatie $e$ wordt in parallel toegepast voor elke $x$ in $n$. \emph{Merk op dat in deze regel de stap, voor elke i in n, een grote stap ($\mapsto v_i$) is die de expressie in \'e\'en keer naar een waarde evalueert}. Deze regel behandelt de pure \textbf{for} constructie zonder handler erbuit en zou vrij moeten zijn van oproepen naar effecten. \newline

\subsection{Observaties over de calculus}
De $\lambda^p$-calculus modelleert geen volledig uitgewerkte operationele semantiek aangezien stappen voor \emph{pure computatie} ontbreken net zoals regels voor \emph{forwarding} van handlers. De calculus gebruikt $e \leadsto e'$ gebruikt wordt voor zowel individuele stappen als voor een volledige reductie naar een waarde. Het gebruik in \textbf{E-Step} suggereert een individuele stap maar het gebruik \textbf{E-Parallel} suggereert een volledige reductie. \newline
Opvallend is dat de calculus geen type- en effect-systeem modelleert. \newline
De E-Parallel is mogelijk uitdagend te implementeren in een interpreter. Hoe kan de interpreter efficiënt detecteren wanneer geen handlers meer buiten de \textbf{for} constructie resteren?
%Doordat elke handler in de \textbf{E-Traverse} clausule nieuwe \textbf{for} constructies kan introduceren is het nodig om als buitenste handler het programma te evalueren met een handler die de resterende \textbf{for}-constructies puur behandelt. 

\section{Gecombineerde calculus}
% TODO: 
De $\lambda_{sc}$-calculus ondersteunt de sequentiële behandeling van algebraïsche en scoped effecten. De $\lambda^{p}$-calculus ondersteunt de parallelle afhandeling van algebraïsche effecten. Het doel van de masterproef is een gecombineerde calculus te bekomen die de combinatie van beide ondersteunt. Uit dit hoofdstuk blijkt dat er significante verschillen zijn in het ontwerp van beide calculi. \newline 
Hoofdstuk \ref{hoofdstuk:motivatie} bespreekt wat het plan van aanpak is om beide calculi samen te voegen en wat de uitdagingen zijn. De gecombineerde calculus bouwt verder op de $\lambda_{sc}$-calculus en probeert de bevindingen uit de $\lambda^p$-calculus hierin in te passen. \newline
Hoofdstukken \ref{hoofdstuk:syntaxis} en \ref{hoofdstuk:semantiek} behandelen de syntaxis en semantiek voor de gecombineerde calculus $\lambda_{sc}^{p}$. \newline
Hoofdstukken \ref{hoofdstuk:typesysteem} en \ref{hoofdstuk:metatheorie} bespreken vervolgens respectievelijk het type-en-effectsysteem en de metatheorie met een bewijs voor typeveiligheid voor de gecombineerde calculus. Hoofdstuk \ref{hoofdstuk:voorbeelden} behandelt voorbeelden van het gebruik van de gecombineerde calculus.
%Een hoofdstuk behandelt een samenhangend geheel dat min of meer op zichzelf
%staat. Het is dan ook logisch dat het begint met een inleiding, namelijk
%het gedeelte van de tekst dat je nu aan het lezen bent.

%\section{Eerste onderwerp in dit hoofdstuk}
%De inleidende informatie van dit onderwerp.

%\subsection{Een item}
%Een tekst staat nooit alleen. Dit wil zeggen dat er zeker ook referenties
%nodig zijn. Dit kan zowel naar on-line documenten\cite{wiki} als naar
%boeken\cite{pratchett06:_good_omens}.

%\section{Figuren}
%Figuren worden gebruikt om illustraties toe te voegen. Dit is dan ook de
%manier om beeldmateriaal toe te voegen zoals getoond wordt in
%figuur~\ref{fig:logo}.

%\begin{figure}
%  \centering
%  \includegraphics{logokul}
%  \caption{Het KU~Leuven logo.}
%  \label{fig:logo}
%\end{figure}

%\section{Tabellen}
%Tabellen kunnen gebruikt worden om informatie op een overzichtelijke te
%groeperen. Een tabel is echter geen rekenblad! Vergelijk maar eens
%tabel~\ref{tab:verkeerd} en tabel~\ref{tab:juist}. Welke tabel vind jij het
%duidelijkst?

%\begin{table}
%  \centering
%  \begin{tabular}{||l|lr||} \hline
%    gnats     & gram      & \$13.65 \\ \cline{2-3}
%              & each      & .01 \\ \hline
%    gnu       & stuffed   & 92.50 \\ \cline{1-1} \cline{3-3}
%    emu       &           & 33.33 \\ \hline
%    armadillo & frozen    & 8.99 \\ \hline
%  \end{tabular}
%  \caption{Een tabel zoals het niet moet.}
%  \label{tab:verkeerd}
%\end{table}

%\begin{table}
%  \centering
%  \begin{tabular}{@{}llr@{}} \toprule
%    \multicolumn{2}{c}{Item} \\ \cmidrule(r){1-2}
%    Animal    & Description & Price (\$)\\ \midrule
%    Gnat      & per gram    & 13.65 \\
%              & each        & 0.01 \\
%    Gnu       & stuffed     & 92.50 \\
%    Emu       & stuffed     & 33.33 \\
%    Armadillo & frozen      & 8.99 \\ \bottomrule
%  \end{tabular}
%  \caption{Een tabel zoals het beter is.}
%  \label{tab:juist}
%\end{table}

%\section{Lorem ipsum}
%Tenslotte gaan we hier nog wat tekst voorzien zodat er minstens een
%bijkomende bladzijde aangemaakt wordt. Dat geeft de gelegenheid om eens te
%zien hoe de koptekst en de voettekst zich gedragen.

%\subsection{Lorem ipsum dolor sit amet, consectetur adipiscing elit}
%Sed nec tortor id felis tristique sodales. Nulla nec massa eu dui fermentum
%tincidunt. Integer ullamcorper ante eget eros posuere faucibus. Nam id
%ligula ut augue pulvinar vulputate id at purus. Aenean condimentum tortor
%eu mi placerat eget eleifend massa mollis. Nam est mi, sagittis quis
%euismod eget, sagittis in nibh. Proin elit turpis, aliquam et imperdiet
%sed, volutpat eu turpis.

%Pellentesque vel enim tellus, vitae egestas turpis. Praesent malesuada elit
%non nisi sollicitudin non blandit lacus tincidunt. Morbi blandit urna at
%lectus ornare laoreet. Suspendisse turpis diam, lobortis dictum luctus
%quis, commodo at lorem. Integer lacinia convallis ultricies. Sed quis augue
%neque, eu malesuada arcu. Nullam vehicula, purus vitae sagittis pulvinar,
%erat eros semper massa, eu egestas nibh erat quis magna. Cras pellentesque,
%nisl eu dapibus volutpat, urna augue ornare quam, quis egestas lectus nulla
%a lectus.

%Vivamus dictum libero in massa cursus sed vulputate eros imperdiet. Donec
%lacinia, libero ac lobortis egestas, nibh dui ornare arcu, luctus porttitor
%velit massa sit amet quam. Maecenas scelerisque laoreet diam, vitae congue
%quam adipiscing vitae. Aliquam cursus nisl a leo convallis eleifend
%fermentum massa porta. Nunc libero quam, dapibus dapibus molestie sit amet,
%faucibus vel nunc.

%\subsection{Praesent auctor venenatis posuere}
%Sed tellus augue, molestie in pulvinar lacinia, dapibus non ipsum. Fusce
%vitae mi vitae enim ullamcorper hendrerit eu malesuada est. Proin iaculis
%ante sed nibh tincidunt vel interdum libero posuere. Vivamus accumsan metus
%quis felis congue suscipit dapibus enim mattis. Fusce mattis tortor eget
%ipsum interdum sagittis auctor id metus.

%Integer diam lacus, pharetra sit amet tempor et, tristique non lorem.
%Aenean auctor, nisi eu interdum fermentum, lectus massa adipiscing elit,
%sed facilisis orci odio a lectus. Proin mi nibh, tempus quis porta a,
%viverra quis enim. In sollicitudin egestas libero, quis viverra velit
%molestie eget. Nulla rhoncus, dolor a mollis vestibulum, lacus elit semper
%nisi, nec sollicitudin sem urna eu magna. Nunc sed est urna, euismod congue
%mi.

%\subsection{Cras vulputate ultricies venenatis}
%Vivamus eros urna, sodales accumsan semper vel, lobortis sit amet mauris.
%Etiam condimentum eleifend lorem, ullamcorper ornare lectus aliquet vitae.
%Praesent massa enim, interdum sit amet semper et, venenatis ut elit.
%Quisque faucibus, quam ac lacinia imperdiet, nulla neque elementum purus,
%tempus rutrum justo massa porta sapien. Vestibulum ante ipsum primis in
%faucibus orci luctus et ultrices posuere cubilia Curae; Sed ultrices
%interdum mi, et rhoncus sapien rutrum sed.

%Duis elit orci, molestie quis sollicitudin sed, convallis non ante.
%Maecenas tincidunt condimentum justo, et ultricies leo tristique vitae.
%Vestibulum quis quam non lectus dapibus eleifend a vitae nibh. Nam nibh
%justo, pharetra quis iaculis consequat, elementum quis justo. Etiam mollis
%lacinia lacus, nec sollicitudin urna lobortis ac. Nulla facilisi.

%Proin placerat risus eleifend erat ultricies placerat. Etiam rutrum magna
%nec turpis euismod consectetur. Phasellus tortor odio, lacinia imperdiet
%condimentum sed, faucibus commodo erat. Phasellus sed felis id ante
%placerat ultrices. Aenean tempor justo in tortor volutpat eu auctor dolor
%mollis. Aenean sit amet risus urna. Morbi viverra vehicula cursus.

%\subsection{Donec nibh ante, consectetur et posuere id, tempus nec arcu}
%Curabitur a tellus aliquet ipsum pellentesque scelerisque. Etiam congue,
%risus et volutpat rutrum, est purus dapibus leo, non cursus metus felis
%eget ligula. Vivamus facilisis tristique turpis, ut pretium lectus luctus
%eleifend. Fusce magna sapien, ullamcorper vitae fringilla id, euismod quis
%ante.

%Phasellus volutpat, nunc et pharetra semper, sem justo adipiscing mauris,
%id blandit magna quam et orci. Vestibulum a erat purus, ut molestie ante.
%Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere
%cubilia Curae; Proin turpis diam, consequat ut ullamcorper ut, consequat eu
%orci. Sed metus risus, fringilla nec interdum vel, interdum eu nunc.
%Suspendisse vel sapien orci.

%\subsection{Morbi et mauris tempus purus ornare vehicula}
%Mauris sit amet diam quam, eget luctus purus. Sed faucibus, risus semper
%eleifend iaculis, mi turpis bibendum nisl, quis cursus nibh nisl sit amet
%ipsum. Vestibulum tempor urna vitae mi auctor malesuada eget non ligula.
%Nullam convallis, diam vel ultrices auctor, eros eros egestas elit, sed
%accumsan arcu tortor eget leo. Vestibulum orci purus, porttitor in pharetra
%eget, tincidunt eget nisl. Nullam sit amet nulla dui, facilisis vestibulum
%dui.

%Donec faucibus facilisis mauris ac cursus. Duis rhoncus quam sed nisi
%laoreet eu scelerisque massa tincidunt. Vivamus sit amet libero nec arcu
%imperdiet tempor quis non libero. Sed consequat dignissim justo. Phasellus
%ullamcorper, velit quis posuere vulputate, felis erat tincidunt mauris, at
%vestibulum justo lectus et turpis. Maecenas lacinia convallis euismod.
%Quisque egestas fermentum sapien eu dictum. Sed nec lacus in purus dictum
%consequat quis vel nisl. Fusce non urna sem. Curabitur eu diam vitae elit
%accumsan blandit. Nullam fermentum nunc et leo dictum laoreet. Donec semper
%varius velit vel fringilla. Vivamus eu orci nunc.

%\section{Besluit van dit hoofdstuk}
%Als je in dit hoofdstuk tot belangrijke resultaten of besluiten gekomen
%bent, dan is het ook logisch om het hoofdstuk af te ronden met een
%overzicht ervan. Voor hoofdstukken zoals de inleiding en het
%literatuuroverzicht is dit niet strikt nodig.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "masterproef"
%%% End: 
