\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\chapter{Achtergrond}
\label{hoofdstuk:achtergrond}
Het doel van dit hoofdstuk is om de lezer een introductie te bieden aan enkele onderwerpen die essentieel zijn als achtergrondinformatie om de rest van de masterproef te begrijpen.

\section{Effecten en handlers} \label{sec:achtergrondAlgEff}
Effecten en handlers \cite{Bauer2015} zijn een mechanisme om effecten gestructureerd te behandelen in een programmeertaal. Ze stellen de programmeur in staat om de pure, functionele code in een programma te scheiden van de impure, effectvolle code. Dit gebeurt door effect-operaties te introduceren die effectvolle primitieven zijn. Vervolgens definieert de aanpak specifieke functies, effect handlers, voor het afhandelen van de effect-operaties. Effecten en handlers maken het makkelijker over de logica van de code te redeneren en effecten te coderen en te manipuleren op een modulair componeerbare manier, waardoor meer modulaire en herbruikbare programma's kunnen worden gemaakt. Dit is bijzonder interessant in systemen met complexe effecten of systemen waar werken met effecten niet triviaal is zoals gedistribueerde systemen. \newline

Handlers beschrijven de instructies die de machine uitvoert wanneer een effect optreedt in de controlestroom van het programma. Doordat de semantiek van het effect in de handler zit, is er een scheiding tussen het voorkomen van het effect en de afhandeling, wat redeneren over en controleren van de effecten in een programma vergemakkelijkt. \newline

De belangrijkste eigenschap van programmeren met effect handlers is de hoge mate van modulariteit en diversiteit van semantiek die de programmeur kan bereiken met dezelfde bouwstenen. Dit vloeit voort uit overloading van effecten via verschillende handlers, modulaire compositie van effecten en scheiding van syntax en semantiek bij de afhandeling van effecten. Deze eigenschappen maken dit een veelbelovende aanpak voor het programmeren met effecten. 

\section{Algebraïsche operaties}
De algebraïsche effect-operaties of effecten of operaties hebben een type-signatuur $A \rightarrowtriangle B$. Dit duidt aan dat het effect een term van type A omvormt naar type B. Het $choose:() \rightarrowtriangle Bool$ effect is een voorbeeld van een algebraïsch effect dat een eenheids-waarde neemt als input en een boolean waarde teruggeeft. In de voorbeelden in deze thesis is de boolean waarde die het effect teruggeeft willekeurige of niet-deterministisch. Het gemodelleerde effect van \emph{choose} is met andere woorden non-determinisme. De syntaxis voor het choose effect in deze masterproef is als volgt:

\begin{equation}
    \textbf{op} \: choose \: (\:) \: (y. \: c)
\end{equation}

Hier geeft het sleutelwoord \textbf{op} aan dat het om een algebraïsch effect gaat, gevolgd door het label \textit{choose}, gevolgd door de input parameter $(\:)$, gevolgd door de resumptie $(y. \: c)$. De resumptie is de computatie die de rest van het programma bevat gegeven de resulterende waarde van het effect. Een voorbeeld programma, gebaseerd op een gelijkaardig voorbeeld in \cite{Bosman2022}, met het \textit{choose} effect is een programma dat ''pasta'' of ''pizza'' teruggeeft afhankelijk van het resultaat:

\begin{equation}
    c_{ND}\:=\:\textbf{op}\:choose\:()\:(x.\:then\:return\:"pasta"\:else\:return\:"pizza"\:)
\end{equation}

Algebraïsche effecten worden gekenmerkt door de eigenschap dat ze aan elkaar gerijgd kunnen worden door gebruik te maken van de algebraïciteits-eigenschap als volgt:

\begin{equation} \label{eq:algFood}
    \begin{split}
        \textbf{do}\:food \leftarrow \textbf{op}\:choose\:()\:(x. \: if \: x \:then\:return\:"pasta"\:else\:return\:"pizza"\:) \: ; \\ \: \textbf{return}\: "We \: are \: eating \: " \concat  food \concat " \: tonight!"  \leadsto \\
        \textbf{op}\:choose\:()\:(x.\: \textbf{do}\:food \leftarrow  if \: x \:then\:return\:"pasta"\:else\:return\:"pizza"\:; \\ \: \textbf{return} "We \: are \: eating \: " \concat  food \concat " \: tonight!" )
    \end{split}
\end{equation}

Generisch opgesteld, ziet deze eigenschap er zo uit:

\begin{equation}
    \textbf{do}\:x \leftarrow \textbf{op}\:l\:v\:(y.\:c_{1})\:;\:c_{2} \leadsto  \textbf{op}\:l\:v\:(y.\: \textbf{do}\:x \leftarrow c_{1}\:;\:c_{2})
\end{equation}

Het effect van deze eigenschap is enerzijds dat de \textbf{do} clausule wordt doorgeschoven naar de continuatie en anderzijds dat de computatie na de het \textbf{do} statement (de $c_2$ computatie) in de continuatie wordt geduwd.

\section{Algebraïsche effect handlers}
Het voorbeeld-programma $c_{ND}$ uit is niet te evalueren aangezien de operatie nog geen semantiek heeft in dit programma.
De effect handlers geven semantiek aan de algebraïsche operaties door te definiëren hoe de operaties te interpreteren. Effect handlers hebben drie interessante eigenschappen, overloading van effecten, functie compositie en effectinteracties.

\subsection{Overloading van effecten}
Overloading van effecten is simpel te demonstreren door twee verschillende handlers te definiëren en deze hetzelfde programma te laten behandelen. Het resultaat zal in beide gevallen anders zijn, wat aangeeft dat handlers een interessante invloed hebben op de semantiek van het programma. Het onderstaande voorbeeld is gebaseerd op een gelijkaardig voorbeeld in \cite{Bosman2022}. \newline 
De handler $h_{True}$ selecteert de $true$ tak van de computatie voor het \textit{choose} effect:
\begin{equation}
    \begin{split}
        h_{True} = \textbf{handler} \: & \{ \: \textbf{return}\:x \mapsto \textbf{return}\:x \\
         & , \: \textbf{op}\:choose\:\_\:k \mapsto k \: true\}
    \end{split}
\end{equation}
Deze handler toegepast op het programma uit Eq. \ref{eq:algFood} heeft als resultaat
\begin{equation}
    "We\:are\:eating\:pasta\:tonight!"
\end{equation} 
De handler $h_{Max}$ selecteert beide takken en combineert het resultaat:
\begin{equation}
    \begin{split}
        h_{True} = \textbf{handler} \: & \{ \: \textbf{return}\:x \mapsto \textbf{return}\:[x] \\
        & , \: \textbf{op}\:choose\:\_\:k \mapsto \textbf{do}\:t \leftarrow k \: true\;;\: \textbf{do}\:f \leftarrow k\:false\;\:t \concat f \}
    \end{split}
\end{equation}
Deze handler toegepast op het programma uit Eq. \ref{eq:algFood} zal als resultaat
\begin{equation}
    ["We\:are\:eating\:pasta\:tonight!",\:"We\:are\:eating\:pizza\:tonight!"]
\end{equation} 
hebben. Deze twee resultaten zijn een interessante toepassing van overloading van effecten door verschillende handlers te definiëren voor hetzelfde effect.

\subsection{Functie compositie}
\label{subsec:funcComp}
Functie compositie betekent dat het mogelijk moet zijn om programma's te schrijven die verschillende effecten bevatten. De paper "Effect Handlers in Scope"\cite{Wu2014} stelt dat het bij samenstelling van operaties essentieel is dat niet alleen compositie van de syntaxis van effecten maar ook van hun semantiek triviaal is. Een goed voorbeeld hiervan is hoe in een programma met de orthogonale effecten van state en niet-determinisme de semantiek van het programma kan veranderen door de volgorde van de handlers om te wisselen. Voorbeelden voor deze eigenschap zijn moeilijk om duidelijk aan te tonen op een beknopte manier. Het voorbeeld dat hieronder is beschreven is deels overgenomen van \cite{Wu2014} maar niet het hele voorbeeld is weergegeven. Het voorbeeld bestaat uit het knapsack probleem. Dit probleem bestaat uit het vullen (met vervanging) van een rugzak tot een bepaald gewicht, de eerste parameter, gebruikmakend van een lijst van gewichten, de tweede parameter. De output is een lijst van de gebruikte gewichten. In het voorbeeld is \emph{solutions} de handler die alle mogelijke geldige oplossingen teruggeeft als een lijst. \emph{runState} is een handler die een state van het programma kan opvragen en een nieuwe state kan opslaan. Deze twee handlers resulteren in twee mogelijke evaluatie volgorden: 

\begin{equation}
    runLocal = solutions \  . \   runState \   s
\end{equation}

\begin{equation}
    runGlobal = runState \  . \   solutions \   s
\end{equation}

runLocal geeft een lijst van waarden uiteindelijke waarden terug met voor elke een state. runGlobal geeft een lijst van oplossingen met een globale state. Met \emph{choices} een handler die voor elke keuze de state incrementeert krijgen we volgende programma's:

\begin{equation}
    \begin{split}
        (run \  . \   runGlobal \  (0 :: Int) \   choices) \  (knapsack \   3 \  [3,2,1]) \\
        \leadsto (12,[[3],[2,1],[1,2],[1,1,1]])
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        (run \  . \   runLocal \  (0 :: Int) \   choices) \  (knapsack \   3 \ 
  [3,2,1]) \\
        \leadsto [(1,[3]),(5,[2,1]),(5,[1,2]),(9,[1,1,1])]
    \end{split}
\end{equation}


\subsection{Effect-interacties}
\label{subsec:effInter}
Interessante semantiek kan ook bekomen worden door niet-orthogonale effecten te combineren. Dit resulteert in effect-interacties. Deze eigenschap is eveneens moeilijk beknopt te illustrereten. Een voorbeeld van de eigenschap is uitgeschreven in de sectie "Cut and Call" in "Effect Handlers in Scope"\cite{Wu2014} en dit voorbeeld wordt hier beschreven. Om de interactie te beschrijven is het voldoende om het bestaan van een \emph{once} effect te veronderstellen dat de computatie afbreekt bij het vinden van de eerste oplossing. Dit effect heeft duidelijk een interactie met het non-determinisme effect uit de choices handler in het voorbeeld in \ref{subsec:funcComp}. De combinatie van deze twee resulteert in een interactie tussen twee niet-orthogonale effecten. 

\section{Beperkingen algebraïsche effecten en handlers}
Algebraïsche effecten en handlers zijn beperkt in hun vermogen om bepaalde soorten effecten te modelleren. Ze kunnen effecten modelleren zoals onder andere I/O, het veranderen van de staat van variabelen en niet-determinisme. Algebraïsche effecten kunnen echter geen effecten voorstellen die de controlestroom van een programma veranderen, zoals uitzonderingen (geen catch functionaliteit mogelijk). Deze beperking is rechtstreeks terug te brengen naar de syntaxis van de effecten die enkel een parameter en een continuatie hebben. In het geval van een catch functionaliteit is een computatie in scope nodig die als de \emph{try block} van een uitzondering kan gezien worden welke onmogelijk is af te leiden uit enkel de continuatie. Zonder deze try block is het onmogelijk voor de handler om de state van het programma terug te zetten naar de state voor de uitzondering (indien gewenst) om resumptie te doen na de afhandeling (indien gewenst). Buiten catch functionaliteit vereisen andere controlestroom-veranderende effecten ook meer verfijnde mechanismen voor hun behandeling, die buiten de mogelijkheden van algebraïsche effecten vallen. Een categorie van zulke effecten die binnen de scope van deze thesis valt zijn de scoped effecten in Sectie \ref{hoofdstuk:AchteffScope} en de parallelle effecten in Sectie \ref{hoofdstuk:AchteffPar}. Enkele andere categorieën effecten worden besproken in Sectie \ref{subsec:OthCompEff}

\section{Effecten met scope} \label{hoofdstuk:AchteffScope}
Scoped effecten \cite{Bosman2022}, \cite{Wu2014}, \cite{Yang2022}, \cite{Pirog2018} zijn effecten waarbij het gedrag in scope beperkt is tot een deel van de totale berekening. Dit type effect verdeelt het programma in een computatie die binnen het bereik van het effect valt en een deel dat buiten het bereik valt. De $\lambda_{sc}$ calculus \cite{Bosman2022} beschrijft een calculus voor algebraïsche en scoped effecten. De syntaxis en semantiek van deze calculus wordt beschreven in Sectie \ref{hoofdstuk:startpuntScoped}. De syntaxis van scoped operaties ziet er als volgt uit:
\begin{equation}
    \textbf{sc}\:l\:v\:(y.\:c_{1})\:(z.\:c_{2})
\end{equation}

Hier geeft het sleutelwoord \textbf{sc} aan dat het om een scoped effect gaat, gevolgd door een label $l$, een input parameter $v$, een berekening in scope $(y.\:c_{1})$ en een resumptie $(z.\:c_{2})$. Het verschil met de algebraïsche effecten is de toevoeging van een berekening in scope. Deze toevoeging laat de handler toe om de bereking in scope anders te interpreteren dan de resumptie. Door deze toevoeging kan ook geen generieke forwarding van effecten door verschillende handlers meer gebeuren en moet de handler een expliciete forwarding clausule hebben van de volgende vorm:
\begin{equation}
    \textbf{fwd}\:f\:p\:k \mapsto c_{f}
\end{equation}
Sectie \ref{hoofdstuk:startpuntScoped} en \cite{Bosman2022} bespreken deze clausule in meer detail.


\section{Parallelle algebraïsche effecten}
\label{hoofdstuk:AchteffPar}
Effect handlers behandelen effecten standaard sequentieel. De $\lambda^{p}$ calculus \cite{Xie2021} modelleert parallelle afhandeling van algebraïsche effecten. Deze calculus wordt behandeld in Sectie \ref{hoofdstuk:startpuntParallel}. De $\lambda^{p}$-calculus maakt gebruikt van een constructie 
\begin{equation}
    \textbf{for}\:x\::\:n.\:e
\end{equation}

Waarbij \textbf{for} het sleutelwoord is, en de expressie $e$ in parallel wordt uitgevoerd voor elke $x$ in $n$. Gelijkaardig aan de expliciete forwarding clausule voor scoped effecten zoals besproken in Sectie \ref{hoofdstuk:AchteffScope}, heeft deze calculus een \textbf{traverse} clausule in de vorm
\begin{equation}
    \textbf{traverse}\:n\:l\:k
\end{equation}
Deze \textbf{traverse} clausule stelt de handler-specifieke behandeling van de \textbf{for} operatie voor.

\section{Formele systemen of calculi}
\label{subsec:formSysCal}
De meest bekende calculus in deze context is de lambda calculus, ontwikkeld door Alonzo Church\cite{Church1941}. De paper ''A Correspondence between ALGOL 60 and Church's Lambda-Notation'' van Peter Landin \cite{Landin1965} waarin Landin een correspondentie toont tussen de programmeertaal ALGOL 60 en de $\lambda$-calculus illustreert dat zulke formele systemen een modellen kunnen zijn die programmeertalen met bepaalde eigenschappen of mogelijkheden voorstelt. Een calculus stelt een vereenvoudigde versie van een programmeertaal voor in abstracte wiskundige notatie en is een elegante manier om programmeertalen te modelleren. Binnen de formele systemen kunnen ook metatheoretische bewijzen van gewenste eigenschappen geleverd worden. Deze sectie zal een overzicht geven van een simpele calculus, de calculus voor getypeerde arithmetische expressies met als doel de verschillende onderdelen van een calculus uiteen te zetten. De calculus is een licht gemodificeerde versie van de calculus in Hoofdstuk 8 van Types and Programming Languages van Benjamin C. Pierce (TAPL) \cite{Pierce2002}, aangepast om meer in lijn te zijn met de vorm van calculi die verder in de tekst aan bod komen.

\subsection{Termen, waarden, computaties en operaties}
\label{subsec:termWaaComOp}
De kleinste bouwblokken voor programma's in calculi zijn termen. In de syntaxi voorgesteld in deze masterproef zijn de termen opgesplitst in waarden en computaties waarbij een term slechts bij een van beide hoort. Deze aanpak is niet geheel standaard en varieert van de calculi in TAPL die de waarden expliciet scheiden maar verder termen definiëren. Dit verschil is cruciaal in de operationele semantiek aangezien de inferentie-regels in TAPL van term naar term reduceren en in deze thesis van computatie naar computatie zullen reduceren. Een waarde is een term die niet kan evalueren of reduceren. Een computatie is in tegenstelling tot een waarde een term die wel kan evalueren of reduceren. Effect handlers introduceren operaties die in deze context duiden op syntax-constructies die de oproep van een effect symboliseren.

\subsection{Syntaxis}
\begin{table}
    \centering
    \begin{tabular}{|r c l r|}
    \hline 
         numerieke waarde nv & $::=$ & 0 & constante 0 \\
         & $|$ & succ nv & successor waarde \\
         & & & \\
         waarden $v$ & $::=$ & $true$ & constante true \\
         & $|$ & $false$ & constante false \\
         & $|$ & nv & numerieke waarde\\
         & & & \\
         computaties c & $::=$ & return v & return waarde \\
         & $|$ & if c then c else c & conditie\\
         & $|$ & succ c & successor \\
         & $|$ & pred c & predecessor \\
         & $|$ & iszero c & nul test \\
         & & & \\
        types $A$ & $::=$ & Bool & type van booleans \\
        & $|$ & Nat & type van natuurlijke getallen \\
         & & & \\
    \hline
    \end{tabular}
    \caption{Getypeerde arithmetische expressies calculus syntaxis}
    \label{fig:syntaxisSTLC}
\end{table}

De syntaxis geeft een abstract overzicht van de verschillende bouwstenen waaruit een correct programma kan bestaan. Tabel \ref{fig:syntaxisSTLC} geeft de syntaxis voor de pure, simpel getypeerde $\lambda$-calculus. De tabel is opgemaakt in Backus-Naur vorm (BNF) \cite{Backus2003}, een manier om de syntaxis van onder andere programmeertalen te beschrijven. De syntaxis maakt een onderscheid tussen waarden, computaties en types en definieert voor elk van deze welke vormen ze kunnen aannemen. Waarden en computaties hebben types. Zoals besproken in Sectie \ref{subsec:termWaaComOp} is het verschil tussen waarden en computaties dat waarden zich in een irreduceerbare, normaalvorm bevinden en computaties kunnen reduceren. De operationele semantiek legt de regels voor reductie vast.

\subsection{Semantiek}

\begin{table}
    \centering
    \begin{tabular}{|l|}
        \hline
        % top
        \\
        % header
         \begin{tabular} {l r}
              \begin{tabular}{|l|}
              \hline
                     $c \leadsto c'$ \\
                \hline
              \end{tabular} & Computatie reductie \\
         \end{tabular} \\
         % rules
          \begin{tabular}{c}
          \\
            $\inference{}{if \ return \ true \ then \ c_1 \ else \ c_2 \leadsto c_1}[E-IfTrue]$ \\
            \\
            $\inference{}{if \ return \ false \ then \ c_1 \ else \ c_2 \leadsto c_1}[E-IfFalse]$ \\
            \\
            $\inference{c_1 \leadsto c_1'}{if \ c_1 \ then \ c_2 \ else \ c_3 \leadsto if \ c_1' \ then \ c_2 \ else \ c_3}[E-If]$ \\
            \\
            $\inference{c \leadsto c'}{succ \ c \leadsto succ \ c'}[E-Succ]$ \\
            \\
            $\inference{}{succ \ (return \  nv) \leadsto return \ (succ \ nv) }[E-SuccRet]$\\ 
            \\
            $\inference{}{pred \  (return \ 0) \leadsto return \  0}[E-PredZero]$\\
            \\
            $\inference{}{pred \ (return \ (succ \ nv)) \leadsto return \ nv}[E-PredSucc]$\\ \\
            $\inference{c \leadsto c'}{pred \  c \leadsto pred \  c'}[E-Pred]$\\
            \\
            $\inference{}{iszero \ (return \ 0) \leadsto return \ true}[E-IsZeroZero]$\\
            \\
            $\inference{}{iszero \ (return \ (succ \ nv)) \leadsto return \ false}[E-IsZeroSucc]$ \\
            \\
            $\inference{c_1 \leadsto c_1'}{iszero \ c_1 \leadsto iszero \  c_1'}[E-IsZero]$\\
          \end{tabular} \\
          % bottom
          \\
        \hline
    \end{tabular}
    \caption{Operationele semantiek voor getypeerde arithmetische expressies}
    \label{fig:semantiekSTLC}
\end{table}

Tabel \ref{fig:semantiekSTLC} toont de operationele semantiek voor de calculus voor getypeerde arithmetische expressies. Dit zijn semantische regels die gevolgd kunnen worden om berekeningen te reduceren tot normaalvormen. In het geval van deze calculus zijn de normaalvormen return true, return false en return nv. De relatie $c \leadsto c'$ betekent dat de computatie kan reduceren. Het is belangrijk op te merken dat in de context van deze masterproef de operationele semantiek een computatie reductie relatie uitdrukt ($c \leadsto c'$). Dit verschilt van de term reductie relatie ($t \leadsto t'$) die onder andere in de calculi in TAPL beschreven is. Eveneens is het belangrijk aan te geven dat de operationele semantiek in deze thesis indien niet anders aangegeven een \emph{fine-grained call-by-value} semantiek beschrijft. Een reductie volgens een inferentie-regel is de kleinst mogelijk reductie (fine-grained) en zulke reductie zal verder in de tekst naar gerefereerd worden als een stap in de reductie relatie of simpelweg stap.

\subsection{Type-systeem}
%TODO?
\begin{table}
    \centering
    \begin{tabular}{|l|}
        \hline
        % top
        \\
        % header
         \begin{tabular} {l r}
              \begin{tabular}{|l|}
              \hline
                     $\Gamma \vdash v\::\:A$ \\
                \hline
              \end{tabular} & waarde typering \\
         \end{tabular} 
         \\
         % rules
          \begin{tabular}{c}
          \\
            $\inference{}{0 : Nat}[T-Zero]$ \\
            \\
            $\inference{}{true : Bool}[T-True]$ \\
            \\
            $\inference{}{false : Bool}[T-False]$\\
            \end{tabular} \\
            \\
            \begin{tabular} {l r}
              \begin{tabular}{|l|}
              \hline
                     $\Gamma \vdash c\::\:A$ \\
                \hline
              \end{tabular} & computatie typering \\
         \end{tabular} \\
         \\
            \begin{tabular}{c}
            $\inference{v : T}{return \  v : T}[T-Return]$\\
            \\
            $\inference{c_1: Bool \quad c_2: T \quad c_3: T}{if \  c_1 \  then \  c_2 \  else \  c_3 : T}[T-If]$\\
            \\
            $\inference{c : Nat}{succ \  c : Nat}[T-Succ]$\\
            \\
            $\inference{c : Nat}{pred \  c : Nat}[T-Pred]$\\
            \\
            $\inference{c : Nat}{iszero \  c : Bool}[T-IsZero]$\\
          \end{tabular} \\
          % bottom
          \\
        \hline
    \end{tabular}
    \caption{Typesysteem van getypeerde arithmetische expressie calculus}
    \label{tab:semantiekSTLC}
\end{table}

Tabel \ref{tab:semantiekSTLC} toont het typesysteem voor de calculus voor getypeerde arithmetische expressies. Het doel van het typesysteem is om te zorgen dat we een statische check kunnen uitvoeren om na te gaan dat de computaties kan reduceren. Voor deze calculus is het voornamelijk belangrijk dat de conditionele term van een if-statement een boolean is en de succ, pred en iszero functies enkel numerieke waarden als argumenten hebben. Het typesysteem bevat typeregels voor de verschillende mogelijke termen.

\subsection{Metatheorie}
Zoals aangehaald in Sectie \ref{subsec:formSysCal} is het mogelijk bewijzen te leveren voor bepaalde eigenschappen voor formele systemen. Een belangrijke praktische eigenschap voor getypeerde systemen is \emph{safety} of \emph{soundness}.\newline 

Deze eigenschap is bewezen door een bewijs van \emph{progress} en een bewijs van \emph{preservation} of \emph{subject reduction}. Toegepast op de calculus uit het voorbeeld stelt de eigenschap progress dat een goed getypeerde computatie c zich ofwel in een normaalvorm bevindt (in dit geval $c = return \  v$) of er een computatie $c'$ bestaat zodat $c \leadsto c'$. Progress betekent dat een computatie niet kan vastzitten indien ze goed getypeerd is. De eigenschap van preservation stelt dat \emph{als} een goed getypeerde computatie een reductie stap zet dat de resulterende computatie ook goed getypeerd is (met hetzelfde type). \newline 

\subsubsection{Progress}

Dit bewijs voor \emph{progress} voor de calculus is gebaseerd op TAPL 8.3.2 \cite{Pierce2002} en aangepast volgens de aanpassingen aan de calculus in deze sectie. Voor dit bewijs is een canonical forms lemma nodig. Dit lemma is eveneens gebaseerd op TAPL.\newline
\begin{lemma}[Canonical forms]
    \label{lem:CanFormArith}
     \begin{enumerate}
         \item Als v een waarde is van type Bool, dan is v true of false.
         \item Als v een waarde is van type Nat, dan is v een numerieke waarde volgend aan de syntaxis in Figuur \ref{fig:syntaxisSTLC}.
     \end{enumerate}
\end{lemma}
\begin{theorem}[Progress]
Stel dat c een goed getypeerde computatie is (c : T voor een T). Dan is c ofwel in de vorm \textbf{return} v met v een waarde of is er een $c'$ zodat $c \leadsto c'$.
\end{theorem}
\begin{proof}
    Door inductie op de derivatie van c : T. Aangezien c een goed getypeerde computatie is volstaat het om een case-analyse te doen op de mogelijke computatie typeringen. \newline
    \indent \textit{Case} T-Return: c = \textbf{return} v \quad v : T \newline
    Dit geval is onmiddelijk uit het theorema. c is in de vorm \textbf{return} v. \newline 
    \indent \textit{Case} T-If: c = if $c_1$ then $c_2$ else $c_3$ \quad $c_1 : Bool$ \quad $c_2 : T$ \quad $c_3 : T$ \newline
    Volgens de inductie hypothese is $c_1$ ofwel in de vorm \textbf{return} v of is er een $c_1'$ zodat $c_1 \leadsto c_1'$. Als $c_1$ in de vorm \textbf{return} v is, dan heeft v volgens T-Return en het canonical forms lemma de waarde \emph{true} of \emph{false} en is geldt respectievelijk E-IfTrue en E-IfFalse. In het andere geval, als $c_1 \leadsto c_1'$ geldt, dan geldt E-If en $c \leadsto if \  c_1' \  then \  c_2 \  else \  c_3$. \newline
    \indent \textit{Case} T-Succ: c = succ c \quad c : Nat \newline
    Volgens de inductie hypothese is $c_1$ ofwel in de vorm \textbf{return} v of is er een $c_1'$ zodat $c_1 \leadsto c_1'$. Als $c_1$ in de vorm \textbf{return} v is, dan is v volgens T-Return en het canonical forms lemma een numerieke waarde en geldt E-SuccRet. In het andere geval, als $c_1 \leadsto c_1'$ geldt, dan geldt E-Succ en $c \leadsto succ \  c_1'$. \newline
    \indent \textit{Case} T-Pred: c = pred c \quad c : Nat \newline
    Volgens de inductie hypothese is $c_1$ ofwel in de vorm \textbf{return} v of is er een $c_1'$ zodat $c_1 \leadsto c_1'$. Als $c_1$ in de vorm \textbf{return} v is, dan is v volgens T-Return en het canonical forms lemma een numerieke waarde. Hier maken we een onderscheid op de vorm van de numerieke waarde. Als de numerieke waarde 0 is, dan geldt E-PredZero, anders geldt E-PredSucc. In het andere geval, als $c_1 \leadsto c_1'$ geldt, dan geldt E-Pred en $c \leadsto pred \  c_1'$. \newline
    \indent \textit{Case} T-IsZero: c = iszero c \quad c : Nat \newline
    Volgens de inductie hypothese is $c_1$ ofwel in de vorm \textbf{return} v of is er een $c_1'$ zodat $c_1 \leadsto c_1'$. Als $c_1$ in de vorm \textbf{return} v is, dan is v volgens T-Return en het canonical forms lemma een numerieke waarde. Hier maken we een onderscheid op de vorm van de numerieke waarde. Als de numerieke waarde 0 is, dan geldt E-IsZeroZero, anders geldt E-IsZeroSucc. In het andere geval, als $c_1 \leadsto c_1'$ geldt, dan geldt E-IsZero en $c \leadsto iszero \  c_1'$. \newline
\end{proof}

\subsubsection{Preservation}
Dit bewijs voor \emph{preservation} is gebaseerd op TAPL 8.3.3 \cite{Pierce2002} en aangepast volgens de aanpassingen aan de calculus in deze sectie.

\begin{theorem}[Preservation]
Als c : T en $c \leadsto c'$, dan is c' : T.
\end{theorem}

\begin{proof}
    Door inductie op een derivatie van c : T. In elke stap van de inductie nemen we aan dat de gewenste eigenschap geldt voor alle subderivaties en we gaan verder door case analyse uit te voeren op de laatstgebruikte derivatie-regel.\newline
    \indent \textit{Case} T-Return is onmiddelijk aangezien geen $c \leadsto c'$ mogelijk is. \newline
    \indent \textit{Case} T-If: c = if $c_1$ then $c_2$ else $c_3$ \quad $c_1 : Bool$ \quad $c_2 : T$ \quad $c_3 : T$ \newline
    Als de laatste regel T-If is, dan weten we van de vorm van deze regel dat c de vorm \emph{if $c_1$ then $c_2$ else $c_3$} heeft. We hebben nu ook subderivaties met de conclusies  $c_1 : Bool$, $c_2 : T$ en $c_3 : T$. Er zijn drie evaluatie regels mogelijk zodat $c \leadsto c'$: E-IfTrue, E-IfFalse en E-If. We gaan verder met een subcase analyse op deze regels.
    \begin{quote}
        \textit{Subcase} E-IfTrue: $c_1 = \textbf{return} \  true$ \quad $c' = c_2$ \newline
        Als $c \leadsto c'$ bekomen is door E-IfTrue, dan zien we uit deze regel dat $c_1$ \emph{\textbf{return} true} moet zijn en de resulterende computatie $c_2$ is. Dit betekent dat we klaar zijn, aangezien we weten dat $c_2 : T$ en dit is wat we nodig hadden. \newline 
        \textit{Subcase} E-IfFalse: $c_1 = \textbf{return} \   false$ \quad $c' = c_3$ \newline
        Als $c \leadsto c'$ bekomen is door E-IfFalse, dan zien we uit deze regel dat $c_1$ \emph{\textbf{return} false} moet zijn en de resulterende computatie $c_3$ is. Dit betekent dat we klaar zijn, aangezien we weten dat $c_3 : T$ en dit is wat we nodig hadden. \newline
        \textit{Subcase} E-If: $c \leadsto c'$ \quad $c' = if \  c_1' \  then \  c_2 \  else \   c_3$
        Van de assumpties uit het T-If geval, hebben we een subderivatie van de originele type derivatie waarvan de conclusie is dat $c_1 : Bool$. We passen de inductie hypothese toe op deze subderivatie, waardoor we $c_1' : Bool$ krijgen. Dit gecombineerd met $c_2 : T$ en $c_3 : T$ betekent dat we T-If kunnen toepassen om te concluderen dat $if \  c_1' \  then \  c_2 \  else \  c_3 : T$ of dus $c' : T$.
    \end{quote}
    
    \indent \textit{Case} T-Succ: c = succ $c_1$ \quad T : Nat \quad $c_1$ : Nat \newline
    Als de laatste regel T-Succ is, dan weten we van de vorm van deze regel dat c de vorm \emph{succ $c_1$} heeft. We hebben nu ook een subderivatie met de conclusie  $c_1 : Nat$. Er zijn twee evaluatie regels mogelijk zodat $c \leadsto c'$: E-Succ en E-SuccRet. We gaan verder met een subcase analyse op deze regels.
    \begin{quote}
        \textit{Subcase} E-Succ: $c_1 \leadsto c_1'$ \newline
        Als $c \leadsto c'$ bekomen is door E-Succ, dan zien we uit deze regel dat $c_1 \leadsto c_1'$ en aangezien we weten dat $c_1 : Nat$ kunnen we de inductie hypothese toepassen om $c_1' : Nat$ te verkrijgen. Hiermee krijgen we $succ c_1' : Nat$ of dus $c' : Nat$. \newline 
        \textit{Subcase} E-SuccRet: \newline 
        Als $c \leadsto c'$ bekomen is door E-SuccRet, dan weten we aangezien $c_1 : Nat$ door T-Succ dat $succ \   c_1 : Nat$. Door T-Return toe passen krijgen we dan dat $return \  succ \  (\textbf{return} \  nv) : Nat$ of dus $c' : Nat$.
    \end{quote}
        
    \indent \textit{Case} T-Pred: c = pred $c_1$ \quad T : Nat \quad $c_1$ : Nat \newline
    Als de laatste regel T-Pred is, dan weten we van de vorm van deze regel dat c de vorm \emph{pred $c_1$} heeft. We hebben nu ook een subderivatie met de conclusie  $c_1 : Nat$. Er zijn drie evaluatie regels mogelijk zodat $c \leadsto c'$: E-Pred, E-PredZero en E-PredSucc. We gaan verder met een subcase analyse op deze regels.
    \begin{quote}
        \textit{Subcase} E-Pred: $c_1 \leadsto c_1'$ \newline
        Als $c \leadsto c'$ bekomen is door E-Pred, dan zien we uit deze regel dat $c_1 \leadsto c_1'$ en aangezien we weten dat $c_1 : Nat$ kunnen we de inductie hypothese toepassen om $c_1' : Nat$ te verkrijgen. Hiermee krijgen we $pred c_1' : Nat$ of dus $c' : Nat$. \newline 
        \textit{Subcase} E-PredZero: \newline
        Als $c \leadsto c'$ bekomen is door E-PredZero, dan geldt het theorema aangezien $c_1 : Nat$ en $\textbf{return} 0 : Nat$ door T-Return en T-Zero, waardoor $c' : Nat$.
        \textit{Subcase} E-PredSucc: \newline
        Als $c \leadsto c'$ bekomen is door E-PredSucc, dan geldt het theorema aangezien $c_1 : Nat$ en $\textbf{return} nv : Nat$ door het canonical forms Lemma \ref{lem:CanFormArith}, waardoor $c' : Nat$.
    \end{quote}
    \indent \textit{Case} T-IsZero: c = iszero $c_1$ \quad T : Nat \quad $c_1$ : Nat \newline
    Als de laatste regel T-IsZero is, dan weten we van de vorm van deze regel dat c de vorm \emph{iszero $c_1$} heeft. We hebben nu ook een subderivatie met de conclusie  $c_1 : Nat$. Er zijn drie evaluatie regels mogelijk zodat $c \leadsto c'$: E-IsZero, E-IsZeroZero en E-IsZeroSucc. We gaan verder met een subcase analyse op deze regels.
    \begin{quote}
        \textit{Subcase} E-IsZero: $c_1 \leadsto c_1'$ \newline
        Als $c \leadsto c'$ bekomen is door E-IsZero, dan zien we uit deze regel dat $c_1 \leadsto c_1'$ en aangezien we weten dat $c_1 : Nat$ kunnen we de inductie hypothese toepassen om $c_1' : Nat$ te verkrijgen. Hiermee krijgen we $iszero c_1' : Bool$ of dus $c' : Bool$. \newline 
        \textit{Subcase} E-IsZeroZero: \newline
        Als $c \leadsto c'$ bekomen is door E-IsZeroZero, dan geldt het theorema aangezien $\textbf{return} \  0 : Nat$ en $\textbf{return} true : Bool$ door T-Return en T-True, waardoor $c' : Bool$.
        \textit{Subcase} E-IsZeroSucc: \newline
        Als $c \leadsto c'$ bekomen is door E-IsZeroZero, dan geldt het theorema aangezien $\textbf{return} \  succ \  nv : Nat$ en $\textbf{return} false : Bool$ door T-Return en T-False, waardoor $c' : Bool$.
    \end{quote}
\end{proof}


Deze twee bewijzen zijn gegeven enerzijds om de algemene vorm van type-veiligheidsbewijzen te tonen aan de lezer en anderzijds om te bewijzen dat de wijzigingen aangebracht aan de calculus geldig zijn of tenminste de type-veiligheid van de calculus behouden.

\section{Andere computationele effecten}
\label{subsec:OthCompEff}
Deze masterproef focust op de algebraïsche en scoped effecten en de parallelle behandeling van effecten. Dit zijn niet de enige types computationele effecten. Deze sectie bespreekt enkele andere soorten effecten die verder niet behandeld worden in de calculus. 

\subsection{Latente effecten}
Latente effecten \cite{vandenBerg2021} zijn een generieke klasse van effecten waarbij de uitvoer van een computatie uitgesteld wordt. Dit is controle-stroom controlerend mechanisme dat verschilt van de mogelijkheden van algebraïsche en scoped effecten.

\subsection{Asynchrone effecten}
De paper \emph{Asynchronous Effects} \cite{Ahman2020} introduceert een calculus om algebraïsche effecten asynchroon te behandelen.

%Een hoofdstuk behandelt een samenhangend geheel dat min of meer op zichzelf
%staat. Het is dan ook logisch dat het begint met een inleiding, namelijk
%het gedeelte van de tekst dat je nu aan het lezen bent.

%\section{Eerste onderwerp in dit hoofdstuk}
%De inleidende informatie van dit onderwerp.

%\subsection{Een item}
%De bijbehorende tekst. Denk eraan om de paragrafen lang genoeg te maken en
%de zinnen niet te lang.

%Een paragraaf omvat een gedachtengang en bevat dus steeds een paar zinnen.
%Een paragraaf die maar \'e\'en lijn lang is, is dus uit den boze.

%\section{Tweede onderwerp in dit hoofdstuk}
%Er zijn in een hoofdstuk verschillende onderwerpen. We zullen nu
%veronderstellen dat dit het laatste onderwerp is.

%\subsection{Een item}
%Maak ook geen misbruik van opsommingen. Voor korte opsommingen gebruik je
%geen ``\verb|itemize|'' of ``\texttt{enumerate}'' commando's. Doe dus
%\emph{niet} het volgende:
%\begin{quote}
%  De Eiffeltoren bevat drie verdiepingen:
%  \begin{itemize}
%  \item de eerste;
%  \item de tweede;
%  \item de derde.
%  \end{itemize}
%\end{quote}
%Maar doe:
%\begin{quote}
%  De Eiffeltoren bevat drie verdiepingen: de eerste, de tweede en de derde.
%\end{quote}

%\section{Besluit van dit hoofdstuk}
%Als je in dit hoofdstuk tot belangrijke resultaten of besluiten gekomen
%bent, dan is het ook logisch om het hoofdstuk af te ronden met een
%overzicht ervan. Voor hoofdstukken zoals de inleiding en het
%literatuuroverzicht is dit niet strikt nodig.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "masterproef"
%%% End: 
