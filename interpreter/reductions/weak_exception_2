handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do _ <- (op accum "start " (y. Return y)
 in sc for ["1","2","3","4","5"] (x. do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y))) (x. Return x))

1.
{-- E-Hand and E-Hand and E-Hand and E-DoOp --}

handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * op accum "start " (y. do _ <- (Return y
 in sc for ["1","2","3","4","5"] (x. do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y))) (x. Return x)))

2.
{-- E-Hand and E-Hand and E-FwdOp --}

handler{hPureSc} * handler{hAccumSc} * op accum "start " (y. handler{hWeak} * do _ <- (Return y
 in sc for ["1","2","3","4","5"] (x. do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y))) (x. Return x)))

3.
{-- E-Hand and E-HandOp --}

handler{hPureSc} * do k' <- (\ y. handler{hAccumSc} * handler{hWeak} * do _ <- (Return y
 in sc for ["1","2","3","4","5"] (x. do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y))) (x. Return x)) ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

4.
{-- E-Hand and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (handler{hAccumSc} * handler{hWeak} * do _ <- (Return ()
 in sc for ["1","2","3","4","5"] (x. do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y))) (x. Return x))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

5.
{-- E-Hand and E-Do and E-Hand and E-Hand and E-DoRet --}

handler{hPureSc} * do k' <- (handler{hAccumSc} * handler{hWeak} * sc for ["1","2","3","4","5"] (x. do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y))) (x. Return x)
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

6.
{-- E-Hand and E-Do and E-Hand and E-HandSc --}

handler{hPureSc} * do k' <- (handler{hAccumSc} * do results <- (sc for ["1","2","3","4","5"] (y. \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y) (z. Return z)
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

7.
{-- E-Hand and E-Do and E-Hand and E-DoSc --}

handler{hPureSc} * do k' <- (handler{hAccumSc} * sc for ["1","2","3","4","5"] (y. \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y) (z. do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

8.
{-- E-Hand and E-Do and E-HandSc --}

handler{hPureSc} * do k' <- (do pairs <- (sc for ["1","2","3","4","5"] (y. \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y) (z. Return z)
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

9.
{-- E-Hand and E-Do and E-DoSc --}

handler{hPureSc} * do k' <- (sc for ["1","2","3","4","5"] (y. \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y) (z. do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

10.
{-- E-Hand and E-DoSc --}

handler{hPureSc} * sc for ["1","2","3","4","5"] (y. \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y) (z. do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))))

11.
{-- E-HandSc --}

do results <- (Map (["1","2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

12.
{-- E-Do and E-Binop --}

do results <- (do y <- (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y "1"
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

13.
{-- E-Do and E-Do and E-AppAbs --}

do results <- (do y <- (handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y "1"
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

14.
{-- E-Do and E-Do and E-Hand and E-AppAbs --}

do results <- (do y <- (handler{hPureSc} * handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) "1"
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

15.
{-- E-Do and E-Do and E-Hand and E-Hand and E-AppAbs --}

do results <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do eq2 <- (Eq ("1") ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "1" (y. Return y))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

16.
{-- E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-Do and E-Binop --}

do results <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do eq2 <- (Return False
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "1" (y. Return y))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

17.
{-- E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-DoRet --}

do results <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * 
if False
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "1" (y. Return y)
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

18.
{-- E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-IfTrue --}

do results <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * op accum "1" (y. Return y)
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

19.
{-- E-Do and E-Do and E-Hand and E-Hand and E-FwdOp --}

do results <- (do y <- (handler{hPureSc} * handler{hAccumSc} * op accum "1" (y. handler{hWeak} * Return y)
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

20.
{-- E-Do and E-Do and E-Hand and E-HandOp --}

do results <- (do y <- (handler{hPureSc} * do k' <- (\ y. handler{hAccumSc} * handler{hWeak} * Return y ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("1") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

21.
{-- E-Do and E-Do and E-Hand and E-Do and E-AppAbs --}

do results <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * handler{hWeak} * Return ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("1") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

22.
{-- E-Do and E-Do and E-Hand and E-Do and E-Hand and E-HandRet --}

do results <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * Return Right ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("1") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

23.
{-- E-Do and E-Do and E-Hand and E-Do and E-HandRet --}

do results <- (do y <- (handler{hPureSc} * do k' <- (Return ("", Right ())
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("1") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

24.
{-- E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do y <- (handler{hPureSc} * do m' <- (Fst ("", Right ())
 in do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("1") (m')
 in Return (m'', s))))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

25.
{-- E-Do and E-Do and E-Hand and E-Do and E-Unop --}

do results <- (do y <- (handler{hPureSc} * do m' <- (Return ""
 in do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("1") (m')
 in Return (m'', s))))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

26.
{-- E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do y <- (handler{hPureSc} * do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("1") ("")
 in Return (m'', s)))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

27.
{-- E-Do and E-Do and E-Hand and E-Do and E-Unop --}

do results <- (do y <- (handler{hPureSc} * do s <- (Return Right ()
 in do m'' <- (AppendS ("1") ("")
 in Return (m'', s)))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

28.
{-- E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do y <- (handler{hPureSc} * do m'' <- (AppendS ("1") ("")
 in Return (m'', Right ()))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

29.
{-- E-Do and E-Do and E-Hand and E-Do and E-Binop --}

do results <- (do y <- (handler{hPureSc} * do m'' <- (Return "1"
 in Return (m'', Right ()))
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

30.
{-- E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do y <- (handler{hPureSc} * Return ("1", Right ())
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

31.
{-- E-Do and E-Do and E-HandRet --}

do results <- (do y <- (Return ("1", Right ())
 in do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

32.
{-- E-Do and E-DoRet --}

do results <- (do ys' <- (Map (["2","3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

33.
{-- E-Do and E-Do and E-Binop --}

do results <- (do ys' <- (do y <- (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y "2"
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

34.
{-- E-Do and E-Do and E-Do and E-AppAbs --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y "2"
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

35.
{-- E-Do and E-Do and E-Do and E-Hand and E-AppAbs --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) "2"
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

36.
{-- E-Do and E-Do and E-Do and E-Hand and E-Hand and E-AppAbs --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do eq2 <- (Eq ("2") ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "2" (y. Return y))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

37.
{-- E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-Do and E-Binop --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do eq2 <- (Return True
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "2" (y. Return y))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

38.
{-- E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-DoRet --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * 
if True
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "2" (y. Return y)
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

39.
{-- E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-IfTrue --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

40.
{-- E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-DoOp --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * op accum "!" (y. do _ <- (Return y
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y))))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

41.
{-- E-Do and E-Do and E-Do and E-Hand and E-Hand and E-FwdOp --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * op accum "!" (y. handler{hWeak} * do _ <- (Return y
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y))))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

42.
{-- E-Do and E-Do and E-Do and E-Hand and E-HandOp --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (\ y. handler{hAccumSc} * handler{hWeak} * do _ <- (Return y
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y))) ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("!") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

43.
{-- E-Do and E-Do and E-Do and E-Hand and E-Do and E-AppAbs --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * handler{hWeak} * do _ <- (Return ()
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("!") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

44.
{-- E-Do and E-Do and E-Do and E-Hand and E-Do and E-Hand and E-Hand and E-DoRet --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * handler{hWeak} * do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("!") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

45.
{-- E-Do and E-Do and E-Do and E-Hand and E-Do and E-Hand and E-Hand and E-DoOp --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * handler{hWeak} * op throw "error" (y. do _ <- (Return y
 in op accum "unreachable" (y. Return y)))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("!") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

46.
{-- E-Do and E-Do and E-Do and E-Hand and E-Do and E-Hand and E-HandOp --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * Return Left "error"
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("!") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

47.
{-- E-Do and E-Do and E-Do and E-Hand and E-Do and E-HandRet --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (Return ("", Left "error")
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("!") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

48.
{-- E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do m' <- (Fst ("", Left "error")
 in do s <- (Snd ("", Left "error")
 in do m'' <- (AppendS ("!") (m')
 in Return (m'', s))))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

49.
{-- E-Do and E-Do and E-Do and E-Hand and E-Do and E-Unop --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do m' <- (Return ""
 in do s <- (Snd ("", Left "error")
 in do m'' <- (AppendS ("!") (m')
 in Return (m'', s))))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

50.
{-- E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do s <- (Snd ("", Left "error")
 in do m'' <- (AppendS ("!") ("")
 in Return (m'', s)))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

51.
{-- E-Do and E-Do and E-Do and E-Hand and E-Do and E-Unop --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do s <- (Return Left "error"
 in do m'' <- (AppendS ("!") ("")
 in Return (m'', s)))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

52.
{-- E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do m'' <- (AppendS ("!") ("")
 in Return (m'', Left "error"))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

53.
{-- E-Do and E-Do and E-Do and E-Hand and E-Do and E-Binop --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * do m'' <- (Return "!"
 in Return (m'', Left "error"))
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

54.
{-- E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do y <- (handler{hPureSc} * Return ("!", Left "error")
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

55.
{-- E-Do and E-Do and E-Do and E-HandRet --}

do results <- (do ys' <- (do y <- (Return ("!", Left "error")
 in do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

56.
{-- E-Do and E-Do and E-DoRet --}

do results <- (do ys' <- (do ys' <- (Map (["3","4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

57.
{-- E-Do and E-Do and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do y <- (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y "3"
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

58.
{-- E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y "3"
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

59.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) "3"
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

60.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do eq2 <- (Eq ("3") ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "3" (y. Return y))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

61.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do eq2 <- (Return False
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "3" (y. Return y))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

62.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * 
if False
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "3" (y. Return y)
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

63.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-IfTrue --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * op accum "3" (y. Return y)
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

64.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-FwdOp --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * op accum "3" (y. handler{hWeak} * Return y)
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

65.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-HandOp --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (\ y. handler{hAccumSc} * handler{hWeak} * Return y ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("3") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

66.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * handler{hWeak} * Return ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("3") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

67.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Hand and E-HandRet --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * Return Right ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("3") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

68.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-HandRet --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (Return ("", Right ())
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("3") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

69.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m' <- (Fst ("", Right ())
 in do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("3") (m')
 in Return (m'', s))))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

70.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Unop --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m' <- (Return ""
 in do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("3") (m')
 in Return (m'', s))))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

71.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("3") ("")
 in Return (m'', s)))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

72.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Unop --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do s <- (Return Right ()
 in do m'' <- (AppendS ("3") ("")
 in Return (m'', s)))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

73.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m'' <- (AppendS ("3") ("")
 in Return (m'', Right ()))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

74.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m'' <- (Return "3"
 in Return (m'', Right ()))
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

75.
{-- E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * Return ("3", Right ())
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

76.
{-- E-Do and E-Do and E-Do and E-Do and E-HandRet --}

do results <- (do ys' <- (do ys' <- (do y <- (Return ("3", Right ())
 in do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

77.
{-- E-Do and E-Do and E-Do and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (Map (["4","5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

78.
{-- E-Do and E-Do and E-Do and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y "4"
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

79.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y "4"
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

80.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) "4"
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

81.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do eq2 <- (Eq ("4") ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "4" (y. Return y))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

82.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do eq2 <- (Return False
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "4" (y. Return y))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

83.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * 
if False
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "4" (y. Return y)
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

84.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-IfTrue --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * op accum "4" (y. Return y)
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

85.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-FwdOp --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * op accum "4" (y. handler{hWeak} * Return y)
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

86.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-HandOp --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (\ y. handler{hAccumSc} * handler{hWeak} * Return y ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("4") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

87.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * handler{hWeak} * Return ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("4") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

88.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Hand and E-HandRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * Return Right ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("4") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

89.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-HandRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (Return ("", Right ())
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("4") (m')
 in Return (m'', s)))))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

90.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m' <- (Fst ("", Right ())
 in do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("4") (m')
 in Return (m'', s))))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

91.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Unop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m' <- (Return ""
 in do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("4") (m')
 in Return (m'', s))))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

92.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("4") ("")
 in Return (m'', s)))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

93.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Unop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do s <- (Return Right ()
 in do m'' <- (AppendS ("4") ("")
 in Return (m'', s)))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

94.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m'' <- (AppendS ("4") ("")
 in Return (m'', Right ()))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

95.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m'' <- (Return "4"
 in Return (m'', Right ()))
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

96.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * Return ("4", Right ())
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

97.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-HandRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do y <- (Return ("4", Right ())
 in do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

98.
{-- E-Do and E-Do and E-Do and E-Do and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Map (["5"]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

99.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y "5"
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

100.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y "5"
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

101.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) "5"
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

102.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do eq2 <- (Eq ("5") ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "5" (y. Return y))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

103.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * do eq2 <- (Return False
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "5" (y. Return y))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

104.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * 
if False
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum "5" (y. Return y)
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

105.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-Hand and E-IfTrue --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * handler{hWeak} * op accum "5" (y. Return y)
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

106.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Hand and E-FwdOp --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * handler{hAccumSc} * op accum "5" (y. handler{hWeak} * Return y)
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

107.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-HandOp --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (\ y. handler{hAccumSc} * handler{hWeak} * Return y ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("5") (m')
 in Return (m'', s)))))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

108.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-AppAbs --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * handler{hWeak} * Return ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("5") (m')
 in Return (m'', s)))))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

109.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Hand and E-HandRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (handler{hAccumSc} * Return Right ()
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("5") (m')
 in Return (m'', s)))))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

110.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-HandRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do k' <- (Return ("", Right ())
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("5") (m')
 in Return (m'', s)))))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

111.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m' <- (Fst ("", Right ())
 in do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("5") (m')
 in Return (m'', s))))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

112.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Unop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m' <- (Return ""
 in do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("5") (m')
 in Return (m'', s))))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

113.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do s <- (Snd ("", Right ())
 in do m'' <- (AppendS ("5") ("")
 in Return (m'', s)))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

114.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Unop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do s <- (Return Right ()
 in do m'' <- (AppendS ("5") ("")
 in Return (m'', s)))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

115.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m'' <- (AppendS ("5") ("")
 in Return (m'', Right ()))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

116.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * do m'' <- (Return "5"
 in Return (m'', Right ()))
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

117.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Hand and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (handler{hPureSc} * Return ("5", Right ())
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

118.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-HandRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (Return ("5", Right ())
 in do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([y]) (ys)))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

119.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Map ([]) (\ y. handler{hPureSc} * \ y. handler{hAccumSc} * \ x. handler{hWeak} * do eq2 <- (Eq (x) ("2")
 in 
if eq2
 then do _ <- (op accum "!" (y. Return y)
 in do _ <- (op throw "error" (y. Return y)
 in op accum "unreachable" (y. Return y)))
 else op accum x (y. Return y)) y y)
 in Append ([("5", Right ())]) (ys))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

120.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Return []
 in Append ([("5", Right ())]) (ys))
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

121.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Append ([("5", Right ())]) ([])
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

122.
{-- E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Return [("5", Right ())]
 in Append ([("4", Right ())]) (ys))
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

123.
{-- E-Do and E-Do and E-Do and E-Do and E-DoRet --}

do results <- (do ys' <- (do ys' <- (do ys' <- (Append ([("4", Right ())]) ([("5", Right ())])
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

124.
{-- E-Do and E-Do and E-Do and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (do ys' <- (Return [("4", Right ()),("5", Right ())]
 in Append ([("3", Right ())]) (ys))
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

125.
{-- E-Do and E-Do and E-Do and E-DoRet --}

do results <- (do ys' <- (do ys' <- (Append ([("3", Right ())]) ([("4", Right ()),("5", Right ())])
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

126.
{-- E-Do and E-Do and E-Do and E-Binop --}

do results <- (do ys' <- (do ys' <- (Return [("3", Right ()),("4", Right ()),("5", Right ())]
 in Append ([("!", Left "error")]) (ys))
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

127.
{-- E-Do and E-Do and E-DoRet --}

do results <- (do ys' <- (Append ([("!", Left "error")]) ([("3", Right ()),("4", Right ()),("5", Right ())])
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

128.
{-- E-Do and E-Do and E-Binop --}

do results <- (do ys' <- (Return [("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]
 in Append ([("1", Right ())]) (ys))
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

129.
{-- E-Do and E-DoRet --}

do results <- (Append ([("1", Right ())]) ([("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())])
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

130.
{-- E-Do and E-Binop --}

do results <- (Return [("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]
 in \ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) results)

131.
{-- E-DoRet --}

\ z. handler{hPureSc} * do k' <- (do pairs <- (Return z
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))) [("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]

132.
{-- E-AppAbs --}

handler{hPureSc} * do k' <- (do pairs <- (Return [("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]
 in do first <- (Map (pairs) (\ l. Fst l)
 in do second <- (Map (pairs) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

133.
{-- E-Hand and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

134.
{-- E-Hand and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (do y <- (\ l. Fst l ("1", Right ())
 in do ys' <- (Map ([("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

135.
{-- E-Hand and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do first <- (do y <- (Fst ("1", Right ())
 in do ys' <- (Map ([("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

136.
{-- E-Hand and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do first <- (do y <- (Return "1"
 in do ys' <- (Map ([("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

137.
{-- E-Hand and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (Map ([("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

138.
{-- E-Hand and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do y <- (\ l. Fst l ("!", Left "error")
 in do ys' <- (Map ([("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

139.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do y <- (Fst ("!", Left "error")
 in do ys' <- (Map ([("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

140.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do y <- (Return "!"
 in do ys' <- (Map ([("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

141.
{-- E-Hand and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (Map ([("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

142.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do y <- (\ l. Fst l ("3", Right ())
 in do ys' <- (Map ([("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

143.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do y <- (Fst ("3", Right ())
 in do ys' <- (Map ([("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

144.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do y <- (Return "3"
 in do ys' <- (Map ([("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

145.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (Map ([("4", Right ()),("5", Right ())]) (\ l. Fst l)
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

146.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do y <- (\ l. Fst l ("4", Right ())
 in do ys' <- (Map ([("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

147.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do y <- (Fst ("4", Right ())
 in do ys' <- (Map ([("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

148.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do y <- (Return "4"
 in do ys' <- (Map ([("5", Right ())]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

149.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Map ([("5", Right ())]) (\ l. Fst l)
 in Append (["4"]) (ys))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

150.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (\ l. Fst l ("5", Right ())
 in do ys' <- (Map ([]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["4"]) (ys))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

151.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (Fst ("5", Right ())
 in do ys' <- (Map ([]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["4"]) (ys))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

152.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (Return "5"
 in do ys' <- (Map ([]) (\ l. Fst l)
 in Append ([y]) (ys)))
 in Append (["4"]) (ys))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

153.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Map ([]) (\ l. Fst l)
 in Append (["5"]) (ys))
 in Append (["4"]) (ys))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

154.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Return []
 in Append (["5"]) (ys))
 in Append (["4"]) (ys))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

155.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Append (["5"]) ([])
 in Append (["4"]) (ys))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

156.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Return ["5"]
 in Append (["4"]) (ys))
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

157.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (Append (["4"]) (["5"])
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

158.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (do ys' <- (Return ["4","5"]
 in Append (["3"]) (ys))
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

159.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (Append (["3"]) (["4","5"])
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

160.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (do ys' <- (Return ["3","4","5"]
 in Append (["!"]) (ys))
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

161.
{-- E-Hand and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (Append (["!"]) (["3","4","5"])
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

162.
{-- E-Hand and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (do ys' <- (Return ["!","3","4","5"]
 in Append (["1"]) (ys))
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

163.
{-- E-Hand and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do first <- (Append (["1"]) (["!","3","4","5"])
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

164.
{-- E-Hand and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do first <- (Return ["1","!","3","4","5"]
 in do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce first
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

165.
{-- E-Hand and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (Map ([("1", Right ()),("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

166.
{-- E-Hand and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (do y <- (\ l. Snd l ("1", Right ())
 in do ys' <- (Map ([("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

167.
{-- E-Hand and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do second <- (do y <- (Snd ("1", Right ())
 in do ys' <- (Map ([("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

168.
{-- E-Hand and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do second <- (do y <- (Return Right ()
 in do ys' <- (Map ([("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

169.
{-- E-Hand and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (Map ([("!", Left "error"),("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

170.
{-- E-Hand and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do y <- (\ l. Snd l ("!", Left "error")
 in do ys' <- (Map ([("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

171.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do y <- (Snd ("!", Left "error")
 in do ys' <- (Map ([("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

172.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do y <- (Return Left "error"
 in do ys' <- (Map ([("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

173.
{-- E-Hand and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (Map ([("3", Right ()),("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

174.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do y <- (\ l. Snd l ("3", Right ())
 in do ys' <- (Map ([("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

175.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do y <- (Snd ("3", Right ())
 in do ys' <- (Map ([("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

176.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do y <- (Return Right ()
 in do ys' <- (Map ([("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

177.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (Map ([("4", Right ()),("5", Right ())]) (\ l. Snd l)
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

178.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do y <- (\ l. Snd l ("4", Right ())
 in do ys' <- (Map ([("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

179.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do y <- (Snd ("4", Right ())
 in do ys' <- (Map ([("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

180.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do y <- (Return Right ()
 in do ys' <- (Map ([("5", Right ())]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

181.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Map ([("5", Right ())]) (\ l. Snd l)
 in Append ([Right ()]) (ys))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

182.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (\ l. Snd l ("5", Right ())
 in do ys' <- (Map ([]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Right ()]) (ys))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

183.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (Snd ("5", Right ())
 in do ys' <- (Map ([]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Right ()]) (ys))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

184.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do y <- (Return Right ()
 in do ys' <- (Map ([]) (\ l. Snd l)
 in Append ([y]) (ys)))
 in Append ([Right ()]) (ys))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

185.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Map ([]) (\ l. Snd l)
 in Append ([Right ()]) (ys))
 in Append ([Right ()]) (ys))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

186.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Return []
 in Append ([Right ()]) (ys))
 in Append ([Right ()]) (ys))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

187.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Append ([Right ()]) ([])
 in Append ([Right ()]) (ys))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

188.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (do ys' <- (Return [Right ()]
 in Append ([Right ()]) (ys))
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

189.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (Append ([Right ()]) ([Right ()])
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

190.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (do ys' <- (Return [Right (),Right ()]
 in Append ([Right ()]) (ys))
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

191.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (Append ([Right ()]) ([Right (),Right ()])
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

192.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (do ys' <- (Return [Right (),Right (),Right ()]
 in Append ([Left "error"]) (ys))
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

193.
{-- E-Hand and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (Append ([Left "error"]) ([Right (),Right (),Right ()])
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

194.
{-- E-Hand and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (do ys' <- (Return [Left "error",Right (),Right (),Right ()]
 in Append ([Right ()]) (ys))
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

195.
{-- E-Hand and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do second <- (Append ([Right ()]) ([Left "error",Right (),Right (),Right ()])
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

196.
{-- E-Hand and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do second <- (Return [Right (),Left "error",Right (),Right (),Right ()]
 in do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) second
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

197.
{-- E-Hand and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do k' <- (\ z. handler{hAccumSc} * do results <- (Return z
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)) [Right (),Left "error",Right (),Right (),Right ()]
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

198.
{-- E-Hand and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do k' <- (handler{hAccumSc} * do results <- (Return [Right (),Left "error",Right (),Right (),Right ()]
 in do FirstFail <- (FirstFail results
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t))
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

199.
{-- E-Hand and E-Do and E-Do and E-Hand and E-DoRet --}

handler{hPureSc} * do k' <- (do k' <- (handler{hAccumSc} * do FirstFail <- (FirstFail [Right (),Left "error",Right (),Right (),Right ()]
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

200.
{-- E-Hand and E-Do and E-Do and E-Hand and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do k' <- (handler{hAccumSc} * do FirstFail <- (Return Left "error"
 in case FirstFail of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t)
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

201.
{-- E-Hand and E-Do and E-Do and E-Hand and E-DoRet --}

handler{hPureSc} * do k' <- (do k' <- (handler{hAccumSc} * case Left "error" of
 error -> Return Left error 
| t -> \ x. handler{hWeak} * Return x t
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

202.
{-- E-Hand and E-Do and E-Do and E-Hand and E-CaseLeft --}

handler{hPureSc} * do k' <- (do k' <- (handler{hAccumSc} * Return Left "error"
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

203.
{-- E-Hand and E-Do and E-Do and E-HandRet --}

handler{hPureSc} * do k' <- (do k' <- (Return ("", Left "error")
 in letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst k'
 in do k'' <- (Snd k'
 in do res <- (AppendS (base) (rest)
 in Return (res, k''))))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

204.
{-- E-Hand and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (letrec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do rest <- (reduce ["1","!","3","4","5"]
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

205.
{-- E-Hand and E-Do and E-LetRec --}

handler{hPureSc} * do k' <- (do rest <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) ["1","!","3","4","5"]
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

206.
{-- E-Hand and E-Do and E-Do and E-AppRec --}

handler{hPureSc} * do k' <- (do rest <- (\ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))) ["1","!","3","4","5"]
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

207.
{-- E-Hand and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do rest <- (do n <- (Empty ["1","!","3","4","5"]
 in 
if n
 then Return ""
 else do h <- (Head ["1","!","3","4","5"]
 in do t <- (Tail ["1","!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

208.
{-- E-Hand and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do n <- (Return False
 in 
if n
 then Return ""
 else do h <- (Head ["1","!","3","4","5"]
 in do t <- (Tail ["1","!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

209.
{-- E-Hand and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (
if False
 then Return ""
 else do h <- (Head ["1","!","3","4","5"]
 in do t <- (Tail ["1","!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

210.
{-- E-Hand and E-Do and E-Do and E-IfTrue --}

handler{hPureSc} * do k' <- (do rest <- (do h <- (Head ["1","!","3","4","5"]
 in do t <- (Tail ["1","!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

211.
{-- E-Hand and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do h <- (Return "1"
 in do t <- (Tail ["1","!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

212.
{-- E-Hand and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do t <- (Tail ["1","!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS ("1") (y)
 in Return x)))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

213.
{-- E-Hand and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do t <- (Return ["!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS ("1") (y)
 in Return x)))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

214.
{-- E-Hand and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) ["!","3","4","5"]
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

215.
{-- E-Hand and E-Do and E-Do and E-Do and E-AppRec --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (\ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))) ["!","3","4","5"]
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

216.
{-- E-Hand and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do n <- (Empty ["!","3","4","5"]
 in 
if n
 then Return ""
 else do h <- (Head ["!","3","4","5"]
 in do t <- (Tail ["!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

217.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do n <- (Return False
 in 
if n
 then Return ""
 else do h <- (Head ["!","3","4","5"]
 in do t <- (Tail ["!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

218.
{-- E-Hand and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (
if False
 then Return ""
 else do h <- (Head ["!","3","4","5"]
 in do t <- (Tail ["!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

219.
{-- E-Hand and E-Do and E-Do and E-Do and E-IfTrue --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do h <- (Head ["!","3","4","5"]
 in do t <- (Tail ["!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

220.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do h <- (Return "!"
 in do t <- (Tail ["!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

221.
{-- E-Hand and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do t <- (Tail ["!","3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS ("!") (y)
 in Return x)))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

222.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do t <- (Return ["3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS ("!") (y)
 in Return x)))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

223.
{-- E-Hand and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) ["3","4","5"]
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

224.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-AppRec --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (\ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))) ["3","4","5"]
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

225.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do n <- (Empty ["3","4","5"]
 in 
if n
 then Return ""
 else do h <- (Head ["3","4","5"]
 in do t <- (Tail ["3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

226.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do n <- (Return False
 in 
if n
 then Return ""
 else do h <- (Head ["3","4","5"]
 in do t <- (Tail ["3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

227.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (
if False
 then Return ""
 else do h <- (Head ["3","4","5"]
 in do t <- (Tail ["3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

228.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-IfTrue --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do h <- (Head ["3","4","5"]
 in do t <- (Tail ["3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

229.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do h <- (Return "3"
 in do t <- (Tail ["3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

230.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do t <- (Tail ["3","4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS ("3") (y)
 in Return x)))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

231.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do t <- (Return ["4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS ("3") (y)
 in Return x)))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

232.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) ["4","5"]
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

233.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppRec --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (\ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))) ["4","5"]
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

234.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do n <- (Empty ["4","5"]
 in 
if n
 then Return ""
 else do h <- (Head ["4","5"]
 in do t <- (Tail ["4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

235.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do n <- (Return False
 in 
if n
 then Return ""
 else do h <- (Head ["4","5"]
 in do t <- (Tail ["4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

236.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (
if False
 then Return ""
 else do h <- (Head ["4","5"]
 in do t <- (Tail ["4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

237.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-IfTrue --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do h <- (Head ["4","5"]
 in do t <- (Tail ["4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

238.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do h <- (Return "4"
 in do t <- (Tail ["4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

239.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do t <- (Tail ["4","5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS ("4") (y)
 in Return x)))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

240.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do t <- (Return ["5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS ("4") (y)
 in Return x)))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

241.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) ["5"]
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

242.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppRec --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (\ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))) ["5"]
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

243.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do n <- (Empty ["5"]
 in 
if n
 then Return ""
 else do h <- (Head ["5"]
 in do t <- (Tail ["5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

244.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do n <- (Return False
 in 
if n
 then Return ""
 else do h <- (Head ["5"]
 in do t <- (Tail ["5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

245.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (
if False
 then Return ""
 else do h <- (Head ["5"]
 in do t <- (Tail ["5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

246.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-IfTrue --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do h <- (Head ["5"]
 in do t <- (Tail ["5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

247.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do h <- (Return "5"
 in do t <- (Tail ["5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

248.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do t <- (Tail ["5"]
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS ("5") (y)
 in Return x)))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

249.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do t <- (Return []
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS ("5") (y)
 in Return x)))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

250.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) []
 in do x <- (AppendS ("5") (y)
 in Return x))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

251.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppRec --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do y <- (\ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))) []
 in do x <- (AppendS ("5") (y)
 in Return x))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

252.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do y <- (do n <- (Empty []
 in 
if n
 then Return ""
 else do h <- (Head []
 in do t <- (Tail []
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do x <- (AppendS ("5") (y)
 in Return x))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

253.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do y <- (do n <- (Return True
 in 
if n
 then Return ""
 else do h <- (Head []
 in do t <- (Tail []
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x)))))
 in do x <- (AppendS ("5") (y)
 in Return x))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

254.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do y <- (
if True
 then Return ""
 else do h <- (Head []
 in do t <- (Tail []
 in do y <- (rec reduce = \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) in \ l. do n <- (Empty l
 in 
if n
 then Return ""
 else do h <- (Head l
 in do t <- (Tail l
 in do y <- (reduce t
 in do x <- (AppendS (h) (y)
 in Return x))))) t
 in do x <- (AppendS (h) (y)
 in Return x))))
 in do x <- (AppendS ("5") (y)
 in Return x))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

255.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-IfTrue --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do y <- (Return ""
 in do x <- (AppendS ("5") (y)
 in Return x))
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

256.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do x <- (AppendS ("5") ("")
 in Return x)
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

257.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (do x <- (Return "5"
 in Return x)
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

258.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do y <- (Return "5"
 in do x <- (AppendS ("4") (y)
 in Return x))
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

259.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do x <- (AppendS ("4") ("5")
 in Return x)
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

260.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (do x <- (Return "45"
 in Return x)
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

261.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do y <- (Return "45"
 in do x <- (AppendS ("3") (y)
 in Return x))
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

262.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do x <- (AppendS ("3") ("45")
 in Return x)
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

263.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (do x <- (Return "345"
 in Return x)
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

264.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do y <- (Return "345"
 in do x <- (AppendS ("!") (y)
 in Return x))
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

265.
{-- E-Hand and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do x <- (AppendS ("!") ("345")
 in Return x)
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

266.
{-- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (do x <- (Return "!345"
 in Return x)
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

267.
{-- E-Hand and E-Do and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do y <- (Return "!345"
 in do x <- (AppendS ("1") (y)
 in Return x))
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

268.
{-- E-Hand and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (do x <- (AppendS ("1") ("!345")
 in Return x)
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

269.
{-- E-Hand and E-Do and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do rest <- (do x <- (Return "1!345"
 in Return x)
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

270.
{-- E-Hand and E-Do and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do rest <- (Return "1!345"
 in do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) (rest)
 in Return (res, k'')))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

271.
{-- E-Hand and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do base <- (Fst ("", Left "error")
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) ("1!345")
 in Return (res, k''))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

272.
{-- E-Hand and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do base <- (Return ""
 in do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS (base) ("1!345")
 in Return (res, k''))))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

273.
{-- E-Hand and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do k'' <- (Snd ("", Left "error")
 in do res <- (AppendS ("") ("1!345")
 in Return (res, k'')))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

274.
{-- E-Hand and E-Do and E-Do and E-Unop --}

handler{hPureSc} * do k' <- (do k'' <- (Return Left "error"
 in do res <- (AppendS ("") ("1!345")
 in Return (res, k'')))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

275.
{-- E-Hand and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (do res <- (AppendS ("") ("1!345")
 in Return (res, Left "error"))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

276.
{-- E-Hand and E-Do and E-Do and E-Binop --}

handler{hPureSc} * do k' <- (do res <- (Return "1!345"
 in Return (res, Left "error"))
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

277.
{-- E-Hand and E-Do and E-DoRet --}

handler{hPureSc} * do k' <- (Return ("1!345", Left "error")
 in do m' <- (Fst k'
 in do s <- (Snd k'
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s)))))

278.
{-- E-Hand and E-DoRet --}

handler{hPureSc} * do m' <- (Fst ("1!345", Left "error")
 in do s <- (Snd ("1!345", Left "error")
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))

279.
{-- E-Hand and E-Do and E-Unop --}

handler{hPureSc} * do m' <- (Return "1!345"
 in do s <- (Snd ("1!345", Left "error")
 in do m'' <- (AppendS ("start ") (m')
 in Return (m'', s))))

280.
{-- E-Hand and E-DoRet --}

handler{hPureSc} * do s <- (Snd ("1!345", Left "error")
 in do m'' <- (AppendS ("start ") ("1!345")
 in Return (m'', s)))

281.
{-- E-Hand and E-Do and E-Unop --}

handler{hPureSc} * do s <- (Return Left "error"
 in do m'' <- (AppendS ("start ") ("1!345")
 in Return (m'', s)))

282.
{-- E-Hand and E-DoRet --}

handler{hPureSc} * do m'' <- (AppendS ("start ") ("1!345")
 in Return (m'', Left "error"))

283.
{-- E-Hand and E-Do and E-Binop --}

handler{hPureSc} * do m'' <- (Return "start 1!345"
 in Return (m'', Left "error"))

284.
{-- E-Hand and E-DoRet --}

handler{hPureSc} * Return ("start 1!345", Left "error")

285.
{-- E-HandRet --}

Return ("start 1!345", Left "error")

286.
{-- Nothing --}

