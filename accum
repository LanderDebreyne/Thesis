-- Zie reduction



-- sc for l (i. op accum i (x. return x)) (x. return x)

-- hAccum = handler 
--     {
--         return x -> return (0, x)
--         op accum m k -> do  (m', v) <- k ();
--                         do  let r = m' + m in return (r, v)
--         sc for l p k -> do  acc <- sequence (map p l);
--                         let (m, x) = foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) in do  (m', b) <- k x;
--                         return (m + m', b)
--         fwd f p k -> f (p, k) -- ?
--     }

sc for l (i. op accum i (x. x)) (x. return x)

hAccum = handler 
    {
        return x -> return (0, x)
        op accum m k -> do  (m', v) <- k ();
                        do  let r = m' + m in return (r, v)
        sc for l p k -> do  pairs <- applyF l p; -- parallel for
                        do  outs <- applyF fst pairs; -- parallel for 
                        do  m <- reduce <> outs; -- parallel reduce
                        do  (m', b) <- k x
                        do  let r = m' <> m in return (r, b)
        fwd f p k -> f (p, k) -- ?
    }

-- Need parallel operational semantics for parallel computation
applyF :: (ParallellisableFunction (v->pc)) => [v] -> (v->pc) -> [pc] -- runs parallel
reduce :: (ReducingFunction (v->v->v)) => [v] -> (v->v->v) -> v -- runs parallel

cAccum = sc for [1,2,3,12] (i. op accum i (x. return x)) (x. return x) 

hAccum # cAccum

{- E-HandSc -}
let pairs = parFor (i. op accum i (x. return x)) [1,2,3,12] in;
do  outs <- parFor fst pairs; -- parallel for 
do  m <- reduce + outs; -- parallel reduce
do  (m', b) <- (x. return x) x
do  let r = m' + m in return (r, b)

-- Useless?
{- E-ParFor1 -}
let pairs = [op accum 1 (x. return x), op accum 2 (x. return x), op accum 3 (x. return x), op accum 12 (x. return x)] in 
do  outs <- parFor fst pairs; -- parallel for 
do  m <- reduce + outs; -- parallel reduce
do  (m', b) <- (x. return x) x
do  let r = m' + m in return (r, b)

{- E-ParFor2 -}
let pairs = [op accum 1 (x. return x), op accum 2 (x. return x), op accum 3 (x. return x), op accum 12 (x. return x)] in 
do  outs <- parFor fst pairs; -- parallel for 
do  m <- reduce + outs; -- parallel reduce
do  (m', b) <- (x. return x) x
do  let r = m' + m in return (r, b)

{- E-Let -}
let pairs = [1, 2, 3, 12] in 
do  outs <- parFor fst pairs; -- parallel for 
do  m <- reduce + outs; -- parallel reduce
do  (m', b) <- (x. return x) x
do  let r = m' + m in return (r, b)

-- {- E-HandSc -}
-- do  acc <- sequence (map (i. op accum i (x. return x)) [1,2,3,12]);
-- let (m, x) = foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
--     in 
--         do (m', b) <- (x. return x) x;
--         return (m + m', b)

-- {- E-Map -} ?
-- do acc <- sequence ([(i. op accum i (x. return x)) 1, (i. op accum i (x. return x)) 2, (i. op accum i (x. return x)) 3, (i. op accum i (x. return x)) 12]);
-- let (m, x) = foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
--     in 
--         do (m', b) <- (x. return x) x;
--         return (m + m', b)

-- {- E-App-Abs -}
-- do acc <- sequence ([op accum 1 (x. return x), op accum 2 (x. return x), op accum 3 (x. return x), op accum 12 (x. return x)]);
-- let (m, x) = foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
--     in 
--         do (m', b) <- return x;
--         return (m + m', b)

-- {- E-Hand-Op -}
-- do acc <- sequence ([
-- do (m', v) <- (x. return x) ();
-- do let r = m' + 1 in return (r, v),
-- do (m', v) <- (x. return x) ();
-- do let r = m' + 2 in return (r, v),
-- do (m', v) <- (x. return x) ();
-- do let r = m' + 3 in return (r, v),
-- do (m', v) <- (x. return x) ();
-- do let r = m' + 12 in return (r, v)]);
-- let (m, x) = foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
--     in 
--         do (m', b) <- return x;
--         return (m + m', b)

-- {- E-App-Abs -}
-- do acc <- sequence ([
-- do (m', v) <- return ();
-- do let r = m' + 1 in return (r, v),
-- do (m', v) <- return ();
-- do let r = m' + 2 in return (r, v),
-- do (m', v) <- return ();
-- do let r = m' + 3 in return (r, v),
-- do (m', v) <- return ();
-- do let r = m' + 12 in return (r, v)]);
-- let (m, x) = foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
--     in 
--         do (m', b) <- return x;
--         return (m + m', b)

-- {- E-DoRet -}
-- do acc <- sequence ([
-- do let r = 1 in return (r, ()),
-- do let r = 2 in return (r, ()),
-- do let r = 3 in return (r, ()),
-- do let r = 12 in return (r, ())]);
-- let (m, x) = foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
--     in 
--         do (m', b) <- return x;
--         return (m + m', b)

-- {- E-Let -}
-- do acc <- sequence ([
-- return (1, ()),
-- return (2, ()),
-- return (3, ()),
-- return (12, ())]);
-- let (m, x) = foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
--     in 
--         do (m', b) <- return x;
--         return (m + m', b)

-- {- E-Seq -} ? 
-- do acc <- return [(1,()),(2,()),(3,()),(12,())];
-- let (m, x) = foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
--     in 
--         do (m', b) <- return x;
--         return (m + m', b)

-- {- E-DoRet -}
-- let (m, x) = foldr (\n a -> (fst n + fst a, snd a)) (head [(1,()),(2,()),(3,()),(12,())]) (tail [(1,()),(2,()),(3,()),(12,())]) 
--     in 
--         do (m', b) <- return x;
--         return (m + m', b)

-- {- E-FoldR -} -- ?
-- let (m, x) = (18, ())
--     in 
--         do (m', b) <- return x;
--         return (m + m', b)

-- {- E-Let -} 
-- do (m', b) <- return ();
-- return (18 + m', b)

-- {- E-DoRet -}
-- return (18 + 0, ())