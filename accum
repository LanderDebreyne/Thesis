sc for l (i. op accum (Sum l[i]) (x. return x)) (x. return x)

hAccum = handler 
    {
        return x -> return (0, x)
        op accum m k -> do  (m', v) <- k ();
                        do  let r = m' + m in return (r, v)
        sc for l p k -> do  acc <- sequence (map p l);
                        let (m, x) = (foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) in do  (m', b) <- k x;
                        return (m + m', b)
        fwd f p k -> f (p, k) -- ?
    }

cAccum = sc for [1,2,3,12] (i. op accum i (x. return x)) (x. return x) 

hAccum # cAccum

{- E-HandSc -}
do  acc <- sequence (map (i. op accum i (x. return x)) [1,2,3,12]);
let (m, x) = (foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
    in 
        do (m', b) <- (x. return x) x;
        return (m + m', b)

{- E-Map -} ?
do acc <- sequence ([(i. op accum i (x. return x)) 1, (i. op accum i (x. return x)) 2, (i. op accum i (x. return x)) 3, (i. op accum i (x. return x)) 12]);
let (m, x) = (foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
    in 
        do (m', b) <- (x. return x) x;
        return (m + m', b)

{- E-App-Abs -}
do acc <- sequence ([op accum 1 (x. return x), op accum 2 (x. return x), op accum 3 (x. return x), op accum 12 (x. return x)]);
let (m, x) = (foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
    in 
        do (m', b) <- return x;
        return (m + m', b)

{- E-Hand-Op -}
do acc <- sequence ([
do (m', v) <- (x. return x) ();
do let r = m' + 1 in return (r, v),
do (m', v) <- (x. return x) ();
do let r = m' + 2 in return (r, v),
do (m', v) <- (x. return x) ();
do let r = m' + 3 in return (r, v),
do (m', v) <- (x. return x) ();
do let r = m' + 12 in return (r, v)]);
let (m, x) = (foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
    in 
        do (m', b) <- return x;
        return (m + m', b)

{- E-App-Abs -}
do acc <- sequence ([
do (m', v) <- return ();
do let r = m' + 1 in return (r, v),
do (m', v) <- return ();
do let r = m' + 2 in return (r, v),
do (m', v) <- return ();
do let r = m' + 3 in return (r, v),
do (m', v) <- return ();
do let r = m' + 12 in return (r, v)]);
let (m, x) = (foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
    in 
        do (m', b) <- return x;
        return (m + m', b)

{- E-DoRet -}
do acc <- sequence ([
do let r = 1 in return (r, ()),
do let r = 2 in return (r, ()),
do let r = 3 in return (r, ()),
do let r = 12 in return (r, ())]);
let (m, x) = (foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
    in 
        do (m', b) <- return x;
        return (m + m', b)

{- E-Let -}
do acc <- sequence ([
return (1, ()),
return (2, ()),
return (3, ()),
return (12, ())]);
let (m, x) = (foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
    in 
        do (m', b) <- return x;
        return (m + m', b)

{- E-Seq -} ? 
do acc <- return [(1,()),(2,()),(3,()),(12,())];
let (m, x) = (foldr (\n a -> (fst n + fst a, snd a)) (head acc) (tail acc) 
    in 
        do (m', b) <- return x;
        return (m + m', b)

{- E-DoRet -}
let (m, x) = (foldr (\n a -> (fst n + fst a, snd a)) (head [(1,()),(2,()),(3,()),(12,())]) (tail [(1,()),(2,()),(3,()),(12,())]) 
    in 
        do (m', b) <- return x;
        return (m + m', b)

{- E-FoldR -} -- ?
let (m, x) = (18, ())
    in 
        do (m', b) <- return x;
        return (m + m', b)

{- E-Let -} 
do (m', b) <- return ();
return (18 + m', b)

{- E-DoRet -}
return (18 + 0, ())