map 1:2:3:4:5:[] (x. if x == 2 then op throw "error" (x. return x) else op accum x (x. return x)) (x. return x)

hAccum = handler 
    {
        return x -> return ("", x)
        op accum m k -> do (m', v) <- k (); return (m ++ m', v) 
        red l k ->  do first <- map fst l;
                    do second <- map snd l;
                    do (m', b) <- k second;
                    let rec reduce = l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in 
                                    do m <- reduce first;
                                    return (m ++ m', b)
        fwd f p k -> f (p, k) -- TODO
    }


hWeak = handler 
    {
        return x -> return (Right x)
        op throw m _ -> return (Left m)
        red l k ->  do res <- return l;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> k t
        fwd f p k -> f (p, k) -- TODO
    }

firstFailure lst = case map firstError lst of
    Just e  -> Left e
    Nothing -> Right $ fmap (\(Right x) -> x) lst 
  where firstError x = case x of Left e  -> Just e
                                 Right _ -> Nothing


-- parallel implementatie moet mogelijk zijn
-- Bijvoorbeeld door lijst te splitsen over threads en resultaten te reduceren zelfde reducerende functie
-- niet-parallelle implementatie 
reduce :: (ReducingFunction (v->v->v)) => [v] -> (v->v->v) -> v 
let rec reduce = l. f. mempty.
    do n <- null l;
    if n then return mempty else
        do h <- head l;
        do t <- tail l;
        do y <- reduce t f mempty;
        return (f h y) in


hAccum # hWeak # map 1:2:3:4:5:[] (x. if x == 2 then op throw "error" (x. return x) else op accum x (x. return x)) (x. return x)

{- E-Hand and E-HandMap -}
hAccum # map 1:2:3:4:5:[] (x. hWeak # if x == 2 then op throw "error" (x. return x) else op accum x (x. return x)) 
(x. do res <- return x;
case firstFailure res of
    Left err -> return (Left err)
    Right t  -> (x. hWeak # return x) t)

{- E-HandMap -}
map 1:2:3:4:5:[] (x. hAccum # hWeak # if x == 2 then op throw "error" (x. return x) else op accum x (x. return x))
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)

{- E-EffMap -}
par ((x. hAccum # hWeak # if x == 2 then op throw "error" (x. return x) else op accum x (x. return x)) 1):
    ((x. hAccum # hWeak # if x == 2 then op throw "error" (x. return x) else op accum x (x. return x)) 2):
    ((x. hAccum # hWeak # if x == 2 then op throw "error" (x. return x) else op accum x (x. return x)) 3):
    ((x. hAccum # hWeak # if x == 2 then op throw "error" (x. return x) else op accum x (x. return x)) 4):
    ((x. hAccum # hWeak # if x == 2 then op throw "error" (x. return x) else op accum x (x. return x)) 5):[]
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)) 

{- E-Par and [E-AppAbs, E-AppAbs, E-AppAbs, E-AppAbs, E-AppAbs] -}
par (hAccum # hWeak # if 1 == 2 then op throw "error" (x. return x) else op accum 1 (x. return x)):
    (hAccum # hWeak # if 2 == 2 then op throw "error" (x. return x) else op accum 2 (x. return x)):
    (hAccum # hWeak # if 3 == 2 then op throw "error" (x. return x) else op accum 3 (x. return x)):
    (hAccum # hWeak # if 4 == 2 then op throw "error" (x. return x) else op accum 4 (x. return x)):
    (hAccum # hWeak # if 5 == 2 then op throw "error" (x. return x) else op accum 5 (x. return x)):[]
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)) 
 
{- E-Par and [E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-IfTrue, E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-IfFalse] -}
par (hAccum # hWeak # op accum 1 (x. return x)):
    (hAccum # hWeak # op throw "error" (x. return x)):
    (hAccum # hWeak # op accum 3 (x. return x)):
    (hAccum # hWeak # op accum 4 (x. return x)):
    (hAccum # hWeak # op accum 5 (x. return x)):[]
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)) 

{- E-Par and [E-Hand and E-FwdOp, E-Hand and E-HandOp, E-Hand and E-FwdOp, E-Hand and E-FwdOp, E-Hand and E-FwdOp] -}
par (hAccum # op accum 1 (x. hWeak # return x)):
    (hAccum # return (Left "error")):
    (hAccum # op accum 3 (x. hWeak # return x)):
    (hAccum # op accum 4 (x. hWeak # return x)):
    (hAccum # op accum 5 (x. hWeak # return x)):[]
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)) 
 
{- E-Par and [E-HandOp, E-HandRet, E-HandOp, E-HandOp, E-HandOp] -}
par (do (m', v) <- (x. hAccum # hWeak # return x) (); return (m' ++ 1, v)):
    (return ("",Left "error")):
    (do (m', v) <- (x. hAccum # hWeak # return x) (); return (m' ++ 3, v)):
    (do (m', v) <- (x. hAccum # hWeak # return x) (); return (m' ++ 4, v)):
    (do (m', v) <- (x. hAccum # hWeak # return x) (); return (m' ++ 5, v)):[]
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)) 

{- E-Par and [E-Do and E-AppAbs, E-Do and E-AppAbs, E-Do and E-AppAbs, E-Do and E-AppAbs] -}
par (do (m', v) <- hAccum # hWeak # return (); return (m' ++ 1, v)):
    (return ("",Left "error")):
    (do (m', v) <- hAccum # hWeak # return (); return (m' ++ 3, v)):
    (do (m', v) <- hAccum # hWeak # return (); return (m' ++ 4, v)):
    (do (m', v) <- hAccum # hWeak # return (); return (m' ++ 5, v)):[]
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)) 

{- E-Par and [E-Do and E-Hand and E-HandRet, E-Do and E-Hand and E-HandRet, E-Do and E-Hand and E-HandRet, E-Do and E-Hand and E-HandRet] -}
par (do (m', v) <- hAccum # return (Right ()); return (m' ++ 1, v)):
    (return ("",Left "error")):
    (do (m', v) <- hAccum # return (Right ()); return (m' ++ 3, v)):
    (do (m', v) <- hAccum # return (Right ()); return (m' ++ 4, v)):
    (do (m', v) <- hAccum # return (Right ()); return (m' ++ 5, v)):[]
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)) 

{- E-Par and [E-Do and E-HandRet, E-Do and E-HandRet, E-Do and E-HandRet, E-Do and E-HandRet] -}
par (do (m', v) <- return ("", Right ()); return (m' ++ 1, v)):
    (return ("",Left "error")):
    (do (m', v) <- return ("", Right ()); return (m' ++ 3, v)):
    (do (m', v) <- return ("", Right ()); return (m' ++ 4, v)):
    (do (m', v) <- return ("", Right ()); return (m' ++ 5, v)):[]
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b))  

{- E-Par and [E-DoRet, E-DoRet, E-DoRet, E-DoRet] -}
par (return (1, Right ())):
    (return ("",Left "error")):
    (return (3, Right ())):
    (return (4, Right ())):
    (return (5, Right ())):[]
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)) 

{- E-ParNorRet -}
(x. do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)) 

(1, Right ()):
("",Left "error"):
(3, Right ()):
(4, Right ()):
(5, Right ()):[]

{- E-AppAbs -}
do first <- map fst ((1, Right ()):("",Left "error"):(3, Right ()):(4, Right ()):(5, Right ()):[]);
do second <- map snd ((1, Right ()):("",Left "error"):(3, Right ()):(4, Right ()):(5, Right ()):[]);
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)

{- E-Do and E-Map -}
do first <- ((fst (1, Right ())):(fst ("", Left "error")):(fst (3, Right ())):(fst (4, Right ())):(fst (5, Right ())):[]);
do second <- map snd ((1, Right ()):("", Left "error"):(3, Right ()):(4, Right ()):(5, Right ()):[]);
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)

{- E-Do and E-ParList and [E-First, E-First, E-First, E-First, E-First] -}
do first <- ((return 1):(return ""):(return 3):(return 4):(return 5):[]);
do second <- map snd ((1, Right ()):("", Left "error"):(3, Right ()):(4, Right ()):(5, Right ()):[]);
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)

{- E-Do and E-ListRet -}
do first <- return ((1):(""):(3):(4):(5):[]);
do second <- map snd ((1, Right ()):("", Left "error"):(3, Right ()):(4, Right ()):(5, Right ()):[]);
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce first;
                return (m ++ m', b)

{- E-DoRet -}
do second <- map snd ((1, Right ()):("", Left "error"):(3, Right ()):(4, Right ()):(5, Right ()):[]);
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce ((1):(""):(3):(4):(5):[]);
                return (m ++ m', b)

{- E-Do and E-Map -}
do second <- ((snd (1, Right ())):(snd ("", Left "error")):(snd (3, Right ())):(snd (4, Right ())):(snd (5, Right ())):[]);
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce ((1):(""):(3):(4):(5):[]);
                return (m ++ m', b)

{- E-Do and E-ParList and [E-Second, E-Second, E-Second, E-Second, E-Second] -}
do second <- ((return (Right ())):(return (Left "error")):(return (Right ())):(return (Right ())):(return (Right ())):[]);
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce ((1):(""):(3):(4):(5):[]);
                return (m ++ m', b)

{- E-Do and E-ListRet -}
do second <- return ((Right ()):((Left "error")):((Right ())):((Right ())):((Right ())):[]);
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) second
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce ((1):(""):(3):(4):(5):[]);
                return (m ++ m', b)

{- E-DoRet -}
do (m', b) <- (x. hAccum # do res <- return x;
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) ((Right ()):((Left "error")):((Right ())):((Right ())):((Right ())):[])
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce ((1):(""):(3):(4):(5):[]);
                return (m ++ m', b)

{- E-Do and E-AppAbs -}
do (m', b) <- (hAccum # do res <- return ((Right ()):((Left "error")):((Right ())):((Right ())):((Right ())):[]);
    case firstFailure res of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # return x) t) 
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce ((1):(""):(3):(4):(5):[]);
                return (m ++ m', b)

{- E-Do and E-Hand and E-DoRet -}
do (m', b) <- (hAccum # case firstFailure ((Right ()):((Left "error")):((Right ())):((Right ())):((Right ())):[]) of
                            Left err -> return (Left err)
                            Right t  -> (x. hWeak # return x) t) 
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce ((1):(""):(3):(4):(5):[]);
                return (m ++ m', b)

-- TODO
{- E-Do and E-CaseFirstFailLeft -}
do (m', b) <- hAccum # return (Left "error")
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce ((1):(""):(3):(4):(5):[]);
                return (m ++ m', b)

{- E-Do and E-HandRet -}
do (m', b) <- return ("", Left "error")
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce ((1):(""):(3):(4):(5):[]);
                return (m ++ m', b)

{- E-DoRet -}
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return []
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h ++ y) in 
                do m <- reduce ((1):(""):(3):(4):(5):[]);
                return (m ++ "", Left "error")

{- E-LetRec -}
 do m <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return []
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h ++ y) in l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y)) ((1):(""):(3):(4):(5):[]);
return (m ++ "", Left "error")

{- E-Do and E-LetRec -}
 do m <- (l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return []
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h ++ y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) t;
                return (h ++ y)) ((1):(""):(3):(4):(5):[]);
return (m ++ "", Left "error")

{- E-Do and E-AppAbs -}
 do m <- do n <- null ((1):(""):(3):(4):(5):[]);
        if n
            then 
                return []
            else
                do h <- head ((1):(""):(3):(4):(5):[]);
                do t <- tail ((1):(""):(3):(4):(5):[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return []
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h ++ y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) t;
                return (h ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-NullFalse -}
 do m <- do n <- return False;
        if n
            then 
                return []
            else
                do h <- head ((1):(""):(3):(4):(5):[]);
                do t <- tail ((1):(""):(3):(4):(5):[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return []
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h ++ y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) t;
                return (h ++ y);
return (m ++ "", Left "error")

{- E-Do and E-DoRet -}
 do m <- if False
            then 
                return []
            else
                do h <- head ((1):(""):(3):(4):(5):[]);
                do t <- tail ((1):(""):(3):(4):(5):[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return []
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h ++ y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) t;
                return (h ++ y);
return (m ++ "", Left "error")

{- E-Do and E-IfFalse -}
 do m <- do h <- head ((1):(""):(3):(4):(5):[]);
        do t <- tail ((1):(""):(3):(4):(5):[]);
        do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return []
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h ++ y) in l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y)) t;
        return (h ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Head -}
 do m <- do h <- return 1;
        do t <- tail ((1):(""):(3):(4):(5):[]);
        do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return []
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h ++ y) in l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y)) t;
        return (h ++ y);
return (m ++ "", Left "error")

{- E-Do and E-DoRet -}
 do m <- do t <- tail ((1):(""):(3):(4):(5):[]);
        do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return []
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h ++ y) in l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y)) t;
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Tail -}
 do m <- do t <- return ((""):(3):(4):(5):[]);
        do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return []
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h ++ y) in l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y)) t;
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-DoRet -}
 do m <- do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return []
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h ++ y) in l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y)) ((""):(3):(4):(5):[]);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-LetRec -}
 do m <- do y <- (l.
                do n <- null l;
                if n
                    then 
                        return []
                    else
                        do h <- head l;
                        do t <- tail l;
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h ++ y)) t;
                        return (h ++ y)) ((""):(3):(4):(5):[]);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-AppAbs -}
 do m <- do y <- do n <- null ((""):(3):(4):(5):[]);
                if n
                    then 
                        return []
                    else
                        do h <- head ((""):(3):(4):(5):[]);
                        do t <- tail ((""):(3):(4):(5):[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h ++ y)) t;
                        return (h ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-NullFalse -}
 do m <- do y <- do n <- return False;
                if n
                    then 
                        return []
                    else
                        do h <- head ((""):(3):(4):(5):[]);
                        do t <- tail ((""):(3):(4):(5):[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h ++ y)) t;
                        return (h ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-DoRet -}
 do m <- do y <- if False
                    then 
                        return []
                    else
                        do h <- head ((""):(3):(4):(5):[]);
                        do t <- tail ((""):(3):(4):(5):[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h ++ y)) t;
                        return (h ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-IfFalse -}
 do m <- do y <- do h <- head ((""):(3):(4):(5):[]);
                do t <- tail ((""):(3):(4):(5):[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return []
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h ++ y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) t;
                return (h ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Head -}
 do m <- do y <- do h <- return "";
                do t <- tail ((""):(3):(4):(5):[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return []
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h ++ y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) t;
                return (h ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-DoRet -}
 do m <- do y <- do t <- tail ((""):(3):(4):(5):[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return []
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h ++ y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) t;
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Tail -}
 do m <- do y <- do t <- return ((3):(4):(5):[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return []
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h ++ y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) t;
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return []
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h ++ y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) ((3):(4):(5):[]);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-LetRec -}
 do m <- do y <- do y <- (l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return []
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h ++ y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h ++ y) ) t;
                                return (h ++ y)) ((3):(4):(5):[]);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-AppAbs -}
 do m <- do y <- do y <- do n <- null ((3):(4):(5):[]);
                        if n
                            then 
                                return []
                            else
                                do h <- head ((3):(4):(5):[]);
                                do t <- tail ((3):(4):(5):[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return []
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h ++ y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h ++ y) ) t;
                                return (h ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-NullFalse -}
 do m <- do y <- do y <- do n <- return False;
                        if n
                            then 
                                return []
                            else
                                do h <- head ((3):(4):(5):[]);
                                do t <- tail ((3):(4):(5):[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return []
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h ++ y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h ++ y) ) t;
                                return (h ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- if False
                            then 
                                return []
                            else
                                do h <- head ((3):(4):(5):[]);
                                do t <- tail ((3):(4):(5):[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return []
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h ++ y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h ++ y) ) t;
                                return (h ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-IfFalse -}
 do m <- do y <- do y <- do h <- head ((3):(4):(5):[]);
                        do t <- tail ((3):(4):(5):[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h ++ y) ) t;
                        return (h ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Head -}
 do m <- do y <- do y <- do h <- return 3;
                        do t <- tail ((3):(4):(5):[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h ++ y) ) t;
                        return (h ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do t <- tail ((3):(4):(5):[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h ++ y) ) t;
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Tail -}
 do m <- do y <- do y <- do t <- return ((4):(5):[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h ++ y) ) t;
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h ++ y) ) ((4):(5):[]);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-LetRec -}
 do m <- do y <- do y <- do y <- (l.
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return []
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h ++ y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return []
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h ++ y)) t;
                                        return (h ++ y) ) ((4):(5):[]);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-AppAbs -}
 do m <- do y <- do y <- do y <- do n <- null ((4):(5):[]);
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head ((4):(5):[]);
                                        do t <- tail ((4):(5):[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return []
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h ++ y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return []
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h ++ y)) t;
                                        return (h ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-NullFalse -}
 do m <- do y <- do y <- do y <- do n <- return False;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head ((4):(5):[]);
                                        do t <- tail ((4):(5):[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return []
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h ++ y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return []
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h ++ y)) t;
                                        return (h ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do y <- if False
                                    then 
                                        return []
                                    else
                                        do h <- head ((4):(5):[]);
                                        do t <- tail ((4):(5):[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return []
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h ++ y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return []
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h ++ y)) t;
                                        return (h ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-IfFalse -}
 do m <- do y <- do y <- do y <- do h <- head ((4):(5):[]);
                                do t <- tail ((4):(5):[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return []
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h ++ y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h ++ y)) t;
                                return (h ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-Head -}
 do m <- do y <- do y <- do y <- do h <- return 4;
                                do t <- tail ((4):(5):[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return []
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h ++ y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h ++ y)) t;
                                return (h ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do y <- do t <- tail ((4):(5):[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return []
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h ++ y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h ++ y)) t;
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-Tail -}
 do m <- do y <- do y <- do y <- do t <- return ((5):[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return []
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h ++ y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h ++ y)) t;
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do y <- do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return []
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h ++ y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h ++ y)) ((5):[]);;
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-LetRec -}
 do m <- do y <- do y <- do y <- do y <- (l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- (let rec reduce = l.
                                                    do n <- null l;
                                                    if n
                                                        then 
                                                            return []
                                                        else
                                                            do h <- head l;
                                                            do t <- tail l;
                                                            do y <- reduce t;
                                                            return (h ++ y) in l.
                                                                do n <- null l;
                                                                if n
                                                                    then 
                                                                        return []
                                                                    else
                                                                        do h <- head l;
                                                                        do t <- tail l;
                                                                        do y <- reduce t;
                                                                        return (h ++ y)) t;
                                                return (h ++ y)) ((5):[]);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs -}
 do m <- do y <- do y <- do y <- do y <- do n <- null ((5):[]);
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head ((5):[]);
                                                do t <- tail ((5):[]);
                                                do y <- (let rec reduce = l.
                                                    do n <- null l;
                                                    if n
                                                        then 
                                                            return []
                                                        else
                                                            do h <- head l;
                                                            do t <- tail l;
                                                            do y <- reduce t;
                                                            return (h ++ y) in l.
                                                                do n <- null l;
                                                                if n
                                                                    then 
                                                                        return []
                                                                    else
                                                                        do h <- head l;
                                                                        do t <- tail l;
                                                                        do y <- reduce t;
                                                                        return (h ++ y)) t;
                                                return (h ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-NullFalse -}
 do m <- do y <- do y <- do y <- do y <- do n <- return False;
                                        if n
                                            then 
                                                return []
                                            else
                                                do h <- head ((5):[]);
                                                do t <- tail ((5):[]);
                                                do y <- (let rec reduce = l.
                                                    do n <- null l;
                                                    if n
                                                        then 
                                                            return []
                                                        else
                                                            do h <- head l;
                                                            do t <- tail l;
                                                            do y <- reduce t;
                                                            return (h ++ y) in l.
                                                                do n <- null l;
                                                                if n
                                                                    then 
                                                                        return []
                                                                    else
                                                                        do h <- head l;
                                                                        do t <- tail l;
                                                                        do y <- reduce t;
                                                                        return (h ++ y)) t;
                                                return (h ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do y <- do y <- if False
                                            then 
                                                return []
                                            else
                                                do h <- head ((5):[]);
                                                do t <- tail ((5):[]);
                                                do y <- (let rec reduce = l.
                                                    do n <- null l;
                                                    if n
                                                        then 
                                                            return []
                                                        else
                                                            do h <- head l;
                                                            do t <- tail l;
                                                            do y <- reduce t;
                                                            return (h ++ y) in l.
                                                                do n <- null l;
                                                                if n
                                                                    then 
                                                                        return []
                                                                    else
                                                                        do h <- head l;
                                                                        do t <- tail l;
                                                                        do y <- reduce t;
                                                                        return (h ++ y)) t;
                                                return (h ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-IfFalse -}
 do m <- do y <- do y <- do y <- do y <- do h <- head ((5):[]);
                                        do t <- tail ((5):[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return []
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h ++ y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return []
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h ++ y)) t;
                                        return (h ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Head -}
 do m <- do y <- do y <- do y <- do y <- do h <- return 5;
                                        do t <- tail ((5):[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return []
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h ++ y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return []
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h ++ y)) t;
                                        return (h ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do y <- do y <- do t <- tail ((5):[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return []
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h ++ y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return []
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h ++ y)) t;
                                        return (5 ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Tail -}
 do m <- do y <- do y <- do y <- do y <- do t <- return [];
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return []
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h ++ y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return []
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h ++ y)) t;
                                        return (5 ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do y <- do y <- do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return []
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h ++ y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return []
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h ++ y)) [];
                                        return (5 ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-LetRec -}
 do m <- do y <- do y <- do y <- do y <- do y <- (l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- (let rec reduce = l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return []
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                    return (h ++ y) in l.
                                                                        do n <- null l;
                                                                        if n
                                                                            then 
                                                                                return []
                                                                            else
                                                                                do h <- head l;
                                                                                do t <- tail l;
                                                                                do y <- reduce t;
                                                                                return (h ++ y)) t;
                                                        return (h ++ y)) [];
                                        return (5 ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs -}
 do m <- do y <- do y <- do y <- do y <- do y <- do n <- null [];
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head [];
                                                        do t <- tail [];
                                                        do y <- (let rec reduce = l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return []
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                    return (h ++ y) in l.
                                                                        do n <- null l;
                                                                        if n
                                                                            then 
                                                                                return []
                                                                            else
                                                                                do h <- head l;
                                                                                do t <- tail l;
                                                                                do y <- reduce t;
                                                                                return (h ++ y)) t;
                                                        return (h ++ y);
                                        return (5 ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-NullTrue -}
 do m <- do y <- do y <- do y <- do y <- do y <- do n <- return True;
                                                if n
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head [];
                                                        do t <- tail [];
                                                        do y <- (let rec reduce = l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return []
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                    return (h ++ y) in l.
                                                                        do n <- null l;
                                                                        if n
                                                                            then 
                                                                                return []
                                                                            else
                                                                                do h <- head l;
                                                                                do t <- tail l;
                                                                                do y <- reduce t;
                                                                                return (h ++ y)) t;
                                                        return (h ++ y);
                                        return (5 ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do y <- do y <- do y <- if True
                                                    then 
                                                        return []
                                                    else
                                                        do h <- head [];
                                                        do t <- tail [];
                                                        do y <- (let rec reduce = l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return []
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                    return (h ++ y) in l.
                                                                        do n <- null l;
                                                                        if n
                                                                            then 
                                                                                return []
                                                                            else
                                                                                do h <- head l;
                                                                                do t <- tail l;
                                                                                do y <- reduce t;
                                                                                return (h ++ y)) t;
                                                        return (h ++ y);
                                        return (5 ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-IfTrue -}
 do m <- do y <- do y <- do y <- do y <- do y <- return []
                                        return (5 ++ y);
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do y <- do y <- return 5;
                                return (4 ++ y);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- do y <- return (45);
                        return (3 ++ y);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-Do and E-DoRet -}
 do m <- do y <- do y <- return (345);
                return ("" ++ y);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-Do and E-DoRet -}
 do m <- do y <- return (345);
        return (1 ++ y);
return (m ++ "", Left "error")

{- E-Do and E-DoRet -}
 do m <- return (1345);
return (m ++ "", Left "error")

{- E-DoRet -}
return (1345, Left "error")