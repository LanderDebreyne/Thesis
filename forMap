#######

Updated: 02/01/2023

#######



for lstv (i. op accum i (x. return x)) (x. return x)

hAccum = handler 
    {
        return x -> return (0, x)
        op accum m k -> do (m', v) <- k (); return (m + m', v)
        for l p k ->    do pairs <- for l p k;
                        do first <- map fst pairs;
                        do second <- map snd pairs;
                        do (m', b) <- k second;
                        let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in 
                                        do m <- reduce first;
                                        return (m + m', b)
        fwd f p k -> f (p, k) -- TODO
    }

-- "parallelle" pure for-each
hPure = handler
    {
        return x -> return x
        for l p k -> do res <- map p l;
                    k res
        fwd f p k -> -- TODO
    }

-- parallelle implementatie mogelijk
-- Bijvoorbeeld door lijst te splitsen over threads en resultaten te reduceren zelfde reducerende functie
-- niet-parallelle implementatie 
reduce :: (ReducingFunction (v->v->v)) => [v] -> (v->v->v) -> v 
let rec reduce = l. f. mempty.
    do n <- null l;
    if n then return mempty else
        do h <- head l;
        do t <- tail l;
        do y <- reduce t f mempty;
        return (f h y) in

hPure # hAccum # for (1:2:3:4:5:[]) (i. op accum i (x. return x)) (x. return x)

{- E-Hand and E-HandFor -}
hPure # do pairs <- for (1:2:3:4:5:[]) (i. hAccum # op accum i (x. return x)) (x. hAccum # return x);
do first <- map fst pairs;
do second <- map snd pairs;
do (m', b) <- k second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)

{- E-Hand and E-DoFor -}
hPure # for (1:2:3:4:5:[]) (i. hAccum # op accum i (x. return x)) 
(x. do pairs <- hAccum # return x;
do first <- map fst pairs;
do second <- map snd pairs;
do (m', b) <- k second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b))

{- E-HandFor -}
do res <- map (i. hPure # hAccum # op accum i (x. return x)) (1:2:3:4:5:[]);
(x. hPure # do pairs <- hAccum # return x;
do first <- map fst pairs;
do second <- map snd pairs;
do (m', b) <- k second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)) res

{- E-Do and E-Map -}
do res <-   (((i. hPure # hAccum # op accum i (x. return x)) 1):
            ((i. hPure # hAccum # op accum i (x. return x)) 2):
            ((i. hPure # hAccum # op accum i (x. return x)) 3):
            ((i. hPure # hAccum # op accum i (x. return x)) 4):
            ((i. hPure # hAccum # op accum i (x. return x)) 5):[]);
(x. hPure # do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)) res

{- E-Do and E-ParList and [E-AppAbs*5] -}
do res <-   ((hPure # hAccum # op accum 1 (x. return x)):
            (hPure # hAccum # op accum 2 (x. return x)):
            (hPure # hAccum # op accum 3 (x. return x)):
            (hPure # hAccum # op accum 4 (x. return x)):
            (hPure # hAccum # op accum 5 (x. return x)):[]);
(x. hPure # do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)) res

{- E-Do and E-ParList and [E-Hand and E-HandOp*5] -}
do res <-   (hPure # do (m', v) <- (x. hAccum # return x) (); return (m' + 1, v)):
            (hPure # do (m', v) <- (x. hAccum # return x) (); return (m' + 2, v)):
            (hPure # do (m', v) <- (x. hAccum # return x) (); return (m' + 3, v)):
            (hPure # do (m', v) <- (x. hAccum # return x) (); return (m' + 4, v)):
            (hPure # do (m', v) <- (x. hAccum # return x) (); return (m' + 5, v)):[]);
(x. hPure # do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)) res

{- E-Do and E-ParList and [E-Hand and E-Do and E-AppAbs*5] -}
do res <-   ((hPure # do (m', v) <- hAccum # return (); return (m' + 1, v)):
            (hPure # do (m', v) <- hAccum # return (); return (m' + 2, v)):
            (hPure # do (m', v) <- hAccum # return (); return (m' + 3, v)):
            (hPure # do (m', v) <- hAccum # return (); return (m' + 4, v)):
            (hPure # do (m', v) <- hAccum # return (); return (m' + 5, v)):[]);
(x. hPure # do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)) res

{- E-Do and E-ParList and [E-Hand and E-Do and E-HandRet*5] -}
do res <-   ((hPure # do (m', v) <- return (0,()); return (m' + 1, v)):
            (hPure # do (m', v) <- return (0,()); return (m' + 2, v)):
            (hPure # do (m', v) <- return (0,()); return (m' + 3, v)):
            (hPure # do (m', v) <- return (0,()); return (m' + 4, v)):
            (hPure # do (m', v) <- return (0,()); return (m' + 5, v)):[]);
(x. hPure # do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)) res

{- E-Do and E-ParList and [E-Hand and E-DoRet*5] -}
do res <-   ((hPure # return (1, ())):
            (hPure # return (2, ())):
            (hPure # return (3, ())):
            (hPure # return (4, ())):
            (hPure # return (5, ())):[]);
(x. hPure # do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)) res

{- E-Do and E-ParList and [E-HandRet*5] -}
do res <-   ((return (1, ())):(return (2, ())):(return (3, ())):(return (4, ())):(return (5, ())):[]);
(x. hPure # do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)) res


{- E-Do and E-ListRet -}
do res <- return ((1, ()):(2, ()):(3, ()):(4, ()):(5, ()):[]);
(x. hPure # do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)) res

{- E-DoRet -}
(x. hPure # do first <- map fst x;
do second <- map snd x;
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)) ((1, ()):(2, ()):(3, ()):(4, ()):(5, ()):[])

{- E-AppAbs -}
hPure # do first <- map fst ((1, ()):(2, ()):(3, ()):(4, ()):(5, ()):[]);
do second <- map snd ((1, ()):(2, ()):(3, ()):(4, ()):(5, ()):[]);
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)

{- E-Hand and E-Do and E-Map -}
hPure # do first <-((fst (1, ())):(fst (2, ())):(fst (3, ())):(fst (4, ())):(fst (5, ())):[]);
do second <- map snd ((1, ()):(2, ()):(3, ()):(4, ()):(5, ()):[]);
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)

{- E-Hand and E-Do and E-ParList and [E-First, E-First, E-First, E-First, E-First] -}
hPure # do first <- ((return 1):(return 2):(return 3):(return 4):(return 5):[]);
do second <- map snd ((1, ()):(2, ()):(3, ()):(4, ()):(5, ()):[]);
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce first;
                return (m + m', b)

{- E-Hand and E-Do and E-ListRet -}
hPure # do second <- map snd ((1, ()):(2, ()):(3, ()):(4, ()):(5, ()):[]);
do (m', b) <- (x. hAccum # return x) second;
return (first + m', b) 

{- E-Hand and E-DoRet -}
hPure # do second <- map snd ((1, ()):(2, ()):(3, ()):(4, ()):(5, ()):[]);
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce (1:2:3:4:5:[]);
                return (m + m', b)

{- E-Hand and E-Do and E-Map -}
hPure # do second <- ((snd (1, ())):(snd (2, ())):(snd (3, ())):(snd (4, ())):(snd (5, ())):[]);
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce (1:2:3:4:5:[]);
                return (m + m', b) 

{- E-Hand and E-Do and E-ParList and [E-Second, E-Second, E-Second, E-Second, E-Second] -}
hPure # do second <- ((return ()):(return ()):(return ()):(return  ()):(return ()):[]);
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce (1:2:3:4:5:[]);
                return (m + m', b) 

{- E-Hand and E-Do and E-ListRet -}
hPure # do second <- return (():():():():():[]);
do (m', b) <- (x. hAccum # return x) second;
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce (1:2:3:4:5:[]);
                return (m + m', b) 

{- E-Hand and E-DoRet -}
hPure # do (m', b) <- (x. hAccum # return x) (():():():():():[]);
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce (1:2:3:4:5:[]);
                return (m + m', b) 

{- E-Hand and E-Do and E-AppAbs -}
hPure # do (m', b) <- hAccum # return (():():():():():[]);
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce (1:2:3:4:5:[]);
                return (m + m', b) 

{- E-Hand and E-Do and E-HandRet -}
hPure # do (m', b) <- return (0, (():():():():():[]));
let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce (1:2:3:4:5:[]);
                return (m + m', b) 

{- E-Hand and E-DoRet -}
hPure # let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in 
                do m <- reduce (1:2:3:4:5:[]);
                return (m + 0, (():():():():():[])) 

{- E-Hand and E-LetRec -}
hPure # do m <- (let rec reduce = l.
    do n <- null l;
    if n
        then 
            return 0
        else
            do h <- head l;
            do t <- tail l;
            do y <- reduce t;
            return (h + y) in l.
                do n <- null l;
                if n
                    then 
                        return 0
                    else
                        do h <- head l;
                        do t <- tail l;
                        do y <- reduce t;
                        return (h + y)) (1:2:3:4:5:[]);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-LetRec -}
hPure # do m <- (l.
        do n <- null l;
        if n
            then 
                return 0
            else
                do h <- head l;
                do t <- tail l;
                do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y))) (1:2:3:4:5:[]);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-AppAbs -}
hPure # do m <- do n <- null (1:2:3:4:5:[]);
        if n
            then 
                return 0
            else
                do h <- head (1:2:3:4:5:[]);
                do t <- tail (1:2:3:4:5:[]);
                do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y)) t;
                return (h + y);
return (m + 0, (():():():():():[])) 

{- E-hand and E-Do and E-Do and E-NullFalse -}
hPure # do m <- do n <- return False;
        if n
            then 
                return 0
            else
                do h <- head (1:2:3:4:5:[]);
                do t <- tail (1:2:3:4:5:[]);
                do y <- (let rec reduce = l.
                        do n <- null l;
                        if n
                            then 
                                return 0
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h + y) in l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return 0
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h + y)) t;
                return (h + y);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-DoRet -}
hPure # do m <- if False
            then 
                return 0
            else
                do h <- head (1:2:3:4:5:[]);
                do t <- tail (1:2:3:4:5:[]);
                do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return 0
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h + y) in l.
                        do n <- null l;
                        if n
                            then 
                                return 0
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h + y)) t;
                return (h + y);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-IfFalse -}
hPure # do m <- do h <- head (1:2:3:4:5:[]);
        do t <- tail (1:2:3:4:5:[]);
        do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return 0
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h + y) in l.
                        do n <- null l;
                        if n
                            then 
                                return 0
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h + y)) t;
        return (h + y);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-Do and E-Head -}
hPure # do m <- do h <- return 1;
        do t <- tail (1:2:3:4:5:[]);
        do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return 0
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h + y) in l.
                        do n <- null l;
                        if n
                            then 
                                return 0
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h + y)) t;
        return (h + y);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-DoRet -}
hPure # do m <- do t <- tail (1:2:3:4:5:[]);
        do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return 0
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h + y) in l.
                        do n <- null l;
                        if n
                            then 
                                return 0
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h + y)) t;
        return (1 + y);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-Do and E-Tail -}
hPure # do m <- do t <- return (2:3:4:5:[]);
        do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return 0
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h + y) in l.
                        do n <- null l;
                        if n
                            then 
                                return 0
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h + y)) t;
        return (1 + y);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-DoRet -}
hPure # do m <- do y <- (let rec reduce = l.
            do n <- null l;
            if n
                then 
                    return 0
                else
                    do h <- head l;
                    do t <- tail l;
                    do y <- reduce t;
                    return (h + y) in l.
                        do n <- null l;
                        if n
                            then 
                                return 0
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h + y)) (2:3:4:5:[]);
        return (1 + y);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-Do and E-LetRec -}
hPure # do m <- do y <- (l.
                do n <- null l;
                if n
                    then 
                        return 0
                    else
                        do h <- head l;
                        do t <- tail l;
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y)) t;
                        return (h + y)) (2:3:4:5:[]);
        return (1 + y);
return (m + 0, (():():():():():[])) 

{- E-Hand andE-Do and E-Do and E-Do and E-AppAbs -}
hPure # do m <- do y <- do n <- null (2:3:4:5:[]);
                if n
                    then 
                        return 0
                    else
                        do h <- head (2:3:4:5:[]);
                        do t <- tail (2:3:4:5:[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y)) t;
                        return (h + y);
        return (1 + y);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-Do and E-Do and E-NullFalse -}
hPure # do m <- do y <- do n <- return False;
                if n
                    then 
                        return 0
                    else
                        do h <- head (2:3:4:5:[]);
                        do t <- tail (2:3:4:5:[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y)) t;
                        return (h + y);
        return (1 + y);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- if False
                    then 
                        return 0
                    else
                        do h <- head (2:3:4:5:[]);
                        do t <- tail (2:3:4:5:[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y)) t;
                        return (h + y);
        return (1 + y);
return (m + 0, (():():():():():[])) 

{- E-Hand and E-Do and E-Do and E-IfFalse -}
hPure # do m <- do y <- do h <- head (2:3:4:5:[]);
                do t <- tail (2:3:4:5:[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return 0
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h + y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return 0
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h + y)) t;
                return (h + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Head -}
hPure # do m <- do y <- do h <- return 2;
                do t <- tail (2:3:4:5:[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return 0
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h + y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return 0
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h + y)) t;
                return (h + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do t <- tail (2:3:4:5:[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return 0
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h + y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return 0
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h + y)) t;
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Tail -}
hPure # do m <- do y <- do t <- return (3:4:5:[]);
                do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return 0
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h + y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return 0
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h + y)) t;
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do y <- (let rec reduce = l.
                    do n <- null l;
                    if n
                        then 
                            return 0
                        else
                            do h <- head l;
                            do t <- tail l;
                            do y <- reduce t;
                            return (h + y) in l.
                                do n <- null l;
                                if n
                                    then 
                                        return 0
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h + y)) (3:4:5:[]);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-LetRec -}
hPure # do m <- do y <- do y <- (l.
                        do n <- null l;
                        if n
                            then 
                                return 0
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return 0
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h + y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h + y)) t;
                                return (h + y)) (3:4:5:[]);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-AppAbs -}
hPure # do m <- do y <- do y <- do n <- null (3:4:5:[]);
                        if n
                            then 
                                return 0
                            else
                                do h <- head (3:4:5:[]);
                                do t <- tail (3:4:5:[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return 0
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h + y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h + y)) t;
                                return (h + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-NullFalse -}
hPure # do m <- do y <- do y <- do n <- return False;
                        if n
                            then 
                                return 0
                            else
                                do h <- head (3:4:5:[]);
                                do t <- tail (3:4:5:[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return 0
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h + y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h + y)) t;
                                return (h + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do y <- if False
                            then 
                                return 0
                            else
                                do h <- head (3:4:5:[]);
                                do t <- tail (3:4:5:[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return 0
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h + y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h + y)) t;
                                return (h + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-IfFalse -}
hPure # do m <- do y <- do y <- do h <- head (3:4:5:[]);
                        do t <- tail (3:4:5:[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y)) t;
                                return (h + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Head -}
hPure # do m <- do y <- do y <- do h <- return 3;
                        do t <- tail (3:4:5:[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y)) t;
                                return (h + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do y <- do t <- tail (3:4:5:[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y)) t;
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Tail -}
hPure # do m <- do y <- do y <- do t <- return (4:5:[]);
                        do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y)) t;
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do y <- do y <- (let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return 0
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h + y) in l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- reduce t;
                                                return (h + y)) (4:5:[]);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-LetRec -}
hPure # do m <- do y <- do y <- do y <- (l.
                                do n <- null l;
                                if n
                                    then 
                                        return 0
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return 0
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h + y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return 0
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h + y)) t;
                                        return (h + y)) (4:5:[]);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))


{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-AppAbs -}
hPure # do m <- do y <- do y <- do y <- do n <- null (4:5:[]);
                                if n
                                    then 
                                        return 0
                                    else
                                        do h <- head (4:5:[]);
                                        do t <- tail (4:5:[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return 0
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h + y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return 0
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h + y)) t;
                                        return (h + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-NullFalse -}
hPure # do m <- do y <- do y <- do y <- do n <- return False;
                                if n
                                    then 
                                        return 0
                                    else
                                        do h <- head (4:5:[]);
                                        do t <- tail (4:5:[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return 0
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h + y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return 0
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h + y)) t;
                                        return (h + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do y <- do y <- if False
                                    then 
                                        return 0
                                    else
                                        do h <- head (4:5:[]);
                                        do t <- tail (4:5:[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return 0
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                    return (h + y) in l.
                                                        do n <- null l;
                                                        if n
                                                            then 
                                                                return 0
                                                            else
                                                                do h <- head l;
                                                                do t <- tail l;
                                                                do y <- reduce t;
                                                                return (h + y)) t;
                                        return (h + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-IfFalse -}
hPure # do m <- do y <- do y <- do y <- do h <- head (4:5:[]);
                                do t <- tail (4:5:[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return 0
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h + y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h + y)) t;
                                        return (h + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Head -}
hPure # do m <- do y <- do y <- do y <- do h <- return 4;
                                do t <- tail (4:5:[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return 0
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h + y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h + y)) t;
                                        return (h + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
do m <- do y <- do y <- do y <- do t <- tail (4:5:[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return 0
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h + y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h + y)) t;
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Tail -}
hPure # do m <- do y <- do y <- do y <- do t <- return (5:[]);
                                do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return 0
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h + y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h + y)) t;
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do y <- do y <- do y <- (let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return 0
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h + y) in l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- reduce t;
                                                        return (h + y)) (5:[]);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand andE-Do and E-Do and E-Do and E-Do and E-Do and E-LetRec -}
hPure # do m <- do y <- do y <- do y <- do y <- (l.
                                        do n <- null l;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head l;
                                                do t <- tail l;
                                                do y <- (let rec reduce = l.
                                                    do n <- null l;
                                                    if n
                                                        then 
                                                            return 0
                                                        else
                                                            do h <- head l;
                                                            do t <- tail l;
                                                            do y <- reduce t;
                                                                return (h + y) in l.
                                                                    do n <- null l;
                                                                    if n
                                                                        then 
                                                                            return 0
                                                                        else
                                                                            do h <- head l;
                                                                            do t <- tail l;
                                                                            do y <- reduce t;
                                                                            return (h + y)) t;
                                                return (h + y)) (5:[]);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs -}
hPure # do m <- do y <- do y <- do y <- do y <- do n <- null (5:[]);
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head (5:[]);
                                                do t <- tail (5:[]);
                                                do y <- (let rec reduce = l.
                                                    do n <- null l;
                                                    if n
                                                        then 
                                                            return 0
                                                        else
                                                            do h <- head l;
                                                            do t <- tail l;
                                                            do y <- reduce t;
                                                                return (h + y) in l.
                                                                    do n <- null l;
                                                                    if n
                                                                        then 
                                                                            return 0
                                                                        else
                                                                            do h <- head l;
                                                                            do t <- tail l;
                                                                            do y <- reduce t;
                                                                            return (h + y)) t;
                                                return (h + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-NullFalse -}
hPure # do m <- do y <- do y <- do y <- do y <- do n <- return False;
                                        if n
                                            then 
                                                return 0
                                            else
                                                do h <- head (5:[]);
                                                do t <- tail (5:[]);
                                                do y <- (let rec reduce = l.
                                                    do n <- null l;
                                                    if n
                                                        then 
                                                            return 0
                                                        else
                                                            do h <- head l;
                                                            do t <- tail l;
                                                            do y <- reduce t;
                                                                return (h + y) in l.
                                                                    do n <- null l;
                                                                    if n
                                                                        then 
                                                                            return 0
                                                                        else
                                                                            do h <- head l;
                                                                            do t <- tail l;
                                                                            do y <- reduce t;
                                                                            return (h + y)) t;
                                                return (h + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do y <- do y <- do y <- if False
                                            then 
                                                return 0
                                            else
                                                do h <- head (5:[]);
                                                do t <- tail (5:[]);
                                                do y <- (let rec reduce = l.
                                                    do n <- null l;
                                                    if n
                                                        then 
                                                            return 0
                                                        else
                                                            do h <- head l;
                                                            do t <- tail l;
                                                            do y <- reduce t;
                                                                return (h + y) in l.
                                                                    do n <- null l;
                                                                    if n
                                                                        then 
                                                                            return 0
                                                                        else
                                                                            do h <- head l;
                                                                            do t <- tail l;
                                                                            do y <- reduce t;
                                                                            return (h + y)) t;
                                                return (h + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-IfFalse -}
hPure # do m <- do y <- do y <- do y <- do y <- do h <- head (5:[]);
                                        do t <- tail (5:[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return 0
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                        return (h + y) in l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return 0
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                    return (h + y)) t;
                                                return (h + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Head -}
hPure # do m <- do y <- do y <- do y <- do y <- do h <- return 5;
                                        do t <- tail (5:[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return 0
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                        return (h + y) in l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return 0
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                    return (h + y)) t;
                                                return (h + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do y <- do y <- do y <- do t <- tail (5:[]);
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return 0
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                        return (h + y) in l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return 0
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                    return (h + y)) t;
                                                return (5 + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Tail -}
hPure # do m <- do y <- do y <- do y <- do y <- do t <- return [];
                                        do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return 0
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                        return (h + y) in l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return 0
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                    return (h + y)) t;
                                                return (5 + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do y <- do y <- do y <- do y <- (let rec reduce = l.
                                            do n <- null l;
                                            if n
                                                then 
                                                    return 0
                                                else
                                                    do h <- head l;
                                                    do t <- tail l;
                                                    do y <- reduce t;
                                                        return (h + y) in l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return 0
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                    return (h + y)) [];
                                                return (5 + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-LetRec -}
hPure # do m <- do y <- do y <- do y <- do y <- do y <- (l.
                                                do n <- null l;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head l;
                                                        do t <- tail l;
                                                        do y <- (let rec reduce = l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return 0
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                        return (h + y) in l.
                                                                            do n <- null l;
                                                                            if n
                                                                                then 
                                                                                    return 0
                                                                                else
                                                                                    do h <- head l;
                                                                                    do t <- tail l;
                                                                                    do y <- reduce t;
                                                                                        return (h + y)) t;
                                                        return (h + y)) [];
                                                return (5 + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-AppAbs -}
hPure # do m <- do y <- do y <- do y <- do y <- do y <- (do n <- null [];
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head [];
                                                        do t <- tail [];
                                                        do y <- (let rec reduce = l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return 0
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                        return (h + y) in l.
                                                                            do n <- null l;
                                                                            if n
                                                                                then 
                                                                                    return 0
                                                                                else
                                                                                    do h <- head l;
                                                                                    do t <- tail l;
                                                                                    do y <- reduce t;
                                                                                        return (h + y)) t;
                                                        return (h + y)) [];
                                                return (5 + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-NullTrue -}
hPure # do m <- do y <- do y <- do y <- do y <- do y <- (do n <- return True;
                                                if n
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head [];
                                                        do t <- tail [];
                                                        do y <- (let rec reduce = l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return 0
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                        return (h + y) in l.
                                                                            do n <- null l;
                                                                            if n
                                                                                then 
                                                                                    return 0
                                                                                else
                                                                                    do h <- head l;
                                                                                    do t <- tail l;
                                                                                    do y <- reduce t;
                                                                                        return (h + y)) t;
                                                        return (h + y)) [];
                                                return (5 + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet -}
hPure # do m <- do y <- do y <- do y <- do y <- do y <- (if True
                                                    then 
                                                        return 0
                                                    else
                                                        do h <- head [];
                                                        do t <- tail [];
                                                        do y <- (let rec reduce = l.
                                                            do n <- null l;
                                                            if n
                                                                then 
                                                                    return 0
                                                                else
                                                                    do h <- head l;
                                                                    do t <- tail l;
                                                                    do y <- reduce t;
                                                                        return (h + y) in l.
                                                                            do n <- null l;
                                                                            if n
                                                                                then 
                                                                                    return 0
                                                                                else
                                                                                    do h <- head l;
                                                                                    do t <- tail l;
                                                                                    do y <- reduce t;
                                                                                        return (h + y)) t;
                                                        return (h + y)) [];
                                                return (5 + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-Do and E-IfTrue -}
hPure # do m <- do y <- do y <- do y <- do y <- do y <- return 0
                                                return (5 + y);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-Do and E-DoRet-}
hPure # do m <- do y <- do y <- do y <- do y <- return (5);
                                        return (4 + y);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-Do and E-DoRet-}
hPure # do m <- do y <- do y <- do y <- return (9);
                                return (3 + y);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-Do and E-DoRet-}
hPure # do m <- do y <- do y <- return (12);
                return (2 + y);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-Do and E-DoRet-}
hPure # do m <- do y <- return (14);
        return (1 + y);
return (m + 0, (():():():():():[]))

{- E-Hand and E-Do and E-DoRet-}
hPure # do m <- return (15);
return (m + 0, (():():():():():[]))

{- E-Hand and E-DoRet-}
hPure # return (15, (():():():():():[]))

{- E-HandRet-}
return (15, (():():():():():[]))

-- Correct met parallel algebraic effects implementatie