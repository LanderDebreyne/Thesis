#######

Updated: 03/01/2023

#######



do _ <- op accum "start " (x. return x);
do _ <- for 1:2:3:4:5:[] (x. if x == 2
    then
    do _ <- op accum "!" (x.return x);
    do _ <- op throw "error" (x. return x);
    op accum "unreachable" (x. return x)
    else op accum x (x. return x)) ;
do _ <- op accum " end" (x. return x);
return "success"

hAccum = handler 
    {
        return x -> return ("", x)
        op accum m k -> do (m', v) <- k (); return (m ++ m', v)  
        for l p k ->    do pairs <- for l p k;
                        do first <- map fst pairs;
                        do second <- map snd pairs;
                        do (m', b) <- k second;
                        let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in 
                                        do m <- reduce first;
                                        return (m ++ m', b)
        fwd f p k -> f (p, k) -- TODO
    }


hWeak = handler 
    {
        return x -> return (Right x)
        op throw m _ -> return (Left m)
        for l p k ->    do results <- for l p k;
                        case firstFailure results of
                            Left err -> return (Left err)
                            Right t  -> k t
        fwd f p k -> f (p, k) -- TODO
    }

firstFailure lst = case map firstError lst of
    Just e  -> Left e
    Nothing -> Right $ fmap (\(Right x) -> x) lst 
  where firstError x = case x of Left e  -> Just e
                                 Right _ -> Nothing

hPure = handler 
{
    return x -> return x
    for l p k -> do res <- map p l;
                 k res
    fwd f p k -> -- TODO 
}

hPure # hAccum # hWeak # (do _ <- op accum "start " (x. return x);
                        do _ <- for 1:2:3:4:5:[] (x. if x == 2
                            then
                            do _ <- op accum "!" (x.return x);
                            do _ <- op throw "error" (x. return x);
                            op accum "unreachable" (x. return x)
                            else op accum x (x. return x)) (x. return x);
                        do _ <- op accum " end" (x. return x) (x. return x);
                        return "success")

{- E-Hand and E-hand and E-Hand and E-DoOp -}
hPure # hAccum # hWeak # op accum "start " (x. 
                                    do _ <- return x;
                                    do _ <- for 1:2:3:4:5:[] (x. if x == 2
                                        then
                                        do _ <- op accum "!" (x.return x);
                                        do _ <- op throw "error" (x. return x);
                                        op accum "unreachable" (x. return x)
                                        else op accum x (x. return x)) (x. return x);
                                    do _ <- op accum " end" (x. return x) (x. return x);
                                    return "success")

{- E-Hand and E-Hand and E-FwdOp -}
hPure # hAccum # op accum "start " (x. hWeak # 
                            do _ <- return x;
                            do _ <- for 1:2:3:4:5:[] (x. if x == 2
                                then
                                do _ <- op accum "!" (x.return x);
                                do _ <- op throw "error" (x. return x);
                                op accum "unreachable" (x. return x)
                                else op accum x (x. return x)) (x. return x);
                            do _ <- op accum " end" (x. return x) (x. return x);
                            return "success")

{- E-Hand and E-HandOp -}
hPure # do (m', v) <- (x. hAccum # hWeak # 
                do _ <- return x;
                do _ <- for 1:2:3:4:5:[] (x. if x == 2
                    then
                    do _ <- op accum "!" (x.return x);
                    do _ <- op throw "error" (x. return x);
                    op accum "unreachable" (x. return x)
                    else op accum x (x. return x)) (x. return x);
                do _ <- op accum " end" (x. return x) (x. return x);
                return "success") (); 
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-AppAbs -}
hPure # do (m', v) <- hAccum # hWeak # 
                do _ <- return ();
                do _ <- for 1:2:3:4:5:[] (x. if x == 2
                    then
                    do _ <- op accum "!" (x.return x);
                    do _ <- op throw "error" (x. return x);
                    op accum "unreachable" (x. return x)
                    else op accum x (x. return x)) (x. return x);
                do _ <- op accum " end" (x. return x) (x. return x);
                return "success"; 
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Hand and E-Hand and E-DoRet -}
hPure # do (m', v) <- hAccum # hWeak # 
                do _ <- for 1:2:3:4:5:[] (x. if x == 2
                    then
                    do _ <- op accum "!" (x.return x);
                    do _ <- op throw "error" (x. return x);
                    op accum "unreachable" (x. return x)
                    else op accum x (x. return x)) (x. return x);
                do _ <- op accum " end" (x. return x) (x. return x);
                return "success"; 
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Hand and E-Hand and E-DoFor -}
hPure # do (m', v) <- hAccum # hWeak # 
            for 1:2:3:4:5:[] (x. if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) (x. 
                                                do _ <- return x;
                                                do _ <- op accum " end" (x. return x) (x. return x);
                                                return "success"; 
                );
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Hand and E-HandFor -}
hPure # do (m', v) <- hAccum #
            do results <- for (1:2:3:4:5:[]) (x. hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) (x. hWeak # 
                                                do _ <- return x;
                                                do _ <- op accum " end" (x. return x) (x. return x);
                                                return "success"; );
            case firstFailure results of
                Left err -> return (Left err)
                Right t  -> (x. hWeak # 
                            do _ <- return x;
                            do _ <- op accum " end" (x. return x) (x. return x);
                            return "success"; ) t
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Hand and E-DoFor -}
hPure # do (m', v) <- hAccum #
            for (1:2:3:4:5:[]) (x. hWeak #  if x == 2
                then
                do _ <- op accum "!" (x.return x);
                do _ <- op throw "error" (x. return x);
                op accum "unreachable" (x. return x)
                else op accum x (x. return x)) (x. do results <- hWeak # 
                                                do _ <- return x;
                                                do _ <- op accum " end" (x. return x) (x. return x);
                                                return "success"; 
                                                case firstFailure results of
                                                    Left err -> return (Left err)
                                                    Right t  -> (x. hWeak # 
                                                                do _ <- return x;
                                                                do _ <- op accum " end" (x. return x) (x. return x);
                                                                return "success"; ) t);
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Hand and E-HandFor -}
hPure # do (m', v) <-   do pairs <- for (1:2:3:4:5:[]) 
                            (x. hAccum # hWeak #  if x == 2
                            then
                            do _ <- op accum "!" (x.return x);
                            do _ <- op throw "error" (x. return x);
                            op accum "unreachable" (x. return x)
                            else op accum x (x. return x)) 
                                (x. hAccum # do results <- hWeak # 
                                    do _ <- return x;
                                    do _ <- op accum " end" (x. return x) (x. return x);
                                    return "success"; 
                                    case firstFailure results of
                                        Left err -> return (Left err)
                                        Right t  -> (x. hWeak # 
                                                    do _ <- return x;
                                                    do _ <- op accum " end" (x. return x) (x. return x);
                                                    return "success"; ) t);
                        do first <- map fst pairs;
                        do second <- map snd pairs;
                        do (m', b) <- k second;
                        let rec reduce = l.
                            do n <- null l;
                            if n
                                then 
                                    return []
                                else
                                    do h <- head l;
                                    do t <- tail l;
                                    do y <- reduce t;
                                    return (h ++ y) in 
                                        do m <- reduce first;
                                        return (m ++ m', b)
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-DoFor -}
hPure # do (m', v) <- for (1:2:3:4:5:[]) 
                        (x. hAccum # hWeak #  if x == 2
                        then
                        do _ <- op accum "!" (x.return x);
                        do _ <- op throw "error" (x. return x);
                        op accum "unreachable" (x. return x)
                        else op accum x (x. return x)) 
                            (x. do pairs <- (hAccum # do results <- hWeak # 
                                do _ <- return x;
                                do _ <- op accum " end" (x. return x) (x. return x);
                                return "success"; 
                                case firstFailure results of
                                    Left err -> return (Left err)
                                    Right t  -> (x. hWeak # 
                                                do _ <- return x;
                                                do _ <- op accum " end" (x. return x) (x. return x);
                                                return "success"; ) t);
                                do first <- map fst pairs;
                                do second <- map snd pairs;
                                do (m', b) <- k second;
                                let rec reduce = l.
                                    do n <- null l;
                                    if n
                                        then 
                                            return []
                                        else
                                            do h <- head l;
                                            do t <- tail l;
                                            do y <- reduce t;
                                            return (h ++ y) in 
                                                do m <- reduce first;
                                                return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-DoFor -}
hPure # for (1:2:3:4:5:[]) 
            (x. hAccum # hWeak #  if x == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum x (x. return x)) 
                (x. do (m', v) <- (do pairs <- (hAccum # do results <- hWeak # 
                    do _ <- return x;
                    do _ <- op accum " end" (x. return x) (x. return x);
                    return "success"; 
                    case firstFailure results of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # 
                                    do _ <- return x;
                                    do _ <- op accum " end" (x. return x) (x. return x);
                                    return "success"; ) t);
                    do first <- map fst pairs;
                    do second <- map snd pairs;
                    do (m', b) <- k second;
                    let rec reduce = l.
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in 
                                    do m <- reduce first;
                                    return (m ++ m', b));
                    return ("start " ++ m', v) )

{- E-HandFor -}
do res <- map (x. hPure # hAccum # hWeak #  if x == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum x (x. return x))  (1:2:3:4:5:[]);
(x. hPure # do (m', v) <- (do pairs <- (hAccum # do results <- hWeak # 
    do _ <- return x;
    do _ <- op accum " end" (x. return x) (x. return x);
    return "success"; 
    case firstFailure results of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # 
                    do _ <- return x;
                    do _ <- op accum " end" (x. return x) (x. return x);
                    return "success"; ) t);
    do first <- map fst pairs;
    do second <- map snd pairs;
    do (m', b) <- k second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
    return ("start " ++ m', v) ) res

{- E-Do and E-Map -}
do res <- (((x. hPure # hAccum # hWeak #  if x == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum x (x. return x)) 1):
            ((x. hPure # hAccum # hWeak #  if x == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum x (x. return x)) 2):
            ((x. hPure # hAccum # hWeak #  if x == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum x (x. return x)) 3):
            ((x. hPure # hAccum # hWeak #  if x == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum x (x. return x)) 4):
            ((x. hPure # hAccum # hWeak #  if x == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum x (x. return x)) 5):[]);
(x. hPure # do (m', v) <- (do pairs <- (hAccum # do results <- hWeak # 
    do _ <- return x;
    do _ <- op accum " end" (x. return x) (x. return x);
    return "success"; 
    case firstFailure results of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # 
                    do _ <- return x;
                    do _ <- op accum " end" (x. return x) (x. return x);
                    return "success"; ) t);
    do first <- map fst pairs;
    do second <- map snd pairs;
    do (m', b) <- k second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
    return ("start " ++ m', v) ) res

{- E-Do and E-ParList and [E-AppAbs*5] -}
do res <- ((hPure # hAccum # hWeak # if 1 == 2
            then
            do _ <- op accum "!" (x. return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum 1 (x. return x)):
            (hPure # hAccum # hWeak # if 2 == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum 2 (x. return x)):
            (hPure # hAccum # hWeak # if 3 == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum 3 (x. return x)):
            (hPure # hAccum # hWeak #  if 4 == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum 4 (x. return x)):
            (hPure # hAccum # hWeak # if 5 == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum 5 (x. return x)):[]);
(x. hPure # do (m', v) <- (do pairs <- (hAccum # do results <- hWeak # 
    do _ <- return x;
    do _ <- op accum " end" (x. return x) (x. return x);
    return "success"; 
    case firstFailure results of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # 
                    do _ <- return x;
                    do _ <- op accum " end" (x. return x) (x. return x);
                    return "success"; ) t);
    do first <- map fst pairs;
    do second <- map snd pairs;
    do (m', b) <- k second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
    return ("start " ++ m', v) ) res

{- E-Do and E-ParList and [E-AppAbs*5] -}
do res <- ((hPure # hAccum # hWeak # if 1 == 2
            then
            do _ <- op accum "!" (x. return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum 1 (x. return x)):
            (hPure # hAccum # hWeak # if 2 == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum 2 (x. return x)):
            (hPure # hAccum # hWeak # if 3 == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum 3 (x. return x)):
            (hPure # hAccum # hWeak #  if 4 == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum 4 (x. return x)):
            (hPure # hAccum # hWeak # if 5 == 2
            then
            do _ <- op accum "!" (x.return x);
            do _ <- op throw "error" (x. return x);
            op accum "unreachable" (x. return x)
            else op accum 5 (x. return x)):[]);
(x. hPure # do (m', v) <- (do pairs <- (hAccum # do results <- hWeak # 
    do _ <- return x;
    do _ <- op accum " end" (x. return x) (x. return x);
    return "success"; 
    case firstFailure results of
        Left err -> return (Left err)
        Right t  -> (x. hWeak # 
                    do _ <- return x;
                    do _ <- op accum " end" (x. return x) (x. return x);
                    return "success"; ) t);
    do first <- map fst pairs;
    do second <- map snd pairs;
    do (m', b) <- k second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
    return ("start " ++ m', v) ) res

{- E-Do and E-ParList and [E-Hand and E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-Hand and E-IfTrue, E-Hand and E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-Hand and E-IfFalse, E-Hand and E-Hand and E-Hand and E-IfFalse] -}
do res <- ((hPure # hAccum # hWeak # op accum 1 (x. return x)):
            (hPure # hAccum # hWeak #  do _ <- op accum "!" (x.return x); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x)):
            (hPure # hAccum # hWeak # op accum 3 (x. return x)):
            (hPure # hAccum # hWeak # op accum 4 (x. return x)):
            (hPure # hAccum # hWeak # op accum 5 (x. return x)):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Hand and E-FwdOp, E-Hand and E-Hand and E-Hand and E-DoOp, E-Hand and E-Hand and E-FwdOp, E-Hand and E-Hand and E-FwdOp, E-Hand and E-Hand and E-FwdOp] -}
do res <- ((hPure # hAccum # op accum 1 (x. hWeak # return x)):
            (hPure # hAccum # hWeak # op accum "!" (x. do _ <- return x; do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x))):
            (hPure # hAccum # op accum 3 (x. hWeak # return x)):
            (hPure # hAccum # op accum 4 (x. hWeak # return x)):
            (hPure # hAccum # op accum 5 (x. hWeak # return x)):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-HandOp, E-Hand and E-Hand and E-FwdOp, E-Hand and E-HandOp, E-Hand and E-HandOp, E-Hand and E-HandOp] -}
do res <- ((hPure # do (m', v) <- (x. hAccum # hWeak # return x) (); return (1 ++ m', v)):
            (hPure # hAccum # op accum "!" (x. hWeak # do _ <- return x; do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x))):
            (hPure # do (m', v) <- (x. hAccum # hWeak # return x) (); return (3 ++ m', v)):
            (hPure # do (m', v) <- (x. hAccum # hWeak # return x) (); return (4 ++ m', v)):
            (hPure # do (m', v) <- (x. hAccum # hWeak # return x) (); return (5 ++ m', v)):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Do and E-AppAbs, E-Hand and E-HandOp, E-Hand and E-Do and E-AppAbs, E-Hand and E-Do and E-AppAbs,E-Hand and E-Do and E-AppAbs] -}
do res <- ((hPure # do (m', v) <- hAccum # hWeak # return (); return (1 ++ m', v)):
            (hPure # do (m', v) <- (x. hAccum # hWeak # do _ <- return x; do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x)) (); return ("!" ++ m', v)):
            (hPure # do (m', v) <- hAccum # hWeak # return (); return (3 ++ m', v)):
            (hPure # do (m', v) <- hAccum # hWeak # return (); return (4 ++ m', v)):
            (hPure # do (m', v) <- hAccum # hWeak # return (); return (5 ++ m', v)):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Do and E-Hand and E-HandRet, E-Hand and E-Do And E-AppAbs, E-Hand and E-Do and E-Hand and E-HandRet, E-Hand and E-Do and E-Hand and E-HandRet, E-Hand and E-Do and E-Hand and E-HandRet] -}
do res <- ((hPure # do (m', v) <- hAccum # return (Right ()); return (1 ++ m', v)):
            (hPure # do (m', v) <- hAccum # hWeak # do _ <- return (); do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x); return ("!" ++ m', v)):
            (hPure # do (m', v) <- hAccum # return (Right ()); return (3 ++ m', v)):
            (hPure # do (m', v) <- hAccum # return (Right ()); return (4 ++ m', v)):
            (hPure # do (m', v) <- hAccum # return (Right ()); return (5 ++ m', v)):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Do and E-HandRet, E-Hand and E-Do And E-Hand and E-Hand and E-DoRet, E-Hand and E-Do and E-HandRet, E-Hand and E-Do and E-HandRet, E-Hand and E-Do and E-HandRet] -}
do res <- ((hPure # do (m', v) <- return ("", Right ()); return (1 ++ m', v)):
            (hPure # do (m', v) <- hAccum # hWeak # do _ <- op throw "error" (x. return x); op accum "unreachable" (x. return x); return ("!" ++ m', v)):
            (hPure # do (m', v) <- return ("", Right ()); return (3 ++ m', v)):
            (hPure # do (m', v) <- return ("", Right ()); return (4 ++ m', v)):
            (hPure # do (m', v) <- return ("", Right ()); return (5 ++ m', v)):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-DoRet, E-Hand and E-Do And E-Hand and E-Hand and E-DoOp, E-Hand and E-DoRet, E-Hand and E-DoRet, E-Hand and E-DoRet] -}
do res <- ((hPure # return ("1", Right ())):
            (hPure # do (m', v) <- hAccum # hWeak # op throw "error" (x. do _ <-  return x; op accum "unreachable" (x. return x)); return ("!" ++ m', v)):
            (hPure # return ("3", Right ())):
            (hPure # return ("4", Right ())):
            (hPure # return ("5", Right ())):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-HandRet, E-Hand and E-Do And E-Hand and E-HandOp, E-HandRet, E-HandRet, E-HandRet] -}
do res <- ((return ("1", Right ())):
            (hPure # do (m', v) <- hAccum # return (Left "error"); return ("!" ++ m', v)):
            (return ("3", Right ())):
            (return ("4", Right ())):
            (return ("5", Right ())):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-Do And E-HandRet] -}
do res <- ((return ("1", Right ())):
            (hPure # do (m', v) <- return ("", Left "error"); return ("!" ++ m', v)):
            (return ("3", Right ())):
            (return ("4", Right ())):
            (return ("5", Right ())):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-Hand and E-DoRet] -}
do res <- ((return ("1", Right ())):
            (hPure # return ("!", Left "Error")):
            (return ("3", Right ())):
            (return ("4", Right ())):
            (return ("5", Right ())):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ParList and [E-HandRet] -}
do res <- ((return ("1", Right ())):
            (return ("!", Left "Error")):
            (return ("3", Right ())):
            (return ("4", Right ())):
            (return ("5", Right ())):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-Do and E-ListRet -}
do res <- return (("1", Right ()):("!", Left "Error"):("3", Right ()):("4", Right ()):("5", Right ()):[]); 
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) res

{- E-DoRet -}
(x. hPure # do (m', v) <- (do first <- map fst x;
    do second <- map snd x;
    do (m', b) <- (x. hAccum #  do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v)) (("1", Right ()):("!", Left "Error"):("3", Right ()):("4", Right ()):("5", Right ()):[])

{- E-AppAbs -}
hPure # do (m', v) <- (do first <- map fst (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-Map -}
hPure # do (m', v) <- (do first <- ((fst ("1", Right ())):(fst ("!", Left "error")):(fst ("3", Right ())):(fst ("4", Right ())):(fst ("5", Right ())):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-Map -}
hPure # do (m', v) <- (do first <- ((fst ("1", Right ())):(fst ("!", Left "error")):(fst ("3", Right ())):(fst ("4", Right ())):(fst ("5", Right ())):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-ParList and [E-First*5] -}
hPure # do (m', v) <- (do first <- ((return "1"):(return "!"):(return "3"):(return "4"):(return "5"):[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-ListRet -}
hPure # do (m', v) <- (do first <- return ("1":"!":"3":"4":"5":[]);
    do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce first;
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-DoRet -}
hPure # do (m', v) <- (do second <- map snd (("1", Right ()):("!", Left "error"):("3", Right ()):("4", Right ()):("5", Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-Map -}
hPure # do (m', v) <- (do second <- ((snd ("1", Right ())):(snd ("!", Left "error")):(snd ("3", Right ())):(snd ("4", Right ())):(snd ("5", Right ())):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-ParList and [E-Second*5] -}
hPure # do (m', v) <- (do second <- ((return (Right ())):(return (Left "error")):(return (Right ())):(return (Right ())):(return (Right ())):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-ListRet -}
hPure # do (m', v) <- (do second <- return ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]);
    do (m', b) <- (x. hAccum # do res <- return x;
                    case firstFailure res of
                        Left err -> return (Left err)
                        Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) second;
    let rec reduce = l.
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-DoRet -}
hPure # do (m', v) <- (do (m', b) <- (x. hAccum # do res <- return x;
                                case firstFailure res of
                                    Left err -> return (Left err)
                                    Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t) ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]);
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 


{- E-Hand and E-Do and E-Do and E-AppAbs -}
hPure # do (m', v) <- (do (m', b) <- hAccum # do res <- return ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]);
                            case firstFailure res of
                                Left err -> return (Left err)
                                Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t);
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-Hand and E-DoRet -}
hPure # do (m', v) <- (do (m', b) <- hAccum # case firstFailure ((Right ()):(Left "error"):(Right ()):(Right ()):(Right ()):[]) of
                                Left err -> return (Left err)
                                Right t  -> (x. hWeak # do _ <- return x; do _ <- op accum " end" (x. return x) (x. return x); return "success") t);
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b);
return ("start " ++ m', v)

--TODO 
{- E-Hand and E-Do and E-Do E-Hand and E-FirstFailLeft -}
hPure # do (m', v) <- (do (m', b) <- hAccum #  return (Left "error");
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-Do and E-HandRet -}
hPure # do (m', v) <- (do (m', b) <- return ("", Left "error");
    let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ m', b));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-DoRet -}
hPure # do (m', v) <- (let rec reduce = l. 
        do n <- null l;
        if n
            then 
                return []
            else
                do h <- head l;
                do t <- tail l;
                do y <- reduce t;
                return (h ++ y) in 
                    do m <- reduce ("1":"!":"3":"4":"5":[]);
                    return (m ++ "", Left "error"));
return ("start " ++ m', v) 

{- E-Hand and E-Do and E-LetRec -}
hPure # do (m', v) <- (do m <- (let rec reduce = l. 
                        do n <- null l;
                        if n
                            then 
                                return []
                            else
                                do h <- head l;
                                do t <- tail l;
                                do y <- reduce t;
                                return (h ++ y) in l. 
                                do n <- null l;
                                if n
                                    then 
                                        return []
                                    else
                                        do h <- head l;
                                        do t <- tail l;
                                        do y <- reduce t;
                                        return (h ++ y)) ("1":"!":"3":"4":"5":[]);
                return (m ++ "", Left "error"));
return ("start " ++ m', v) 

...
{- analogous to let rec reduction in "reductionMap" -}

{- E-Hand and E-Do and E-DoRet -}
hPure # do (m', v) <- return ("1:345", Left "error");
return ("start " ++ m', v) 

{- E-Hand and E-DoRet -}
hPure # return ("start 1:345", Left "error") 

{- E-HandRet -}
return ("start 1:345", Left "error") 
